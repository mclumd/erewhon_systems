(in-package :user)

(defparameter *MCL-port* 5155
  "Port through which Meta-AQUA and MCL communicate."
  )


#|
Examples 

The MCL response string is of the form "ok([Response(parameter=value*)])"

(setf x "ok([response(type=suggestion,ref=0x00000001,code=crc_extended_code,action=true,abort=true,text=\"MCL response = (29,evaluateObject,crc_extended_code)\")])")

CL-USER(69): (read-from-string (substitute #\Space #\, x) t nil :start 2)
([RESPONSE (TYPE=SUGGESTION REF=0X00000001 CODE=CRC_EXTENDED_CODE ACTION=TRUE ABORT=TRUE TEXT= "MCL response = (29 evaluateObject crc_extended_code)") ])
152

[3] CL-USER(80): (seventh (second (read-from-string (substitute #\Space #\, x) t nil :start 2)))
"MCL response = (29 evaluateObject crc_extended_code)"

[3] CL-USER(81): (read-from-string (seventh (second (read-from-string (substitute #\Space #\, x) t nil :start 2))))
MCL
4

CL-USER(8): (second (second (read-from-string (substitute #\Space #\, x) t nil :start 2)))
REF=0X00000001

|#



;;; 
;;; Function parse-response takes as input an MCL response string such as in 
;;; the example above, and it replaces commas with spaces, reads the Lisp 
;;; object after the ok, then returns the response parameters (i.e., fields).
;;; 
(defun parse-response (response)
  ;; Get the response parameters
  (second
   ;; Read the list structure
   (read-from-string 
    (commas2spaces response)
    ;; skips past the "Ok" response part to get to the parenthetical fields
    t nil :start 2) 
   )
  )



(defun commas2spaces (str)
  "Change all commas in input string to spaces."
  (substitute #\Space #\, str)
  )


;;; "hello=world" --> "world"
(defun return-after-equal-sign (str)
  (subseq str 
	  (1+ (position #\= str))
	  (length str))
  )

;;; 
;;; The reference parameter is of the form ref=0x00000001
;;; 
(defun get-ref (parameters)
  (intern				;Change back to symbol
     (return-after-equal-sign 
      (string (second Parameters)))
    )
  )


;;; 
;;; The suggestion parameter is of the form 
;;; TEXT= "MCL response = (29 evaluateObject crc_extended_code)"
;;; although the seventh item in the parameters argument to the function is the
;;; text srting itself.
;;; 
(defun get-suggestion (parameters)
  (second 
   (read-from-string 
    (return-after-equal-sign 
     (seventh parameters))
    ))
  )


    
;;;; 
;;;; File MCL.lisp implements the functions to integrate Meta-AQUA with the 
;;;; MetaCognitive Loop. To use this file, load Prodigy/Agent. Read the file
;;;; README (need to update README).
;;;; 

;;; 
;;; Function prepend-dollar adds a dollar symbol to the front of the input 
;;; symbol. Thus a-symbol --> $a-symbol
;;; 
(defun prepend-dollar (symbol)
  "symbol --> $symbol"
  (intern 
   (coerce 
    (cons #\$ 
	  (coerce (string symbol) 'list)) 
    'string))
  )


;;; 
;;; Function check-with-MCL represents the call frm Meta-AQUA to MCL with the
;;; anomaly-type LUGGAGE. It is currently called from function declare-anomaly.
;;; See file MCL-patches.lisp.
;;;
(defun check-with-MCL (sensor
		       &aux temp 
			    parameters)
  (setf temp
    (user::send2MCL 
     (format nil 
	     "monitor(meta_aqua,{objSensor=~s~a"
	     (user::prepend-dollar sensor)
	     "})")))
  ;;(break "~%temp: ~s" temp)
  (if (equal (intern 'OK) (read-from-string temp))
      (setf parameters 
	(user::parse-response temp)))
  (when parameters
    (format t 
	    "~%Reference frame = ~S"
	    (user::get-ref parameters))
    (format t 
	    "~%MCL Suggestion = ~S"
	    (user::get-suggestion parameters))))


;;; Set 4 environment variables needed for MCL. This may not be necessary from 
;;; within the isp environment. Perform at command prompt instead. See 
;;; cheat-sheet.txt.
;;; 
(defun set-env-vars ()
  (setf (sys:getenv "LD_LIBRARY_PATH") 
    "/fs/metacog/group/mcl/newmcl/mcl_current:/fs/metacog/group/mcl/newmcl/mcl_current/lib")
  (setf (sys:getenv "MCL_CONFIG_PATH")
    "/fs/metacog/group/mcl/newmcl/mcl_current/config/")
  (setf (sys:getenv "MCL") 
    "/fs/metacog/group/mcl/newmcl/mcl_current")
  (setf (sys:getenv "MCL_CORE_PATH") 
    "/fs/metacog/group/mcl/newmcl/mcl_current")
  )


;;; 
;;; Function send2MCL takes a command string and prints it and then sends it to
;;; MCL over the given socket. It flushes the output and reads and prints the
;;; MCL response. Finally the MCL response is returned. Note that MCL will 
;;; return either fail or OK and then a parenthetical comment such as 
;;; "ok(initialized 'meta_aqua'.)" 
;;; 
(defun send2MCL (command-str
		 &optional 
		 (socket *active-socket*)
		 &aux 
		 (MCL-response "")
		 )
  (format t "~%Meta-AQUA: ~s" command-str)
  (format socket command-str)
  (finish-output socket)
  (format t "~%MCL: ~s"
	  (setf MCL-response 
	    (read-line socket)))
  MCL-response
  )


;;; 
;;; Function init-MCL initializes MCL by first establishing a handshake over
;;; the given socket and then by sending MCL commands that initialize and 
;;; configure the system and establish the sensors and expectations. Two trial 
;;; monitor calls are made to test the interface. One should be OK the other 
;;; should fail. 
;;; 
(defun init-MCL (&optional
		 (port 5150)
		 (socket *active-socket*))
  (establish-active-agent-connection port)
  (do ((cmd-list 
	'("initialize(meta_aqua,0)"
	  "configure(meta_aqua,MA,MA)"
	  "declareObservableSelf(meta_aqua,objSensor,0)"
	  "setObsPropSelf(meta_aqua,objSensor,prop_sclass,sc_object)"
	  "addObsLegalValSelf(meta_aqua,objSensor,$PERSON)" ;Was 0 instead of $person
	  "declareEG(meta_aqua,0)"
	  "declareSelfExp(meta_aqua,0,ec_be_legal,objSensor)"
	  ;"monitor(meta_aqua,{objSensor=$person})"
	  ;"monitor(meta_aqua,{objSensor=$luggage})"
	  ;suggestionImplemented(meta_aqua,1)"
	  )
	(rest cmd-list))
       (result "" (send2MCL (first cmd-list))))
      ((or (null cmd-list) (equal result 'FAIL))
       result)
    )
  )




