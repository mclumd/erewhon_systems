This is info/quintus.info, produced by makeinfo version 4.3 from
quintus.texi.

INFO-DIR-SECTION Quintus Prolog
START-INFO-DIR-ENTRY
* Quintus Prolog Manual: (quintus).             The Quintus Prolog User's Manual.
END-INFO-DIR-ENTRY
   Generated 13 January 2004.


File: quintus.info,  Node: glo-glo,  Up: glo

Glossary
========

"abolish"
     To abolish a "predicate" is to "retract" all the predicate's
     "clauses" and to remove all information about it from the Prolog
     system, to make it as if that predicate had never existed.
     "Built-in predicates" cannot be abolished, but user-defined ones
     always can be, even when "static".

"absolute filename"
     A name of a file giving the absolute location of that file.  Under
     UNIX and Windows, Quintus Prolog considers filenames beginning with
     `/' or `~' absolute.  Under Windows, filenames beginning with a
     letter followed by `:' are also considered absolute.  All other
     filenames are considered "relative".

"alphanumeric"
     An alphanumeric character is any of the lowercase characters from
     `a' to `z', the uppercase characters from `A' to `Z', or the
     numerals from `0' to `9'.

"ancestor"
     An ancestor of a "goal" is any goal that the system is trying to
     solve when it calls that goal.  The most distant ancestor is the
     goal that was typed at the top-level prompt.

"anonymous"
     An anonymous "variable" is one that has no unique name, and whose
     value is therefore inaccessible.  An anonymous variable is denoted
     by an underscore (_).

"archive file"
     A file containing an "object code" library that can be statically
     linked into programs.  Sometimes called "static library".  Archive
     files have an operating system dependent extension, which is:
    Windows:
          `.lib' By convention, Quintus Prolog uses the suffix `s.lib'
          (e.g., `libqps.lib') since a `.lib' is also used for Windows
          DLL import libraries.

    UNIX:
          samp{.a}

"argument"
     See "predicate", "structure", and "arity".

"arity"
     The arity of a "structure" is its number of "argument"s.  For
     example, the structure `customer(jones, 85)' has an arity of 2.

"atom"
     A character sequence used to uniquely denote some entity in the
     problem domain.  A number is _not_ an atom.  Examples of legal
     atoms are:
          hello   *   '#$%'   'New York'   'don''t'

     *Please note:*  An atom may not start with a capital letter or
     underscore unless that atom is enclosed in single quotes.
     Character sequences that include spaces must also be enclosed in
     single quotes.  To include a single quote in an atom, print it
     twice in succession for each single quote that is to appear.  See
     the *Note ref-syn-trm-ato::  for a complete definition of an atom.

"atomic term"
     Synonym for "simple term" or "constant".

"backtracking"
     The process of reviewing the "goal"s that have been satisfied and
     attempting to resatisfy these goals by finding alternative
     solutions.

"binding"
     The process of assigning a value to a "variable"; used in
     "unification".

"body"
     The body of a "clause" consists of the part of a Prolog clause
     following the `:- ' symbol.

"buffer"
     A temporary workspace in Emacs that contains a file being edited.

"built-in predicate"
     A "predicate" that comes with the system and that does not have to
     be explicitly "consult"ed or "compile"d before it is used.

"clause"
     A "fact" or a "rule".  A rule comprises a "head" and a "body".  A
     fact consists of a head only, and is equivalent to a rule with the
     body `true'.

"command"
     An instruction for the Prolog system to perform an action
     involving "side-effects".  If the command is written preceded by a
     ` :- ', it will be executed as a "directive".

"compile"
     Load a program (or a portion thereof) into Prolog through the
     compiler.  Compiled code runs more quickly than interpreted code,
     but you cannot debug compiled code in as much detail as
     interpreted code.

"compound term"
     See "structure".

"connective"
     a logical "term", or a symbol thereof, that relates components in
     such a way that the truth or falsity of the resulting statement is
     determined by the truth or falsity of the components.  For example,
          :-     ;     ,

     stand for the connectives `if', `or', and `and'.

"constant"
     An integer (for example:  1, 20, -10), a floating-point number
     (for example:  12.35), or an "atom" (for example:  `'New York'').
     Constants are also known as "simple term"s, and are recognized by
     the Prolog predicate `atomic/1'.

"consult"
     Load a program (or a portion thereof) into Prolog through the
     interpreter.  Interpreted code runs more slowly than compiled
     code, but you can debug interpreted code in more detail than
     compiled code.

"creep"
     What the debugger does in "trace" mode, also known as
     single-stepping.  It goes to the next "port" of a "procedure" box
     and prints the "goal", then prompts you for input.  See *Note
     dbg-bas-bas::.

"cross-reference"
     A notation in the text of the manual, pointing to another section
     of the manual containing related information.  In the on-line
     manual, these are of the form {MANUAL(TAG)}, as in "see
     {manual(int-man-ove)}."  Typing the text between the braces into
     the Prolog system will cause the text of the referenced section to
     be displayed.

"cursor"
     The point on the screen at which typed characters appear.  This is
     usually highlighted by a line or rectangle the size of one space,
            which may or may not blink.

"cut"
     Written as `!'.  A "built-in predicate" that succeeds when
     encountered; if "backtracking" should later return to the cut, the
     "goal" that matched the "head" of the "clause" containing the cut
     fails immediately.

"database"
     The Prolog database comprises all of the "clause"s that have been
     "load"ed into the Prolog system via `compile/1', `consult/1', or
     that have been asserted, excepting those clauses that have been
     removed by `retract/1' or `abolish/[1,2]'

"debug"
     A mode of "program" execution in which the debugger stops to print
     the current "goal" only at "procedures" that have "spypoints" set
     on them (see "trace").

"determinate"
     A "procedure" is determinate if it can supply only one answer.

"directive"
     A directive is a "command" preceded by the prefix operator `:- ',
     whose intuitive meaning is "execute this as a command, but do not
     print out any variable bindings."

"disjunction"
     A series of "goal"s connected by the "connective" "or" (that is, a
     series of goals whose principal "operator" is `|' or `;').

"dynamic predicate"
     A predicate that can be modified while a "program" is running.  A
     "predicate" must explicitly be declared to be dynamic or it must
     be added to the "database" via one of the assertion predicates.

"environment variable"
     A variable known to the command interpreter environment.  Most
     programs can be controlled to some extent by environment
     variables.  The syntax for setting environment variables in
     command interpreter dependent.  For example, (A) would be
     appropriate for `csh(1)' and `tcsh(1)'; (B) for `sh(1)',
     `bash(1)', and `ksh(1)'; (C) for Windows `cmd.exe'.  Under
     Windows, it is often preferable to set environment variables
     globally in the System control panel.

          % setenv PROLOGINITSIZE 2M (A)
          % export PROLOGINITSIZE=2M (B)
          % SET PROLOGINITSIZE=2M (C)

"export"
     A "module" exports a "procedure" by making that procedure
     "public", so that other modules can "import" it.

"fact"
     (Also called a "unit clause".)  A "clause" with no
     "conditions"--that is, with an empty "body".  A fact is a
     statement that a relationship exists between its "arguments".  Some
     examples, with possible interpretations, are:
          king(louis, france).   % Louis was king of France.
          have_beaks(birds).     % Birds have beaks.
          employee(nancy, data_processing, 55000).
                               % Nancy is an employee in the
                               % data processing department.

     An integer number assigned to a file when it is opened, and then
     used as a unique identifier in I/O operations.

"first-order logic"
     A system of logic in which the values of "variables" may range
     over the data items in the domain.  In Prolog these data items are
     "terms".  For comparison, in zero-order logic (also known as
     propositional logic) there are no variables, and in second-order
     logic the values of variables are allowed to range both over data
     items and over functions and relations.

"functor"
     The name and "arity" of a "structure".  For example, the structure
     `foo(a, b)' is said to have "the functor foo of arity two", which
     is generally written `foo/2'.

"garbage collection"
     The freeing up of space for computation by making the space
     occupied by "terms" that are no longer available for use by the
     Prolog system.

"goal"
     A "procedure" call.  When called, it will either succeed or fail.
     A goal typed at the top level is called a "query".

"head"
     The head of a "clause" is the single "goal" that will be satisfied
     if the "conditions" in the "body" (if any) are true; the part of a
     "rule" before the `:- ' symbol.  The head of a "list" is the first
     element of the list.

"home directory"
     Your default directory upon login.  Under UNIX, this is the value
     of the `HOME' environment variable.  Under Windows, it is the
     directory specified by the environment variables `HOMEDRIVE' and
     `HOMEPATH'.  You can ask Quintus Prolog what it considers to be
     you home directory by typing
          | ?- absolute_file_name(~, HomeDir).

"Horn clause"
     See "clause".

"import"
     "Public" "procedures" in a "module" can be imported by other
     modules.  Once a procedure has been imported by a module, it can
     be called as if it were defined in that module.

     There are two kinds of importation:  procedure-importation, in
     which only specified procedures are imported from a module; and
     module-importation, in which all the predicates made public by a
     module are imported.

"instantiation"
     A "variable" is instantiated if it is "bound" to a non-variable
     "term"; that is, to an "atomic term" (see "constant") or a
     "compound term".

"interpret"
     Load a "program" or set of "clauses" into Prolog through the
     interpreter (also known as "consulting").  Interpreted code runs
     much more slowly than "compiled" code, but more extensive
     facilities are available for debugging interpreted code.

"leap"
     What the debugger does in "debug" mode.  The debugger shows only
     the "ports" of "procedures" that have "spypoints" on them. It then
            prompts you for input, at which time you may leap again to
     the         next spypoint.  See *Note dbg-bas-tra-spy::.

"leashing"
     Determines how frequently the debugger will stop and prompt you
     for input when you are "tracing".  A "port" at which the debugger
     stops is called a "leashed port."

"list"
     A list is written as a set of zero or more "term"s between square
     brackets.  If there are no terms in a list, it is said to be
     empty, and is written as [].  In this first set of examples, all
     members of each list are explicitly stated.
          [aa, bb,cc]  [X, Y]  [Name]  [[x, y], z]

     In the second set of examples, only the first several members of
     each list are explicitly stated, while the rest of the list is
     represented by a "variable" on the right-hand side of the "rest
     of" operator, `|':

          [X | Y]  [a, b, c | Y]  [[x, y] | Rest]

     `|' is also known as the "list constructor."  The first element of
     the list to the left of `|' is called the "head" of the list.  The
     rest of the list, including the variable following `|' (which
     represents a list of any length), is called the "tail" of the list.

     For example,
          list              head        tail
          [X | Y]           X           Y
          [a, b, c | y]     a           [b, c | y]
          [[X, Y] | Rest]   [X, Y]      Rest

"load"
     To "compile" or "consult" a Prolog "clause" or set of clauses.

"meta-predicate"
     A meta-predicate is one that calls one or more of its "arguments";
     more generally, any "predicate" that needs to assume some "module"
     in order to operate is called a meta-predicate.

     A meta-predicate declaration is a "term" in a "module-file" that
     is associated with a given "functor", sharing its "name" and
     "arity", but having each of its "arguments" replaced either by one
     of the mode annotations `+', `-', `*', `+-', `+*', or by `:' or a
     non-negative integer.  `:' or a non-negative integer signifies that
     the corresponding argument requires module name expansion.

"mode line"
     The information line at the bottom of each Emacs "window" that is
     one line long and the width of the screen; often shown in reverse
     video.  The mode line at the bottom of the Prolog window says
     "Quintus Prolog" plus other information such as the state of the
     debugger if it is activated.  The mode line of the text window(s)
     states the "buffer"name, the filename, the editor mode ("Prolog"
     for a file ending in `.pl'), and the percentage of the file that
     precedes the "cursor".

"module"
     A module is a set of "procedures" in a "module-file".  Some
     procedures in a module are "public".  The default module is `user'.

"module-file"
     A module-file is a file that is headed with a "module" declaration
     of the form
          :- module(MODULENAME, PUBLICPREDLIST).

     which must appear as the first "term" in the file.

"multifile predicate"
     A "predicate" whose definition is to be spread over more than one
     file. Such a predicate must be preceded by an explicit multifile
     declaration in the first file containing "clauses" for it.

"name clash"
     A name clash occurs when a "module" attempts to define or "import"
     a "procedure" that it has already defined or imported.

"object code"
     The machine-executable, as opposed to the human-readable,
     representation of a "program".

"object file"
     A file containing "object code".  Object files have an operating
     system dependent extension, which is:
    Windows:
          `.obj'

    UNIX:
          samp{.o}

"operator"
     A notational convenience that allows you to express any "compound
     term" in a different format.  For example, if "likes" in
          | ?- likes(sue, cider).

     is declared an infix operator, the query above could be written:
          | ?- sue likes cider.

     An operator does not have to be associated with a "predicate".
     However, certain "built-in predicates" are declared as operators.
     For example,
          | ?- =..(X, Y).

     can be written as
          | ?- X =.. Y.

     because `=..' has been declared an infix operator.

     Those predicates that correspond to built-in operators are written
     using infix notation in the list of built-in predicates at the
     beginning of the part that contains the reference pages.

     Some built-in operators do _not_ correspond to built-in
     predicates; for example, arithmetic operators.  *Note
     ref-syn-ops-bop:: contains a list of built-in operators.

"parent"
     The "parent" of the current "goal" is a goal that, in its attempt
     to obtain a successful solution to itself, is calling the current
     goal.

"port"
     One of the four key points of interest in the execution of a
     Prolog "procedure".  There are four ports: the Call port,
     representing the initial invocation of the procedure; the Exit
     Port, representing a successful return from the procedure; the Redo
     port, representing reinvocation of the procedure through
     "backtracking"; and the Fail port, representing an unsuccessful
     return due to the failure of the initial "goal" of the procedure.

"precedence"
     A number associated with each Prolog "operator", which is used to
     disambiguate the structure of the term represented by an
     expression containing a number of operators.  Operators of lower
     precedence are applied before those of higher precedence; the
     operator with the highest precedence is considered the principal
     "functor" of the expression.  To disambiguate operators of the same
     precedence, the associativity type is also necessary.  See the
     syntax chapter (*Note ref-syn::).

"predicate"
     A "functor" that specifies some relationship existing in the
     problem domain.  For example, `</2' is a built-in "predicate"
     specifying the relationship of one number being less than another.
     In contrast, the functor `+/2' is not (normally used as) a
     predicate.

     A predicate is either "built-in" or is implemented by a
     "procedure".

"procedure"
     A set of "clauses" in which the "head" of each clause has the same
     "predicate".  For instance, a group of clauses of the following
     form:
          connects(san_francisco, oakland, bart_train).
          connects(san_francisco, fremont, bart_train).
          connects(concord, daly_city, bart_train).

     is identified as belonging to the procedure `connects/3'.

"program"
     A set of "procedures" designed to perform a given task.

"public"
     A "procedure" in a "module" is public if it can be "imported" by
     other modules.  The public predicates of a module are listed in
     the module declaration (see "module-file").

"QOF file"
     a fully general way of storing arbitrary Prolog facts and rules in
     a form that can be quickly and easily used.  QOF files contain a
     machine independent representation of both compiled and dynamic
     Prolog predicates.  This means they are completely portable
     between different platforms running Quintus Prolog.

"query"
        - "simple query":   A query is a question put by the user to the
          Prolog system.  A simple query is written as a "goal"
          followed by a "full-stop" in response to the Prolog system
          prompt.  For example,
               | ?- father(edward, ralph).

          refers to the "predicate" `father/2'.  If a query has no
          "variable"s in it, the system will respond either `yes' or
          `no.' If a query contains variables, the system will try to
          find values of those variables for which the query is true.
          For example,
               | ?- father(edward, X).
               X = ralph

          After the system has found one answer, the user can direct
          the system to look for additional answers to the query by
          typing `; <RET>'.

        - "compound query":   A compound query consists of two or more
          simple queries connected by commas.  For a compound query to
          be true, all of its "goal"s must be true simultaneously.  For
          example, the following compound query will find Ralph's
          grandfather (G):
               | ?- father(G, F), father(F, ralph).

          `F' is a shared "variable" that is constrained by
          "unification" to have the same value in each of the two
          subgoals.

"quintus-directory"
     The root directory of the entire Quintus Prolog file hierarchy.
     Used by Prolog executables to relocate certain relative file names.
     Is the value of the `quintus_directory' Prolog flag.  See *Note
     int-dir::.

"recursion"
     The process in which a running "procedure" calls itself,
     presumably with different "arguments" and for the purpose of
     solving some subset of the original problem.

"region"
     The text between the  "cursor" and a previously-set mark in an
     Emacs buffer.

"relative filename"
     A name of a file giving the location of that file relative to the
     working directory.  See "absolute filename" about differentiating
     absolute filenames from relative ones.

"rule"
     A "clause" with one or more "conditions".  For a rule to be true,
     all of its conditions must also be true.  For example,
          has_stiff_neck(ralph) :-
             hacker(ralph).

     This rule states that if the individual `ralph' is a hacker, then
     he must also have a stiff neck.  The "constant" `ralph' is
     replaced in
          has_stiff_neck(X) :-
             hacker(X).

     by the "variable" X.  X "unifies" with anything, so this rule can
     be used to prove that any hacker has a stiff neck.

"runtime-directory"
     A platform-specific directory containing Quintus Prolog
     executables, object files and the like.  Is the value of the
     `runtime_directory' Prolog flag.  See *Note int-dir::.

"saved-state"
     A snapshot of the state of Prolog saved in a file by
     `save_program/1', `save_modules/2', or `save_predicates/2'.
     `save_program/1' saves the whole Prolog data base, `save_modules/2'
     and `save_predicates/2' save a list of modules and predicates
     respectively.

"semantics"
     The relation between the set of Prolog symbols and their
     combinations (as Prolog "terms" and "clauses"), and their meanings.
     Compare "syntax".

"static library"
     See "shared object file".

"shared object file"
     A file containing "object code" that can be dynamically loaded
     into programs.  Sometimes called "shared library".  Shared object
     files have an operating system dependent extension, which is:
    Windows:
          `.dll'

    HPUX:
          samp{.sl}

    other UNIX:
          samp{.so}

"side-effect"
     A "predicate" that produces a side-effect is one that has any
     effect on the "outside world" (the user's terminal, a file, etc.),
     or that changes the Prolog "database".

"simple term"
     see "constant".

"source code"
     The human-readable, as opposed to the machine-executable,
     representation of a "program".

"spypoint"
     A flag placed on a "predicate" by the command `spy/1' and removed
     by `nospy/1' that tells the debugger to stop execution and allow
     user interaction at "goals" for that predicate.  Any number of
     predicates can have spypoints set on them.

"static library"
     See "archive file".

"static predicate"
     A "predicate" that can be modified only by being reloaded via the
     "consult" or "compile" facility or by being "abolish"ed.    (See
     "dynamic predicate".)

"stream"
     An input/output channel.

"structure"
     (Also called a "compound term".)  A structure is a "functor"
     together with zero or more "argument"s.  For example, in the
     structure
          father(X)

     `father/1' is the functor, and X is the first and only argument.
     The argument to a structure can be another structure, as in
          father(father(X))

"syntax"
     The part of Prolog grammar dealing with the way in which symbols
     are put together to form legal Prolog "terms".  Compare
     "semantics".

"term"
     A basic data object in Prolog.  A term can be a "constant", a
     "variable", or a "structure".

"trace"
     A mode of "program" execution in which the debugger single-steps
     to the next "port" and prints the "goal".

"unbound"
     A "variable" is unbound if it has not yet been "instantiated".

"unification"
     The process of matching a "goal" with the "head" of a "clause"
     during the evaluation of a "query", or of matching arbitrary terms
     with one another during "program" execution.  A goal unifies with
     the head of a clause if 1) they have the same "functor", and 2)
     all of the "argument" "term"s can be unified.  The rules governing
     the unification of terms are:
        * Two "constant"s unify with one another if they are identical.

        * A "variable" unifies with a "constant" or a "structure".  As
          a result of the unification, the variable is "instantiated"
          to the constant or structure.

        * A variable unifies with another variable.  As a result of the
          unification, they become the same variable.

        * A structure unifies with another structure if they have the
          same functor and if all of the arguments can be unified.

"unit clause"
     See "fact".

"variable"
     Logical variable.  A logical variable is a name that stands for
     objects that may or may not be determined at a specific point in a
     Prolog "program".  When the object for which the variable stands
     is determined in the Prolog program, the variable becomes
     instantiated (see "instantiation").  A logical variable may be
     unified (see "unification") with a "constant", a "structure", or
     another variable.  Variables become uninstantiated when the
     procedure they occur in backtracks (see "backtracking") past the
     point at which they were instantiated.

     A variable is written as a single word (with no intervening spaces)
     beginning either with a capital letter without quotes, or with the
     character `_'.  Examples:
          X   Y   Z   Name   Position   _c   _305  One_stop

"volatile"
     Predicate property.  The clauses of a volatile predicate are not
     saved by in QOF files by the Prolog `save' predicates.  However,
     they are saved by `qpc'.

"window"
     Under the Emacs interface, a region of the terminal screen.  There
     are two types of window:  the Prolog window, of which there is
     exactly one, and the the text window, of which there are one or
     more.  Each window has a "mode line" at the bottom, and each text
     window displays the contents of one file.


File: quintus.info,  Node: ref,  Next: sap,  Prev: glo,  Up: Top

The Prolog Language
*******************

* Menu:

* ref-ari::                             Arithmetic
* ref-mdb::                             Modification of the Database
* ref-ere::                             Errors and Exceptions
* ref-fdi::                             Files and Directories
* ref-gru::                             Grammar Rules
* ref-olh::                             On-line Help
* ref-pro::                             Invoking Prolog
* ref-iou::                             Input and Output
* ref-lod::                             Loading Programs
* ref-iex::                             Interrupting Execution
* ref-lps::                             Looking at the Program State
* ref-lte::                             Looking at Terms
* ref-mgc::                             Memory Use and Garbage Collection
* ref-msg::                             Messages
* ref-mod::                             Modules
* ref-sls::                             Saving and Loading the Prolog Database
* ref-sem::                             Semantics
* ref-all::                             Sets and Bags:  Collecting Solutions to a Goal
* ref-syn::                             Syntax
* ref-aos::                             Access to the Operating System


File: quintus.info,  Node: ref-syn,  Next: ref-aos,  Prev: ref-all,  Up: ref

Syntax
======

* Menu:

* ref-syn-ove::                         Overview
* ref-syn-trm::                         Terms
* ref-syn-cpt::                         Compound Terms
* ref-syn-ces::                         Character Escaping
* ref-syn-ops::                         Operators and their Built-in Predicates
* ref-syn-com::                         Commenting
* ref-syn-spc::                         Predicate Specifications
* ref-syn-syn::                         Formal Syntax
* ref-syn-sum::                         Summary of Predicates


File: quintus.info,  Node: ref-syn-ove,  Next: ref-syn-trm,  Up: ref-syn

Overview
--------

   This section describes the syntax of Quintus Prolog.


File: quintus.info,  Node: ref-syn-trm,  Next: ref-syn-cpt,  Prev: ref-syn-ove,  Up: ref-syn

Terms
-----

* Menu:

* ref-syn-trm-ove::                     Overview
* ref-syn-trm-int::                     Integers
* ref-syn-trm-flo::                     Floating-point Numbers
* ref-syn-trm-ato::                     Atoms
* ref-syn-trm-var::                     Variables
* ref-syn-trm-fte::                     Foreign Terms


File: quintus.info,  Node: ref-syn-trm-ove,  Next: ref-syn-trm-int,  Up: ref-syn-trm

Overview
........

   The data objects of the language are called  "term"s.  A  term  is
either a "constant", a "variable", or a "compound term".

   A constant is either a "number" (integer or floating-point) or an
"atom".  Constants  are definite elementary objects, and correspond to
proper nouns in natural language.

   Variables and compound terms are described in *Note
ref-syn-trm-var::, and  *Note ref-syn-cpt::, respectively.

   Foreign data types are discussed in *Note str::, on the Structs
library package.


File: quintus.info,  Node: ref-syn-trm-int,  Next: ref-syn-trm-flo,  Prev: ref-syn-trm-ove,  Up: ref-syn-trm

Integers
........

   The printed form of an integer consists of a sequence of digits
optionally preceded by a minus sign (`-').  These are normally
interpreted as base 10 integers.  It is also possible to enter integers
in other bases (1 through 36); this is done by preceding the digit
string by the base (in decimal) followed by an apostrophe.  If a base
greater than 10 is used, the characters A-Z or a-z are used to stand
for digits greater than 9.

   Examples of valid integer representations are:
     1   -2345   85923   8'777   16'3F4A   -12'2A9

   Note that
     +525

   is not a valid integer.

   A base of zero will return the ASCII code of the (single) character
after the quote; for example,
     0'a = 97


File: quintus.info,  Node: ref-syn-trm-flo,  Next: ref-syn-trm-ato,  Prev: ref-syn-trm-int,  Up: ref-syn-trm

Floating-point Numbers
......................

   A floating-point number (float) consists of a sequence of digits with
an embedded decimal point, optionally preceded by a minus sign (-), and
optionally followed by an exponent consisting of upper- or lowercase
`E' and a signed base 10 integer.  Examples of floats are:
     1.0   -23.45   187.6E12   -0.0234e15   12.0E-2

   Note that there must be at least one digit before, and one digit
after, the decimal point.


File: quintus.info,  Node: ref-syn-trm-ato,  Next: ref-syn-trm-var,  Prev: ref-syn-trm-flo,  Up: ref-syn-trm

Atoms
.....

   An atom is identified by its name, which is a sequence of up to 65532
characters (other than the null character).  An atom can be written in
any of the following forms:

   * Any sequence of alphanumeric characters (including `_'), starting
     with a lowercase letter.  Note that an atom may not begin with an
     underscore.

   * Any sequence from the following set of characters (except `/*',
     which begins a comment):
          + - * / \ ^ < > = ` ~ : . ? @ # $ &

   * Any sequence of characters delimited by single quotes, such as:
          'yes'  '%'

     If the single quote character is included in the sequence it must
     be written twice, for example:
           'can''t'  ''''

     For further details see *Note ref-syn-syn-nte::.

   * Any of:
          ! ; [] {}
      Note that the bracket pairs are special: `[]' and `{}' are
     atoms but `[', `]', `{', and `}' are not.  The form `[X]' is a
     special notation for lists (see *Note ref-syn-cpt-lis::), and the
     form `{X}' is allowed as an alternative to `{}(X)'.

   Examples of atoms are:
     a   void   =   :=   'Anything in quotes'   []

     WARNING: It is recommended that you do not invent atoms beginning
     with the character `$', since it is possible that such names may
     conflict with the names of atoms having special significance for
     certain built-in predicates.


File: quintus.info,  Node: ref-syn-trm-var,  Next: ref-syn-trm-fte,  Prev: ref-syn-trm-ato,  Up: ref-syn-trm

Variables
.........

   Variables may be written as any sequence of alphanumeric characters
(including `_') beginning with either a capital letter or `_'.  For
example:
     X   Value   A   A1   _3   _RESULT

   If a variable is referred to only once in a clause, it does not need
to be named and may be written as an "anonymous" variable, represented
by the underline character `_' by itself.  Any number of anonymous
variables may appear in a clause; they are read as distinct variables.
Anonymous variables are not special at runtime.


File: quintus.info,  Node: ref-syn-trm-fte,  Prev: ref-syn-trm-var,  Up: ref-syn-trm

Foreign Terms
.............

   Pointers to C data structures can be handled using the Structs
package, described in *Note str::.


File: quintus.info,  Node: ref-syn-cpt,  Next: ref-syn-ces,  Prev: ref-syn-trm,  Up: ref-syn

Compound Terms
--------------

* Menu:

* ref-syn-cpt-lis::                     Lists
* ref-syn-cpt-sli::                     Strings As Lists

   The structured data objects of Prolog are compound terms.  A
compound term comprises a "name" (called the "principal functor" of the
term) and a sequence of one or more terms called "arguments".  A
functor is characterized by its "name", which is an atom, and its
"arity" or number of arguments.  For example, the compound term whose
principal functor is `point' of arity 3, and which has arguments X, Y,
and Z, is written
     point(X, Y, Z)

   When we need to refer explicitly to a functor we will normally
denote it by the form NAME/ARITY.  Thus, the functor `point' of arity 3
is denoted
     point/3

   Note that a functor of arity 0 is represented as an atom.

   Functors are generally  analogous  to  common  nouns  in  natural
language.   One  may  think  of  a  functor  as  a record type and the
arguments of a compound term as the  fields  of  a  record.   Compound
terms are usefully pictured as trees.  For example, the (compound) term
     s(np(john), vp(v(likes), np(mary)))

   would be pictured as the following tree:

                       s
                     /   \
                  np       vp
                  |       /  \
                john     v     np
                         |     |
                       likes  mary

   The principal functor of this term is `s/2'.  Its arguments are also
compound terms.  In illustration, the principal functor of the first
argument is `np/1'.

   Sometimes it is convenient to write certain functors as "operators";
binary functors (that is, functors of two arguments)  may be declared as
"infix" operators, and unary functors (that is, functors of one
argument) may be declared as either "prefix" or "postfix" operators.
Thus it is possible to write

     X+Y     P;Q     X<Y      +X     P;

   as optional alternatives to
     +(X,Y)   ;(P,Q)   <(X,Y)   +(X)   ;(P)

   The use of operators is described fully in *Note ref-syn-ops::.


File: quintus.info,  Node: ref-syn-cpt-lis,  Next: ref-syn-cpt-sli,  Up: ref-syn-cpt

Lists
.....

   "Lists" form an important class of data structures in Prolog.  They
are essentially the same as the lists of Lisp: a list is either the
atom `[]', representing the empty list, or else a compound term with
functor `.'  and two arguments, which are the head and tail of the list
respectively, where the tail of a list is another list.  Thus a list of
the first three natural numbers is the structure
                  .
                 / \
                1    .
                    / \
                   2    .
                       / \
                      3   []

   which could be written using the standard syntax, as (A) but which
is normally written in a special list notation, as (B).  Two examples
of this list notation, as used when the tail of  a  list  is a
variable, are (C), which represent the structure in (D).

     .(1,.(2,.(3,[]))) (A)

     [1,2,3] (B)

     [X|L]     [a,b|L] (C)

                  .               .
                 / \             / \
               X     L         a     .
                                    / \
                                  b     L (D)

   Note that the notation [X|L] does not add any new power to the
language; it simply improves readability.  These examples could be
written equally well as (E).

      .(X,L) .(a,.(b,L)) (E)


File: quintus.info,  Node: ref-syn-cpt-sli,  Prev: ref-syn-cpt-lis,  Up: ref-syn-cpt

Strings As Lists
................

   For convenience, a further  notational  variant  is  allowed  for
lists  of  integers that correspond to ASCII character codes.  Lists
written in this notation are called "strings".  For example,
     "Humpty-Dumpty"

   represents exactly the same list as
     [72,117,109,112,116,121,45,68,117,109,112,116,121]


File: quintus.info,  Node: ref-syn-ces,  Next: ref-syn-ops,  Prev: ref-syn-cpt,  Up: ref-syn

Character Escaping
------------------

   The character escaping facility allows escape sequences to occur
within strings and quoted atoms, so that programmers can put
non-printable characters in atoms and strings and still be able to see
what they are doing.  This facility can be switched on and off by the
commands:
     | ?- prolog_flag(character_escapes, _, on).
     
     | ?- prolog_flag(character_escapes, _, off).

   See *Note ref-lps-ove::, for a description of `prolog_flag/3'.
Character escaping is off by default.

   Strings or quoted atoms containing the following escape sequences
can occur in terms obtained by `read/[1,2]', `compile/1', and so on.

   The 0' notation for the integer code of a character is also affected
by character escaping.

   With character escaping turned on, the only things that can occur in
a string or quoted atom are the characters with ASCII codes 9
(horizontal tab), 32 (space), 33 through 126 (non-layout characters),
or one of the following escape sequences:
The escape sequence:
     Is converted to:

`\b'
     backspace (ASCII 8)

`\t'
     horizontal tab (ASCII 9)

`\n'
     new line (ASCII 10)
`\v'
     vertical tab (ASCII 11)

`\f'
     form feed (ASCII 12)

`\r'
     carriage return (ASCII 13)

`\e'
     escape (ASCII 27)

`\d'
     delete (ASCII 127)

`\a'
     alarm = BEL (ASCII 7)

`\xCD'
     the ASCII character with code `CD' (hexadecimal number)

`\OCTAL STRING'
     the ASCII character with code OCTAL STRING base 8, where <octal
     string> is either 1, 2, or 3 octal digits

`\^<control char>'
     the ASCII character whose code is the ASCII code of CONTROL CHAR
     mod 32.  `\^?' is another name for `\d'.

`\LAYOUT CHAR'
     no character, where LAYOUT CHAR is a character with ASCII code =<
     32 or ASCII code >= 127 (thus a newline or form-feed in a string
     or quoted atom can be ignored by immediately preceding it with a
     backslash)

`\c'
     no character; also, all characters up to, but not including, the
     next non-layout character are ignored

`\OTHER'
     the character OTHER, where OTHER is any character not predefined
     here; thus `\\' should be used to insert one backslash

   It is an error if an escape sequence or ASCII character that is not
defined above occurs in a string or quoted atom.  For instance, an
ordinary newline in an atom or string is regarded as an error when
character escapes are on.  This allows the syntax error of a missing
closing quote to be caught much earlier, but it has the problem that
some old programs will break (which is why character_escapses are off
by default).

   With character escaping turned on, the escape sequence `\''
represents the same character as the sequence `''' within a quoted
atom, namely one single quote.  Similarly, with character escaping
turned on, the escape sequence `\"' represents the same character as
the sequence `""' within a string, namely one double quote.

   The escape sequence `\c' (c for continue) is useful when formatting
a string for readability.  For example, the atom (A), is equivalent to
(B):
                '!Ruth \c (A)
                  Gehrig \c
                  Cobb \c
                  Williams!'

          '!Ruth Gehrig Cobb Williams!' (B)

   The following sequence denotes the integer 9:
     0'\t


File: quintus.info,  Node: ref-syn-ops,  Next: ref-syn-com,  Prev: ref-syn-ces,  Up: ref-syn

Operators and their Built-in Predicates
---------------------------------------

* Menu:

* ref-syn-ops-ove::                     Overview
* ref-syn-ops-ops::                     Manipulating and Inspecting Operators
* ref-syn-ops-res::                     Syntax Restrictions
* ref-syn-ops-bop::                     Built-in Operators


File: quintus.info,  Node: ref-syn-ops-ove,  Next: ref-syn-ops-ops,  Up: ref-syn-ops

Overview
........

   Operators in Prolog are simply a notational convenience.  For
example, `+' is an infix operator, so
     2 + 1

   is an alternative way of writing the term `+(2, 1)'.  That is, `2 +
1' represents the data structure
                +
              /   \
             2     1

   and _not_ the number 3.  (The addition would only be performed if
the structure were passed as an argument to an appropriate procedure,
such as `is/2'; see *Note ref-ari-eae::.)

   Prolog syntax allows operators of three kinds: "infix", "prefix",
and "postfix".  An infix operator appears between its two arguments,
while a prefix operator precedes its single argument and a postfix
operator follows its single argument.

   Each operator has a "precedence", which is a number from  1  to
1200.  The  precedence  is  used  to  disambiguate expressions  in
which  the  structure  of  the  term  denoted is not made explicit
through the  use  of  parentheses.   The  general  rule is that the
operator with the _highest_ precedence is the principal functor.  Thus
if `+'  has  a higher precedence than `/', then
     a+b/c     a+(b/c)

   are equivalent, and denote the term `+(a,/(b,c))'. Note that the
infix form of the term `/(+(a,b),c)' must be written with explicit
parentheses:
     (a+b)/c

   If there are two operators in the expression having  the  same
highest precedence,  the ambiguity must be resolved from the "types" of
the operators.  The possible types for an infix operator are
   * `xfx'

   * `xfy'

   * `yfx'

   Operators of type `xfx' are not associative:  it is required that
both of the arguments of the operator be subexpressions of _lower_
precedence than the operator itself; that is, the principal functor of
each subexpression must be of lower precedence, unless the
subexpression is written in parentheses (which gives it zero
precedence).

   Operators of type `xfy' are right-associative: only the first
(left-hand) subexpression must be of lower precedence;  the right-hand
subexpression can be of the _same_  precedence  as the main operator.
Left-associative operators (type `yfx') are the other way around.

   An atom named NAME is  declared  as  an operator of type TYPE and
precedence PRECEDENCE by the command
     :-op(PRECEDENCE, TYPE, NAME).

   An operator declaration can be cancelled by redeclaring the NAME
with the same TYPE, but PRECEDENCE 0.

   The argument NAME can also be a list of names of operators of the
same type and precedence.

   It is possible to have more than one operator of the  same  name, so
long as they are of different kinds:  infix, prefix, or postfix.  An
operator of any kind may be redefined by a new declaration  of  the
same  kind.  Declarations for all these "built-in operators" can be
found in *Note ref-syn-ops-bop::.

   For example, the built-in operators `+' and `-' are as if they had
been declared by (A) so that (B) is valid syntax, and means (C) or
pictorially (D).
     :-op(500, yfx, [+,-]). (A)

     a-b+c (B)

     (a-b)+c (C)

                  +
                /   \
               -     c
              / \
             a   b (D)

   The list functor `./2' is not a standard operator, but we could
declare it to be (E) then (F) would represent the structure (G).
     :-op(600, xfy, .). (E)

     a.b.c (F)

                .
               / \
              a   .
                 / \
                b   c (G)

   Contrasting this with the diagram above for a-b+c shows the
difference between `yfx' operators where the tree grows to the left,
and `xfy' operators where it grows to the right.  The tree cannot grow
at all for `xfx' operators; it is simply illegal to combine `xfx'
operators having equal precedences in this way.

   The possible types for a prefix operator are:
   * `fx'

   * `fy'

   and for a postfix operator they are:
     `xf'
     
     `yf'

   If these precedence and associativity rules seem rather complex,
remember that you can always use parentheses when in any doubt.


File: quintus.info,  Node: ref-syn-ops-ops,  Next: ref-syn-ops-res,  Prev: ref-syn-ops-ove,  Up: ref-syn-ops

Manipulating and Inspecting Operators
.....................................

   To add or remove an operator, use `op(+PRECEDENCE, +TYPE, +NAME)'.
`op/3' declares the atom NAME to be an operator of the stated TYPE and
PRECEDENCE.  If PRECEDENCE is 0, then the operator properties of NAME
(if any) are cancelled.

   To examine the set of operators currently in force, use
`current_op(*PRECEDENCE, *TYPE, *NAME)'.


File: quintus.info,  Node: ref-syn-ops-res,  Next: ref-syn-ops-bop,  Prev: ref-syn-ops-ops,  Up: ref-syn-ops

Syntax Restrictions
...................

   Note carefully the following syntax restrictions, which serve  to
remove potential ambiguities associated with prefix operators.

  1. The  arguments  of  a  compound  term  written  in standard
     syntax must be expressions of precedence _less than_ 1000.  Thus
     it is necessary to write the expression `P:-Q' in parentheses
          assert((P:-Q))

     because the precedence of the infix operator `:-', and hence of the
     expression `P:-Q', is 1200.  Enclosing the expression in
     parentheses reduces its precedence to 0.

  2. Similarly, the  elements of a list written in standard  syntax
     must be expressions of precedence _less than_ 1000.  Thus it is
     necessary to write the expression `P->Q' in parentheses
          [(P->Q)]

     because the precedence of the infix operator `->', and hence of the
     expression `P->Q', is 1050.  Enclosing the expression in
     parentheses reduces its precedence to 0.

  3. In a term written in standard syntax, the  principal  functor  and
     its  following  `('  must  _not_ be separated by any intervening
     spaces, newlines, or other characters.  Thus
          point (X,Y,Z)

     is invalid syntax.

  4.  If the argument of a prefix operator starts with a `(',  this  `('
     must  be  separated  from  the operator by at least one space or
     other layout character.  Thus
          :-(p;q),r.

     (where `:-' is the prefix operator) is invalid syntax.  The system
     would try to interpret it as the structure:
                      ,
                     / \
                   :-    r
                    |
                    ;
                   / \
                  p   q

     That is, it would take `:-' to be a functor of arity 1.  However,
     since the arguments of a functor are required to be expressions of
     precedence less than 1000, this interpretation would fail as soon
     as the `;' (precedence 1100) were encountered.

     In contrast, the term:
          :- (p;q),r.

     is valid syntax and represents the following structure:
                      :-
                       |
                       ,
                      / \
                     ;   r
                    / \
                   p   q

  5. If a prefix  operator  is  written  without  an  argument (as  an
     ordinary  atom),  the  atom  is  treated  as  an expression of the
     same precedence as the prefix operator, and  must  therefore  be
     written in parentheses where necessary.  Thus the parentheses are
     necessary in
          X = (?-)

     since the precedence of `?-' is 1200.


File: quintus.info,  Node: ref-syn-ops-bop,  Prev: ref-syn-ops-res,  Up: ref-syn-ops

Built-in Operators
..................

     :-op( 1200, xfx, [ :-, --> ])
     :-op( 1200,  fx, [ :-, ?- ])
     :-op( 1150,  fx, [ dynamic, multifile,
                          meta_predicate, initialization, volatile ])
     :-op( 1100, xfy, [ ; ])
     :-op( 1050, xfy, [ -> ])
     :-op( 1000, xfy, [ ',' ])
     :-op(  900,  fy, [ \+, spy, nospy ])
     :-op(  700, xfx, [ =, is, =.., ==, \==, @<, @>, @=<, @>=,
                                         =:=, =\=, <, >, =<, >= ])
     :-op(  600, xfy, [:])
     :-op(  500, yfx, [ +, -, \/, /\ ])
     :-op(  500,  fx, [ +, - ])
     :-op(  400, yfx, [ /, //, *, <<, >> div  ])
     :-op(  300, xfx, [ mod ])
     :-op(  200, xfy, [ ^ ])

   Two additional operators are provided solely for compatibility with
other Prologs:
             :- op(1150, fx, [mode, public])


File: quintus.info,  Node: ref-syn-com,  Next: ref-syn-spc,  Prev: ref-syn-ops,  Up: ref-syn

Commenting
----------

   Comments have no effect on the execution of a program, but they are
very useful for making programs more comprehensible.  Two forms of
comments are allowed:

  1. The character `%' followed by any sequence of characters up to the
     end of the line.

  2. The symbol `/*' followed by any sequence of characters (including
     newlines) up to the symbol `*/'.

