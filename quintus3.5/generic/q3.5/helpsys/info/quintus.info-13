This is info/quintus.info, produced by makeinfo version 4.3 from
quintus.texi.

INFO-DIR-SECTION Quintus Prolog
START-INFO-DIR-ENTRY
* Quintus Prolog Manual: (quintus).             The Quintus Prolog User's Manual.
END-INFO-DIR-ENTRY
   Generated 13 January 2004.


File: quintus.info,  Node: ref-mgc-gcp,  Next: ref-mgc-egc,  Prev: ref-mgc-ove,  Up: ref-mgc

Garbage Collection and Programming Style
----------------------------------------

   The availability of garbage collection can lead to a more natural
programming style.  Without garbage collection, a procedure that
generates heap garbage may have to be executed in a failure-driven loop.
Failure-driven loops minimize heap usage from iteration to iteration of
a loop via Quintus Prolog's automatic recovery of heap space on failure.
For instance, in the following procedure `echo/0' echoes Prolog terms
until it reads an end-of-file character.  It uses a failure-driven loop
to recover inaccessible heap space.
     echo :- repeat,
             read(Term),
             echo_term(Term),
             !.
     
     echo_term(Term) :-
             Term == end_of_file.
     echo_term(Term) :-
             write(Term), nl,
             fail.

   Any heap garbage generated by `read/1' or `write/1' is automatically
reclaimed by the failure of each iteration.

   Although failure-driven loops are an accepted Prolog idiom, they are
not particularly easy to read or understand.  So we might choose to
write a clearer version of `echo/0' using recursion instead, as in
     echo :- read(Term),
             echo_term(Term).
     
     echo_term(Term) :-
             Term == end_of_file,
             !.
     echo_term(Term) :-
             write(Term), nl,
             echo.

   Without garbage collection the more natural recursive loop
accumulates heap garbage that cannot be reclaimed automatically.  While
it is unlikely that this trivial example will run out of heap space,
larger and more practical applications may be unable to use the clearer
recursive style without garbage collection.  With garbage collection,
all inaccessible heap space will be reclaimed by the garbage collector.

   Using recursion rather than failure-driven loops can improve
programming style further.  We might want to write a predicate that
reads terms and collects them in a list.  This is naturally done in a
recursive loop by accumulating results in a list that is passed from
iteration to iteration.  For instance,
     collect(List) :-
             read(Term),
             collect_term(Term, List).
     
     collect_term(Term, []) :-
             Term == end_of_file,
             !.
     collect_term(Term, [Term|List0]) :-
             collect(List0).

   For more complex applications this sort of construction might prove
unusable without garbage collection.  Instead, we may be forced to use a
failure-driven loop with side-effects to store partial results, as in
the following much less readable version of `collect/1':
     collect(List) :-
             repeat,
             read(Term),
             store_term(Term),
             !,
             collect_terms(List).
     
     store_term(Term) :-
             Term == end_of_file.
     
     store_term(Term) :-
             assertz(term(Term)),
             fail.
     
     collect_terms([M|List]) :-
             retract(term(M)),
             !,
             collect_terms(List).
     collect_terms([]).

   The variable bindings made in one iteration of a failure-driven loop
are unbound on failure of the iteration.  Thus partial results cannot
simply be stored in a data structure that is passed along to the next
iteration.  We must instead resort to storing partial results via
side-effects (here, `assertz/1') and collect (and clean up) partial
results in a separate pass.  The second example is much less clear to
most people than the first.  It is also much less efficient than the
first.  However,  if there were no garbage collector, larger examples
of the second type might be able to run where those of the first type
would run out of memory.


File: quintus.info,  Node: ref-mgc-egc,  Next: ref-mgc-mgc,  Prev: ref-mgc-gcp,  Up: ref-mgc

Enabling and Disabling the Garbage Collector
--------------------------------------------

   The user has the option of executing programs with or without garbage
collection.  Procedures that do not use a large amount of heap space
before backtracking may not be affected when garbage collection is
enabled.  Procedures that do use a large amount of heap space may
execute more slowly due to the time spent garbage collecting, but will
be more likely to run to completion.  On the other hand, such programs
may run faster when the garbage collector is enabled because the
virtual memory is not expanded to the extent that "thrashing" occurs.
`gc/0' and `nogc/0' are the built-in predicates that are used to enable
and disable the garbage collector.  Alternatively, the `gc' Prolog flag
can be set to `on' or `off'.  To run the `gc' in a verbose mode, set
the `gc_trace' flag to `on'.  By default, garbage collection is enabled.


File: quintus.info,  Node: ref-mgc-mgc,  Next: ref-mgc-gch,  Prev: ref-mgc-egc,  Up: ref-mgc

Monitoring Garbage Collections
------------------------------

   By default, the user is given no indication that the garbage
collector is operating.  If no program ever runs out of space and no
program using a lot of heap space requires an inordinate amount of
processing time, then such information is unlikely to be needed.

   However, if a program thought to be using much heap space runs out of
space or runs inordinately slowly, the user may want to determine
whether more or less frequent garbage collections are necessary.
Information obtained from the garbage collector by turning on the
`gc_trace' option of `prolog_flag/3' can be helpful in this
determination.


File: quintus.info,  Node: ref-mgc-gch,  Next: ref-mgc-gcd,  Prev: ref-mgc-mgc,  Up: ref-mgc

Interaction of Garbage Collection and Heap Expansion
----------------------------------------------------

   For most programs, the default settings for the garbage collection
parameters should suffice.  For programs that have high heap
requirements, the default parameters may result in a higher ratio of
garbage collection time to run time.  These programs should be given
more space in which to run.

   The `gc_margin' is a non-negative integer specifying the desired
margin in kilobytes.  For example, the default value of 1000 means that
the heap will not be expanded if garbage collection can reclaim at least
one megabyte.  The advantage of this criterion is that it takes into
account both the user's estimate of the heap usage and the
effectiveness of garbage collecting.

  1.  Setting the `gc_margin' higher than the default will cause fewer
     heap expansions and garbage collections.  However, it will use
     more space, and garbage collections will be more time-consuming
     when they do occur.

     Setting the margin too large will cause the heap to expand so that
     if it does overflow, the resulting garbage collection will
     significantly disrupt normal processing.  This will be especially
     so if much of the heap is accessible to future computation.

  2.  Setting the `gc_margin' lower than the default will use less
     space, and garbage collections will be less time-consuming.
     However, it will cause more heap expansions and garbage
     collections.

     Setting the margin too small will cause many garbage collections
     in a small amount of time, so that the ratio of garbage-collecting
     time to computation time will be abnormally high.

  3. Setting the margin correctly will cause the heap to expand to a
     size where expansions and garbage collections are infrequent and
     garbage collections are not too time-consuming, if they occur at
     all.

   The correct value for the `gc_margin' is dependent upon many factors.
Here is a non-prioritized list of some of them:
   * The amount of memory available to the Prolog process

   * The maximum memory limit imposed on the Prolog process (see *Note
     ref-mgc-osi::, *Note ref-mgc-osi::)

   * The program's rate of heap garbage generation

   * The program's rate of heap non-garbage generation

   * The program's backtracking behavior

   * The amount of time needed to collect the generated garbage

   * The growth rate of the other Prolog stacks

   The algorithm used when the heap overflows is as follows:


     if `gc' is on
     and the heap is larger than `gc_margin' kilobytes then
        garbage collect the heap
        if less than `gc_margin' bytes are reclaimed then
           try to expand the heap
        endif
     else
        try to expand the heap
     endif

   The user can use the `gc_margin' option of `prolog_flag/3' to reset
the `gc_margin' (see *Note ref-lps-ove::).  If a garbage collection
reclaims at least the `gc_margin' kilobytes of heap space the heap is
not expanded after garbage collection completes.  Otherwise, the heap
is expanded after garbage collection.  This expansion provides space
for the future heap usage that will presumably occur.  In addition, no
garbage collection occurs if the heap is smaller than `gc_margin'
kilobytes.

     *Please note:*  `prolog_flag(gc_margin, OLD, NEW)' has nothing to
     do with the `gcguide(margin, OLD, NEW)' of older Prolog systems.
     The "margin" of those other systems was used for entirely
     different purposes.


File: quintus.info,  Node: ref-mgc-gcd,  Next: ref-mgc-osi,  Prev: ref-mgc-gch,  Up: ref-mgc

Invoking the Garbage Collector Directly
---------------------------------------

   Normally, the garbage collector is invoked only when some Prolog
data area overflows, so the time of its invocation is not predictable.
In some applications it may be desirable to invoke the garbage collector
at regular intervals (when there is known to be a significant amount of
garbage on the heap) so that the time spent garbage collecting is more
evenly distributed in the processing time.  For instance, it may prove
desirable to invoke the garbage collector after each iteration of a
question-and-answer loop that is not failure-driven.

   In rare cases the default garbage collection parameters result in
excessive garbage collecting costs or heap expansion, and the user
cannot tune the `gc_margin' parameter adequately.  Explicitly invoking
the garbage collector using the built-in predicate `garbage_collect/0'
can be useful in these circumstances.


File: quintus.info,  Node: ref-mgc-osi,  Next: ref-mgc-ago,  Prev: ref-mgc-gcd,  Up: ref-mgc

Operating System Interaction
----------------------------

   This section describes the various system parameters required to run
Prolog.

   There is normally no need for you to seek any special privileges or
quotas in order to run Prolog.  Prolog will automatically expand its
space up to the total amount of virtual space you are allowed.  If it
should run out of space, Prolog will raise a resource error.

   This may happen because of an infinite recursion in your program, or
it may be that your program really needs more space than is available.
Under UNIX, if you are using the C shell (`csh'), you can find out how
much space is available by means of the `csh' command `limit'.  The
command
     % limit

   will list a number of limits of which the relevant one is
`datasize'.  This number is the number of kilobytes available to Prolog
for its data areas.  You can reduce this limit by typing, for example,
     % limit datasize 2000

   The main reason that you might want to reduce the limit is that some
systems allow the allocation of more virtual memory than there is swap
space available, and then to crash.  You can run quite large programs
with a datasize of 2000 kilobytes.

     *UNIX Caveat:*

     On some UNIX systems, the specified `datasize' (program) limit
     (see `limit(csh)' and `getrlimit(3)') can be grossly higher then
     the maximum break that a process can set.  This is because the
     setting of the break is dependent upon the amount of swap space
     available.  Since all processes share the same swap space, the
     space available to any one process is based on the space usage of
     all other processes running on the machine.  Therefore, one
     process that has set a large program break may prevent another
     process from doing the same, if both are running simultaneously.

   The Quintus Prolog memory manager makes calculations based upon the
specified `datasize' limit, since the actual limit cannot be determined
except by experimentation, and even then the limit changes over time.
Better memory management will result when the specified `datasize'
limit is close to the actual limit.

   The default behavior of Prolog is tuned to be optimal for a large
class of programs. If the programmers need greater control of the way
Prolog grows and frees memory, they can set environment variables, the
documentation for which follow. Note that the default values for these
variables should satisfy almost all programs and you really do not need
to set these variables at all.  The values for these variables are
entered in bytes, but may be followed by `K' or `M' meaning kilobytes
or megabytes respectively.

`PROLOGINITSIZE'
     Controls the size of Prolog's initial memory allocation.  Can be
     set to a sufficiently large size to allow the Prolog application
     to execute without needing to expand.  This must be done before
     Prolog is invoked.

     By default, the value is the minimum memory required for Prolog to
     start up.  In addition, the value is constrained to be at least
     that amount, regardless of the user setting.

`PROLOGMAXSIZE'
     Can be used to place a limit on the amount of data space that a
     given Prolog process will use.

     The `csh' command `limit' can also be used to set the amount of
     data space that can be used by the the current shell and all
     processes within it.

     By default, the value is effectively infinity, which is to say
     that Prolog's expansion will only be limited by the space that the
     shell is able to provide it.

`PROLOGINCSIZE'
     Can be used to control the amount of space Prolog asks the
     operating system for in any given memory expansion.

     By default, the value is the minimum amount of memory that will
     allow Prolog to expand one of its data areas, by kilobytes. In
     addition, the value is constrained to be at least that amount,
     regardless of the user setting.

`PROLOGKEEPSIZE'
     Can be used to control the amount of space Prolog retains after
     performing some computation.  By default, Prolog gets memory from
     the operating system as the user program executes and returns all
     the free memory back to the operating system when the user program
     does not need any more. If the programmer knows that her program
     once it has grown to a certain size is likely to need as much
     memory for future computations, then she can advise Prolog not to
     return all the free memory back to the operating system by setting
     the value to K.  Once Prolog grows to K bytes, it will always keep
     at least K bytes around. Only memory that was allocated above and
     beyond K bytes is returned to the OS.

`PROLOGLOCALMIN'
     Can be used to control the amount of space Prolog reserves for the
     local stack. The purpose of the local stack is described in detail
     in *Note ref-mgc::.  The default value is 64Kb.

`PROLOGGLOBALMIN'
     Can be used to control the amount of space Prolog reserves for the
     global stack. The purpose of the global stack is described in
     detail in *Note ref-mgc::.  The default value is 64Kb.


File: quintus.info,  Node: ref-mgc-ago,  Next: ref-mgc-sum,  Prev: ref-mgc-osi,  Up: ref-mgc

Atom Garbage Collection
-----------------------

* Menu:

* ref-mgc-ago-agc::                     The Atom Garbage Collector User Interface
* ref-mgc-ago-pat::                     Protecting Atoms in Foreign Memory
* ref-mgc-ago-prm::                     Permanent Atoms
* ref-mgc-ago-are::                     Details of Atom Registration

   By default, atoms created during the execution of a program remain
permanently in the system until Prolog exits. For the majority of
applications this behavior is not a problem and can be ignored.
However, for two classes of application this can present problems.
Firstly the internal architecture of Quintus Prolog limits the number
of atoms that be can created to 2,031,616 and this can be a problem for
database applications that read large numbers of atoms from a database.
Secondly, the space occupied by atoms can become significant and
dominant memory usage, which can be a problem for processes designed to
run perpetually.

   These problems can be overcome by using atom garbage collection to
reclaim atoms that are no longer accessible to the executing program.

   Atoms can be created in many ways: when an appropriate token is read
with `read_term/3', when source or QOF files are loaded, when
`atom_chars/2' is called with a character list, or when
`QP_atom_from_string()' is called in C code.  In any of these contexts
an atom is only created if it does not already exist; all atoms for a
given string are given the same identification number, which is
different from the atom of any other string.  Thus, atom recognition
and comparison can be done quickly, without having to look at strings.
An occurrence of an atom is always of a fixed, small size, so where a
given atom is likely to be used in several places simultaneously the
use of atoms can also be more compact than the use of strings.

   A Prolog functor is implemented like an atom, but also has an
associated arity.  For the purposes of atom garbage collection, a
functor is considered to be an occurrence of the atom of that same name.

   Atom garbage collection is similar to heap garbage collection except
that it is not invoked automatically, but rather through a call to the
built-in predicate `garbage_collect_atoms/0'.  The atom garbage
collector scans Prolog's data areas looking for atoms that are
currently in use and  then throws away all unused atoms, reclaiming
their space.

   Atom garbage collection can turn an application that continually
grows and eventually either runs into the atom number limit or runs out
of space into one that can run perpetually.  It can also make feasible
applications that load and manipulate huge quantities of atom-rich data
that would otherwise become full of useless atoms.


File: quintus.info,  Node: ref-mgc-ago-agc,  Next: ref-mgc-ago-pat,  Up: ref-mgc-ago

The Atom Garbage Collector User Interface
.........................................

   Because the creation of atoms does not follow any other system
behaviors like memory growth or heap garbage collection, Quintus has
chosen to keep the invocation of atom garbage collection independent of
any other operation and to keep the invocation of atom garbage
collection explicit rather than making it automatic.  It is often
preferable for the programmer to control when it will occur in case
preparations need to be made for it.

   Atom garbage collection is invoked by calling the new built-in
predicate `garbage_collect_atoms/0'.  The predicate normally succeeds
silently.  The user may determine whether to invoke atom garbage
collection at a given point based on information returned from a call
to `statistics/2' with the keyword `atoms'.  That call returns a list
of the form

     [NUMBER OF ATOMS, ATOM SPACE IN USE, ATOM SPACE FREE]

   For example,

     | ?- statistics(atoms, Stats).
     
     Stats = [4313,121062,31032]

   One would typically choose to call `garbage_collect_atoms/0' prior
to each iteration of an iterative application, when either the number
of atoms or the atom space in use passes some threshold, e.g.

     <driver loop> :-
             ...
             repeat,
                maybe_atom_gc,
                <do next iteration>
                ...
             fail.
     <driver loop>.

   where

     maybe_atom_gc :-
             statistics(atoms, [_,Inuse,_]),
             atom_gc_space_threshold(Space),
             ( Inuse > Space -> garbage_collect_atoms ; true ).
     
     % Atom GC if there are more than 100000 bytes of atoms:
     atom_gc_space_threshold(100000).

   More sophisticated approaches might use both atom number and atom
space thresholds, or could adjust a threshold if atom garbage collection
didn't free an adequate number of atoms.

   To be most effective, atom garbage collection should be called when
as few as possible atoms are actually in use.  In the above example,
for instance, it makes the most sense to do atom garbage collection at
the beginning of each iteration rather than at the end, as at the
beginning of the iteration the previous failure may just have freed
large amounts of atom-rich global and local stack.  Similarly, it's
better to invoke atom garbage collection after abolishing or retracting
a large database than to do so before.


File: quintus.info,  Node: ref-mgc-ago-pat,  Next: ref-mgc-ago-prm,  Prev: ref-mgc-ago-agc,  Up: ref-mgc-ago

Protecting Atoms in Foreign Memory
..................................

   Quintus Prolog's foreign language interface allows atoms to be
passed to foreign functions.  When calling foreign functions from
Prolog, atoms are passed via the `+atom' argument type in the predicate
specifications of `foreign/[2,3]' facts.  The strings of atoms can be
passed to foreign functions via the `+string' argument type.  In the
latter case a pointer to the Prolog symbol table's copy of the string
for an atom is what is passed.  When calling Prolog from C, atoms are
passed back from C to Prolog using the `-atom' and `-string' argument
types in `extern/1' declarations.  Atoms can also be created in foreign
code via functions like `QP_atom_from_string()'.

   Prolog does not keep track of atoms (or strings of atoms) stored in
foreign memory.  As such, it cannot guarantee that those atoms will be
retained by atom garbage collection.  Therefore Quintus Prolog provides
functions to "register" atoms (or their strings) with the atom garbage
collector.  Registered atoms will not be reclaimed by the atom garbage
collector.  Atoms can be registered while it is undesirable for them to
be reclaimed, and then unregistered when they are no longer needed.

   Of course, the majority of atoms passed as atoms or strings to
foreign functions do not need to be registered.  Only those that will
be stored across foreign function calls (in global variables) or across
nested calls to Prolog are at risk.  An extra margin of control is
given by the fact the programmer always invokes atom garbage collection
explicitly, and can ensure that this is only done in contexts that are
"safe" for the individual application.

   To register or unregister an atom, one of the following functions is
used:

     int QP_register_atom(atom)
     QP_atom atom;
     
     int QP_unregister_atom(atom)
     QP_atom atom;

   These functions return either `QP_ERROR' or a non-negative integer.
The return values are discussed further in *Note ref-mgc-ago-are::.

   As noted above, when an atom is passed as a string (`+string') to a
foreign function, the string the foreign function receives is the one
in Prolog's symbol table.  When atom garbage collection reclaims the
atom for that string, the space for the string will also be reclaimed.

   Thus, if the string is to be stored across foreign calls then either
a copy of the string or else the atom (`+atom') should be passed into
the foreign function so that it can be registered and
`QP_string_from_atom()' can be used to access the string from the atom.

   Keep in mind that the registration of atoms only pertains to those
passed to foreign functions or created in foreign code.  Atoms in
Prolog's data areas are maintained automatically.  Note also that even
though an atom may be unregistered in foreign code, atom garbage
collection still may not reclaim it as it may be referenced from
Prolog's data areas.  But if an atom is registered in foreign code, it
will be preserved regardless of its presence in Prolog's data areas.

   The following example illustrates the use of these functions. In this
example the current value of an object (which an atom) is being stored
in a C global variable. There are two C functions that can be called
from Prolog, one to update the current value and one to access the
value.

     #include <quintus/quintus.h>
     
     QP_atom current_object = NULL;
     
     update_object(newvalue)
     QP_atom newvalue;
     {
             /* if current_object contains an atom, unregister it */
             if (current_object)
                     (void) QP_unregister_atom(current_object);
     
             /* register new value */
             (void) QP_register_atom(newvalue);
             current_object = newvalue;
     }
     
     QP_atom get_object()
     {
             return current_object;
     }


File: quintus.info,  Node: ref-mgc-ago-prm,  Next: ref-mgc-ago-are,  Prev: ref-mgc-ago-pat,  Up: ref-mgc-ago

Permanent Atoms
...............

   Atom garbage collection scans all Prolog's dynamic data areas when
looking for atoms that are in use.  Scanning finds atoms in the Prolog
stacks and in all compiled and interpreted code that has been
dynamically loaded into Prolog via `consult/1', `use_module/1',
`assert/2', etc.  However, there are certain potential sources of atoms
in the Prolog image from which atoms cannot be reclaimed.  Atoms for
Prolog code that has been statically linked with either the Prolog
Development Environment or the Runtime Environment have been placed in
the text space, making them (and the code that contains them)
effectively permanent.  Although such code can be abolished, its space
can never be reclaimed.

   These atoms are internally flagged as permanent by the system and are
always retained by atom garbage collection.  An atom that has become
permanent cannot be made non-permanent, so can never be reclaimed.


File: quintus.info,  Node: ref-mgc-ago-are,  Prev: ref-mgc-ago-prm,  Up: ref-mgc-ago

Details of Atom Registration
............................

   The functions that register and unregister atoms are in fact using
reference counting to keep track of atoms that have been registered.
As a result, it is safe to combine your code with libraries and code
others have written.  If the other code has been careful to register
and unregister its atoms as appropriate, atoms will not be reclaimed
until everyone has unregistered them.

   Of course, it is possible when writing code that needs to register
atoms that errors could occur.  Atoms that are registered too many
times simply will not be garbage collected until they are fully
unregistered.  However, atoms that aren't registered when they should
be may be reclaimed on atom garbage collection.  One normally doesn't
need to think about the reference counting going on in
`QP_register_atom()' and `QP_unregister_atom()', but some understanding
of its details could prove helpful when debugging.

   To help you diagnose problems with registering and unregistering
atoms, `QP_register_atom()' and `QP_unregister_atom()' both normally
return the current reference count for the atom.  If an error occurs,
e.g. a nonexistent atom is registered or unregistered, `QP_ERROR' is
returned.

   An unregistered atom has a reference count of 0.  Unregistering an
atom that is unregistered is a no-op; in this case,
`QP_unregister_atom()' returns 0.  A permanent atom has a reference
count of 128.  In addition, if an atom is simultaneously registered 128
times, it becomes permanent.  (An atom with 128 distinct references is
an unlikely candidate for reclamation!)  Registering or unregistering
an atom that is permanent is also a no-op;  `QP_register_atom()' and
`QP_unregister_atom()' return 128.

   Various safeguards enable you to detect when an atom may have been
reclaimed prematurely.  An atom that has been reclaimed and has not yet
been reused appears as the special system atom `'$anon'', which cannot
match any user atom (even a user-supplied `'$anon'', which will be a
distinct atom).  However, once an atom's space is reused, any
references to the old atom will now see only the new atom.  It is not
possible to detect that an atom has been reused once the reuse occurs.


File: quintus.info,  Node: ref-mgc-sum,  Prev: ref-mgc-ago,  Up: ref-mgc

Summary of Predicates
---------------------

   * `garbage_collect/0'

   * `gc/0'

   * `nogc/0'

   * `prolog_flag/3'

   * `statistics/[0,2]'

   * `trimcore/0'

   * `garbage_collect_atoms/0'


File: quintus.info,  Node: ref-mod,  Next: ref-sls,  Prev: ref-msg,  Up: ref

Modules
=======

* Menu:

* ref-mod-ove::                         Overview
* ref-mod-bas::                         Basic Concepts
* ref-mod-def::                         Defining a Module
* ref-mod-n2m::                         Converting Non-module-files into Module-files
* ref-mod-lod::                         Loading a Module
* ref-mod-vis::                         Visibility Rules
* ref-mod-som::                         The Source Module
* ref-mod-tyi::                         The Type-in Module
* ref-mod-dmo::                         Creating a Module Dynamically
* ref-mod-mpc::                         Module Prefixes on Clauses
* ref-mod-cim::                         Debugging Code in a Module
* ref-mod-mle::                         Modules and Loading through the Editor Interface
* ref-mod-ncl::                         Name Clashes
* ref-mod-ilm::                         Obtaining Information about Loaded Modules
* ref-mod-idp::                         Importing Dynamic Predicates
* ref-mod-mne::                         Module Name Expansion
* ref-mod-met::                         The meta_predicate Declaration
* ref-mod-sum::                         Predicate Summary


File: quintus.info,  Node: ref-mod-ove,  Next: ref-mod-bas,  Up: ref-mod

Overview
--------

   The module system lets the user divide large Prolog programs into
"modules", or rather smaller sub-programs, and define the interfaces
between those modules.  Each module has its own name space; that is, a
predicate defined in one module is distinct from any predicates with
the same name and arity that may be defined in other modules.  The
module system encourages a group of programmers to define the
dependence each has on others' work before any code is written, and
subsequently allows all to work on their own parts independently.  It
also helps to make library predicates behave as extensions of the
existing set of built-in predicates.

   The Quintus Prolog library uses the module system and can therefore
serve as an extended example of the concepts presented in the following
text.  The design of the module system is such that loading library
files and calling library predicates can be performed without knowledge
of the module system.

   Some points to note about the module system are that:
   * It is based on predicate modularity rather than on data
     modularity; that is, atoms and functors are global.

   * It is flat rather than hierarchical; any module may refer to any
     other module by its name -- there is no need to specify a path of
     modules.

   * It is not strict; modularity rules can be explicitly overridden.
     This is primarily for flexibility during debugging.

   * It is efficient; calls to predicates across module boundaries incur
     little or no overhead.

   * It is compatible with previous releases of Quintus Prolog;
     existing Prolog code should run unchanged.


File: quintus.info,  Node: ref-mod-bas,  Next: ref-mod-def,  Prev: ref-mod-ove,  Up: ref-mod

Basic Concepts
--------------

   Each predicate in a program is identified by its "module", as well
as by its name and arity.

   A module defines a set of predicates, some of which have the property
of being "public".  Public predicates are predicates that can be
"imported" by other modules, which means that they can then be called
from within those modules.  Predicates that are not public are
"private" to the module in which they are defined; that is, they cannot
be called from outside that module (except by explicitly overriding the
modularity rules as described in *Note ref-mod-vis::).

   There are two kinds of importation:

  1. A module M1 may import a specified set of predicates from another
     module M2.  All the specified predicates should be public in M2.

  2. A module M1 may import all the public predicates of another module
     M2.

   Built-in predicates do not need to be imported; they are
automatically available from within any module.

   There is a special module called `user', which is used by default
when predicates are being defined and no other module has been
specified.

   If you are using a program written by someone else, you need not be
concerned as to whether or not that program has been made into a module.
The act of loading a module from a file using `compile/1', or
`ensure_loaded/1' (see *Note ref-lod::) will automatically import all
the public predicates in that module.  Thus the command
     :- ensure_loaded(library(basics)).

   will load the basic list-processing predicates from the library and
make them available.


File: quintus.info,  Node: ref-mod-def,  Next: ref-mod-n2m,  Prev: ref-mod-bas,  Up: ref-mod

Defining a Module
-----------------

   The normal way to define a module is by creating a "module-file" for
it and loading it into the Prolog system.  A module-file is a Prolog
file that begins with a "module declaration".

   A module declaration has the form
     :- module(+MODULENAME, +PUBLICPREDLIST).

   Such a declaration must appear as the first term in a file, and
declares that file to be a module-file.  The predicates in the file
will become part of the module MODULENAME, and the predicates specified
in PUBLICPREDLIST are those that can be imported by other modules; that
is, the public predicates of this module.

   Instead of creating and loading a module-file, it is also possible
to define a module dynamically by, for example, asserting clauses into
a specified module.  A module created in this way has no public
predicates; all its predicates are private.  This means that they
cannot be called from outside that module except by explicitly
overriding the modularity rules as described in *Note ref-mod-vis::.
Dynamic creation of modules is described in more detail in *Note
ref-mod-dmo::.


File: quintus.info,  Node: ref-mod-n2m,  Next: ref-mod-lod,  Prev: ref-mod-def,  Up: ref-mod

Converting Non-module-files into Module-files
---------------------------------------------

   The Prolog cross-referencer located in `qplib(tools)' can
automatically generate `module/2' declarations from its cross-reference
information.  This is useful if you want to take a set of files making
up a program and make each of those files into a module-file.  See the
file `library('xref.doc')' for more information.

   Alternatively, if you have a complete Prolog program consisting of a
set of source files `{file1, file2, ...}', and you wish to encapsulate
it in a single module MOD, then this can be done by creating a "driver"
file of the following form:


     :- module(MOD, [ ... ]).
     
     :- ensure_loaded(file1).
     :- ensure_loaded(file2).
        .
        .
        .

   When a module is created in this way, none of the files in the
program `{file1, file2, ...}' have to be changed.


File: quintus.info,  Node: ref-mod-lod,  Next: ref-mod-vis,  Prev: ref-mod-n2m,  Up: ref-mod

Loading a Module
----------------

   To gain access to the public predicates of a module-file, load it as
you would any other file--using `compile/1', or `ensure_loaded/1' as
appropriate.  For example, if your code contains a directive such as
     :- ensure_loaded(FILE).

   this directive will load the appropriate file FILE whether or not
FILE is a module-file.  The only difference is that if FILE is a
module-file any private predicates that it defines will not be visible
to your program.

   The load predicates are adequate for use at Prolog's top level, or
when the file being loaded is a utility such as a library file.  When
you are writing modules of your own; `use_module/[1,2,3]' is the most
useful.

   The following predicates are used to load modules:

`use_module(F)'
     import the module-file(s) F, loading them if necessary; same as
     `ensure_loaded(F)' if all files in F are module-files

`use_module(F,I)'
     import the procedure(s) I from the module-file F, loading
     module-file F if necessary

`use_module(M,F,I)'
     import I from module M, loading module-file F if necessary

   Before a module-file is loaded, the associated module is
"reinitialized": any predicates previously imported into that module
are forgotten by the module.

   If a module of the same name with a different PUBLICPREDLIST or
different meta-predicate list has previously been loaded from a
different module-file, a warning is printed and you are given the
option of abandoning the load.  Only one of these two modules can exist
in the system at one time.

   Normally, a module-file can be reloaded after editing with no need to
reload any other modules.  However, when a module-file is reloaded
after its PUBLICPREDLIST or its meta-predicate declaration (see *Note
ref-mod-met::) has been changed, any modules that import predicates
from it may have become inconsistent.  This is because a module is
associated with a predicate at compile time, rather than run time.
Thus, other modules may refer to predicates in a module-file that are
no longer public or whose module name expansion requirements have
changed.  In the case of module-importation (where all, rather than
specific, public predicates of a module are imported), it is possible
that some predicates in the importing module should now refer to a
newly-public predicate but do not.  Whenever the possibility of such
inconsistency arises, you will be warned at the end of the load that
certain modules need to be reloaded.  This warning will be repeated at
the end of each subsequent load until those modules have been reloaded.

   Modules may be saved to a QOF file by calling
`save_modules(MODULES,FILE)' (see *Note ref-sls::).


File: quintus.info,  Node: ref-mod-vis,  Next: ref-mod-som,  Prev: ref-mod-lod,  Up: ref-mod

Visibility Rules
----------------

   By default, predicates defined in one module cannot be called from
another module.  This section enumerates the exceptions to this--the
ways in which a predicate can be "visible" to modules other than the
one in which it is defined.
  1. The built-in predicates can be called from any module.

  2. Any predicate that is named in the PUBLICPREDLIST of a module, and
     that is imported by some other module M, can be called from within
     M.

  3. Module Prefixing: Any predicate, whether public or not, can be
     called from any other module if its module is explicitly given as
     a prefix to the goal, attached with the `:/2' operator.  The
     module prefix overrides the default module.  For example,
          :- mod:foo(X,Y).

     always calls `foo/2' in module MOD.  This is effectively a
     loophole in the module system, which allows you to override the
     normal module visibility rules.  It is intended primarily to
     facilitate program development and debugging, and it should not be
     used extensively since it subverts the original purposes of using
     the module system.

     Note that a predicate called in this way does not necessarily have
     to be defined in the specified module.  It may be imported into
     it.  It can even be a built-in predicate, and this is sometimes
     useful -- see *Note ref-mod-som::, for an example.


File: quintus.info,  Node: ref-mod-som,  Next: ref-mod-tyi,  Prev: ref-mod-vis,  Up: ref-mod

The Source Module
-----------------

   For any given procedure call, or goal, the "source module" is the
module in which the corresponding predicate must be visible.  That is,
unless the predicate is built-in it must be defined in, or imported
into, the source module.

   For goals typed at the top level, the source module is the "type-in
module", which is `user' by default -- see *Note ref-mod-tyi::.  For
goals appearing in a file (either as goal clauses or as normal
clauses), the source module is the one into which that file has been
loaded.

   There are a number of built-in predicates that take predicate
specifications, clauses, or goals as arguments.  Each of these types of
argument must be understood with reference to some module.  For
example, `assert/1' takes a clause as its argument, and it must decide
into which module that clause should be asserted.  The default
assumption is that it asserts the clause into the source module.
Another example is `call/1'.  The goal (A) calls the predicate `foo/1'
in the source module; this ensures that in the compound goal (B) both
occurrences of `foo/1' refer to the same predicate.

     call(foo(X)) (A)
     
     call(foo(X)), foo(Y)  (B)

   All predicates that refer to the source module allow you to override
it by explicitly naming some other module to be used instead.  This is
done by prefixing the relevant argument of the predicate with the
module to be used followed by a `:' operator.  For example (C), asserts
`f(x)' in module `m'.

     | ?- assert(m:f(x)). (C)

   Note that if you call a goal in a specified module, overriding the
normal visibility rules (see *Note ref-mod-vis::), then the source
module for that goal is the one you specify, not the module in which
this call occurs.  For example (D), has exactly the same effect as
(C)--`f(x)' is asserted in module `m'.  In other words, prefixing a
goal with a module duplicates the effect of calling that goal from that
module.
     | ?- m:assert(f(x)). (D)

   Another built-in predicate that refers to the source module is
`compile/1'.  In this case, the argument is a file, or list of files,
rather than a predicate specification, clause, or goal.  However, in
the case where a file is not a module-file, `compile/1' must decide
into which module to compile its clauses, and it chooses the source
module by default.  This means that you can compile a file FILE into a
specific module M using
     | ?- compile(M:FILE).

   Thus if FILE is a module-file, this command would cause its public
predicates to be imported into module M.  If FILE is a non-module-file,
it is loaded into module M.

   For a list of the built-in predicates that depend on the source
module, see *Note ref-mod-mne::.  In some cases, user-defined
predicates may also require the concept of a source module.  This is
discussed in *Note ref-mod-met::.


File: quintus.info,  Node: ref-mod-tyi,  Next: ref-mod-dmo,  Prev: ref-mod-som,  Up: ref-mod

The Type-in Module
------------------

   The "type-in" module is the module that is taken as the source
module for goals typed in by the user.  The name of the default type-in
module is `user'.  That is, the predicates that are available to be
called directly by the user are those that are visible in the module
`user'.

   When debugging, it is often useful to call, directly from the top
level, predicates that are private to a module, or predicates that are
public but that are not imported into `user'.  This can be done by
prefixing each goal with the module name, as described in *Note
ref-mod-vis::; but rather than doing this extensively, it may be more
convenient to make this module the type-in module.

   The type-in module can be changed using the built-in predicate
`module/1' (see *Note mpg-ref-module1::); for example,
     | ?- module(mod).

   This command will cause subsequent goals typed at the top level to be
executed with `mod' as their source module.

   The name of the type-in module is always displayed, except when it
is `user'.  If you are running Prolog under the editor interface, the
type-in module is displayed in the status line of the Prolog window.
If you are running Prolog without the editor interface, the type-in
module is displayed before each top-level prompt.

   For example, if you are running Prolog without the editor:
     | ?- module(foo).
     
     yes
     [foo]
     | ?-

   It should be noted that it is unlikely to be useful to change the
type-in module via a directive embedded in a file to be loaded, because
this will have no effect on the load -- it will only change the type-in
module for commands subsequently entered by the user.


File: quintus.info,  Node: ref-mod-dmo,  Next: ref-mod-mpc,  Prev: ref-mod-tyi,  Up: ref-mod

Creating a Module Dynamically
-----------------------------

   There are several ways in which you can create a module without
loading a module-file for it.  One way to do this is by asserting
clauses into a specified module.  For example, the command (A) will
create the dynamic predicate `f/1' and the module `m' if they did not
previously exist.

     | ?- assert(m:f(x)). (A)

   Another way to create a module dynamically is to compile a
non-module-file into a specified module.  For example (B), will compile
the clauses in FILE into the module M.

     | ?- compile(M:FILE). (B)

   The same effect can be achieved by (temporarily) changing the type-in
module to M (see *Note ref-mod-tyi::) and then calling `compile(FILE)',
or executing the command in module M as in (C).

     | ?- M:compile(FILE). (C)


File: quintus.info,  Node: ref-mod-mpc,  Next: ref-mod-cim,  Prev: ref-mod-dmo,  Up: ref-mod

Module Prefixes on Clauses
--------------------------

* Menu:

* ref-mod-mpc-cmo::                     Current Modules

   Every clause in a Prolog file has a source module implicitly
associated with it.  If the file is a module-file, then the module
named in the module declaration at the top of the file is the source
module for all the clauses.  If the file is not a module-file, the
relevant module is the source module for the command that caused this
file to be loaded.

   The source module of a predicate decides in which module it is
defined (the module of the head), and in which module the goals in the
body are going to be called (the module of the body). It is possible to
override the implicit source module, both for head and body, of clauses
and directives, by using prefixes. For example, consider the
module-file:
     :- module(a, []).
     
     :- dynamic m:a/1.
     b(1).
     m:c([]).
     m:d([H|T]) :- q(H), r(T).
     m:(e(X) :- s(X), t(X)).
     f(X) :- m:(u(X), v(X)).

   In the previous example, the following modules apply:
  1. `a/1' is declared dynamic in the module `m'.

  2. `b/1' is defined in module `a' (the module of the file).

  3. `c/1' is defined in module `m'.

  4. `d/1' is defined in module `m', but `q/1' and `r/1' are called in
     module `a' (and must therefore be defined in module `a').

  5. `e/1' is defined in module `m', and `s/1' and `t/1' are called in
     module `m'.

  6. `f/1' is defined in module `a', but `u/1' and `v/1' are called in
     module `m'.

   Module prefixing is especially useful when the module prefix is
`user'.  There are several predicates that have to be defined in module
`user' but that you may want to define (or extend) in a program that is
otherwise entirely defined in some other module or modules:
   * `runtime_entry/1'

   * `term_expansion/2'

   * `portray/1'

   * `file_search_path/2'

   * `library_directory/1'

   Note that if clauses for one of these predicates are to be spread
across multiple files, it will be necessary to declare that predicate
to be multifile by putting a multifile declaration in each of the files.


File: quintus.info,  Node: ref-mod-mpc-cmo,  Up: ref-mod-mpc

Current Modules
...............

   A loaded module becomes current as soon as it is encountered, and a
module can never lose the property of being current.


File: quintus.info,  Node: ref-mod-cim,  Next: ref-mod-mle,  Prev: ref-mod-mpc,  Up: ref-mod

Debugging Code in a Module
--------------------------

   Having loaded a module to be debugged, you can trace through its
execution in the normal way.  When the debugger stops at a port, the
procedure being debugged is displayed with its module name as a prefix
unless the module is `user'.

   The predicate `spy/1'  depends on the source module.  It can be
useful to override this during debugging.  For example,
     | ?- spy mod1:f/3.

   puts a spypoint on `f/3' in module `mod1'.

   It can also be useful to call directly a predicate that is private
to its module in order to test that it is doing the right thing.  This
can be done by prefixing the goal with its module; for example,
     | ?- mod1:f(a,b,X).

