This is info/quintus.info, produced by makeinfo version 4.3 from
quintus.texi.

INFO-DIR-SECTION Quintus Prolog
START-INFO-DIR-ENTRY
* Quintus Prolog Manual: (quintus).             The Quintus Prolog User's Manual.
END-INFO-DIR-ENTRY
   Generated 13 January 2004.


File: quintus.info,  Node: ref-lod-rpx,  Next: ref-lod-lis,  Prev: ref-lod-lod,  Up: ref-lod

Redefining Procedures during Program Execution
----------------------------------------------

   You can redefine procedures during the execution of the program,
which can be very useful while debugging.  The normal way to do this is
to use the `break' option of the debugger to enter a break state (see
`break/0', *Note ref-iex-int::), and then load an altered version of
some procedures.  If you do this, it is advisable, after redefining the
procedures and exiting from the break state, to wind the computation
back to the first call to any of the procedures you are changing: you
can do this by using the `retry' option with an argument that is the
invocation number of that call.  If you do not wind the computation
back like this, then:
   * if you are in the middle of executing a procedure that you
     redefine, you will find that the old definition of the procedure
     continues to be used until it exits or fails;

   * if you should fail back into a procedure you have just redefined,
     then alternative clauses in the old definition will still be used.


File: quintus.info,  Node: ref-lod-lis,  Prev: ref-lod-rpx,  Up: ref-lod

Predicate List
--------------

   Detailed information is found in the reference pages for the
following:

   * `compile/1'

   * `consult/1'

   * `ensure_loaded/1'

   * `load_files/[1,2]'

   * `multifile/1'

   * `no_style_check/1'

   * `style_check/1'

   * `prolog_load_context/2'

   * `term_expansion/2'

   * `use_module/[1,2,3]'


File: quintus.info,  Node: ref-sls,  Next: ref-sem,  Prev: ref-mod,  Up: ref

Saving and Loading the Prolog Database
======================================

* Menu:

* ref-sls-ove::                         Overview of QOF Files
* ref-sls-csr::                         Compatibility with save/restore in previous releases
* ref-sls-for::                         Foreign Code
* ref-sls-sst::                         Saved-States
* ref-sls-ssl::                         Selective saving and loading of QOF files
* ref-sls-igs::                         Initializing Goals in Saved States
* ref-sls-lis::                         Predicate List


File: quintus.info,  Node: ref-sls-ove,  Next: ref-sls-csr,  Up: ref-sls

Overview of QOF Files
---------------------

   Quintus Prolog release 3 provides a much more powerful alternative
to the traditional save/restore facilities of Prolog.  It is now
possible to save, and subsequently load, individual predicates, or sets
of predicates, or entire modules of predicates, or indeed the complete
Prolog database.  Such sets of predicates are saved into Quintus'
standard "Quintus Object Format" ("QOF" files).  This significantly
extends the utility of QOF files, which were previously only used to
produce runtime systems and stand-alone programs.  "QOF files" are now
a fully general way of storing arbitrary Prolog facts and rules in a
form that can be quickly and easily used.  QOF files contain a machine
independent representation of both compiled and dynamic Prolog
predicates.  This means they are completely portable between different
platforms running Quintus Prolog.

   QOF files can be generated by:

   * saving a selected set of predicates from a running Prolog
     application (see *Note ref-sls::);

   * using the stand-alone `qpc' Prolog compiler to compile individual
     Prolog source files (see *Note sap-srs-qpc::).


   QOF files can be used by:

   * loading them into a running Prolog application (see *Note
     ref-sls::);

   * linking them together, using the stand-alone `qld' linker, into an
     object file for linking into an executable with static Prolog code
     made shareable (see *Note sap-srs-qld::). This executable can
     either:

        - be a full Quintus Prolog Development System allowing
          continued development;

        - or can be a runtime system for deployment of the application.


   QOF saving and loading is available in both Quintus Prolog
development systems and runtime systems built for distribution.  In a
development system, code can be incrementally compiled using the
built-in compiler and then saved into a QOF file.  In a runtime system,
which does not include the built-in compiler, dynamic code can be
asserted and then saved. Runtime systems can load QOF files containing
previously compiled code.

   This combination of the capabilities of the Quintus Prolog Runtime
Generator, with the saving and loading facilities of Quintus Prolog
release 3, and the cross-platform portability of QOF files, provides
tremendous flexibility that can be used for many purposes.  For example:

   * precompiling Prolog libraries for fast loading;

   * packaging Prolog code for distribution;

   * generating precompiled databases of application data;

   * selectively loading particular application databases (and rule
     bases);

   * saving Prolog data across application runs;

   * building and saving new application databases from within
     applications;

   * linking selected application databases into the application
     executable for ease of distribution, or to get code sharing and
     better memory and paging performance.

   The facilities for saving and loading QOF files are more than just a
convenience when developing programs; they are also a powerful tool
that can be used as part of the application itself.


File: quintus.info,  Node: ref-sls-csr,  Next: ref-sls-for,  Prev: ref-sls-ove,  Up: ref-sls

Compatibility with save/restore in previous releases
----------------------------------------------------

   Unfortunately, it has not been possible to retain the semantics of
`save/[1,2]' available in previous releases of Quintus Prolog.  This is
regrettable because it means that programs that incorporate code for
building saved-states will need to be changed.  This section explains
why it was necessary to remove these predicates.  Note, however, that
`save_program/1' _is_ available and has the same semantics as previous
releases (except for foreign code), although it is based on a new
implementation using QOF files. A new predicate `save_program/2',
described in *Note ref-sls-sst::, has been provided, which supports the
most common usage of `save/[1,2]', which was to specify an initial goal
for a saved-state to call when run.

   The difference between `save_program/1' and `save/[1,2]' in previous
releases of Quintus Prolog was that `save_program/1' saved only the
Prolog database, whereas `save/[1,2]' saved both the Prolog database
and the Prolog execution stacks.  It has not been possible to retain
the saving of the Prolog execution stacks in a way consistent with the
release 3 support of embeddability and the general portability of QOF
files.  This is why `save/[1,2]' have been removed.  The reasoning goes
as follows:

  1. QOF files are a completely portable machine-independent
     representation of Prolog data.

  2. It is difficult, if not impossible, to make the Prolog execution
     state portable in the same way as facts and rules in QOF files
     (see further points).

  3. QOF files can also be combined and loaded in flexible ways, and it
     is unclear what this would mean for execution states.

  4. The QOF file saved-states do _not_ save any C (or other foreign
     language) state. This is a change from the previous Quintus Prolog
     saved-states, and is further discussed below.

  5. In the general case, Prolog execution can now be arbitrarily
     interleaved with C (or other) function calls since Prolog and C
     are completely intercallable and can call each other recursively.

  6. Since the C state is not saved, it is not possible to meaningfully
     save the Prolog execution state in the general case where it
     depends on interleaved C execution state.

  7. In addition, Prolog code embedded in a C (or other) application is
     highly likely to be manipulating C data, such as pointers and other
     process-specific information. This data would be meaningless if
     restored into another process, and indeed would be likely to cause
     faults.

   The model that an arbitrary Prolog execution state can be saved thus
only works well within a Prolog-only situation.  In the complex
embedded environments supported by Quintus Prolog release 3 this model
cannot work properly.  Hence the removal of the facility.

   As mentioned in points 4-7 above, an additional important aspect here
is that Prolog no longer makes any attempt to save the state of C (or
other foreign language) code.  This was a feature of saved-states in
previous releases where both the C code and its data structures were
saved (as a memory image) into saved-states.  This was a feature that
caused many problems.  A primary problem was that the saved C state was
initialized (variables retained their values when restored) and yet the
initialized C state could contain many items that were no longer valid
in the new process, such as addresses and file descriptors.  Such code
would often fail when restored.  In addition, Prolog was unable to
guarantee that it had saved all the necessary foreign code state.  With
the advent of shared libraries and other complex memory management
facilities in the operating system, it became impossible for Prolog to
control and manage the states of other tools in the address space.

   When one takes a step back and looks at Prolog in the light of the
goals of release 3 (see *Note int-hig::) -- where Prolog code is a
component that can be embedded in complex applications written in many
languages -- it is clearly unreasonable for Prolog to try and control,
let alone save, arbitrary non-Prolog state.  The Prolog operations for
saving and loading QOF files now operate solely on the Prolog database
and these operations do not involve making any assumptions about
non-Prolog state. This is a much cleaner and more robust approach, and
is the most appropriate when Prolog applications become embedded
software components.


File: quintus.info,  Node: ref-sls-for,  Next: ref-sls-sst,  Prev: ref-sls-csr,  Up: ref-sls

Foreign Code
------------

   Prolog QOF files do _not_ contain any foreign code or foreign data
structures.  As discussed in the previous section, this is different
from saved-states in previous releases of Quintus Prolog.

   However, QOF files can have dependencies on object files that will be
automatically loaded when the QOF file is loaded. These dependencies
can arise because:

  1. The QOF file was compiled with the stand-alone compiler `qpc' (see
     *Note sap-srs-qpc::) and its source file contained calls to
     `load_foreign_files/2', which will have been turned into object
     file dependencies in the QOF file.

  2. The QOF file was saved from a Prolog session, using
     `save_program/[1,2]' or `save_modules/2', in which foreign code
     had been previously loaded.  The object files loaded will be
     recorded as object file dependencies in the QOF file.

   The `qnm' utility can be used (from the command prompt) to see the
list of dependencies in a QOF file:

     % qnm -D file.qof

   It is slower to start up a QOF file with object file dependencies
because the object files must be re-linked and re-loaded.  This
re-linking and re-loading will occur every time the QOF file is loaded
and the necessary object files are not yet loaded into the system.  If
this start-up time becomes a problem then this can be tackled by
statically linking your foreign code into the Prolog system.  This is
described in *Note sap-srs::.  This will make the foreign code become
part of the Prolog executable so there is no run-time linking required
at all.  In addition, on most systems, this Prolog code will now be
demand-paged from the executable, which will improve start-up time and
reduce paging (as compared with dynamic linking). We recommend
switching over to using static linking for programs with a lot of
foreign code. The dynamic foreign language interface can be used for
loading code while testing, but once your foreign code is stable it is
better to have it statically linked.  Furthermore, dynamically loaded
foreign code cannot be debugged with a debugger such as `gdb(1)', so
you will also need to statically link the foreign code so that the
debugger can be used on the resulting executable.  This contradicts the
fact that foreign code should be dynamically loaded while testing.

   All foreign code is either linked into the Prolog executable, or is
re-loaded when a QOF file is loaded.  This means that when a program is
started the foreign code will always be in an uninitialized state. This
is exactly the same as any other program. However, this is a change
from saved-states in previous releases of Quintus Prolog that saved the
initialized foreign state. The new semantics is much cleaner, is
consistent with standard practice, and avoids previous problems with
invalid initializations that were not valid in the new process. This
latter problem was particularly problematic for libraries (such as
Curses, X Windows, and database interfaces) since the user did not
usually have source code for the libraries and how they initialized and
what they depended upon could not be easily understood. In Quintus
Prolog Release 3, foreign code linked with Prolog, or loaded into
Prolog, will work just the same as if it were a separate program
independent of Prolog.

   It is possible that some of your previous programs relied on the
saving of foreign state into saved-states. If you have such programs
then they will need to be changed. Usually the change will involve
making sure that the foreign code is explicitly initialized each time
the application is run.  The initialization facilities described below,
see *Note ref-sls-igs::, may be useful for this.


File: quintus.info,  Node: ref-sls-sst,  Next: ref-sls-ssl,  Prev: ref-sls-for,  Up: ref-sls

Saved-States
------------

   Saved-states are just a special case of QOF files.  The
`save_program/[1,2]' predicate will save the entire Prolog database into
a QOF file, and then in addition will make that QOF file executable.
Under UNIX, the QOF file is made executable by making the first line of
the file be a `sh(1)' script. This script runs the executable that the
QOF file was saved from, telling it to load the QOF file.

   So, if a saved-state is created as follows:

     | ?- save_program(SAVEDSTATE).

   then if we look at the first line of the file we will see something
like the following. Note that `+L' is a Prolog command line option to
load a QOF file (`$0' will be the name of the QOF file and `$*' will be
any other arguments given when it is run).

     % head -1 SAVEDSTATE
     exec /usr/local/quintus/bin3.5/sun4-5/prolog +L $0 $*

   This QOF file can then be run from the command line as follows:

     % SAVEDSTATE

   In addition to the user's code from the Prolog database, a
saved-state saved by `save_program/[1,2]' also contains Prolog system
information such as flag settings, debugging information and so forth.
When the saved-state is loaded this system state is also restored,
which is convenient for continued development.

   Apart from being made executable, and containing additional Prolog
system information, a saved-state saved through `save_program/[1,2]' is
just a standard QOF file.  This means that it can be used anywhere you
would otherwise use a QOF file, for such things as loading into Prolog,
linking together with other QOF files, and linking into executables
(see *Note sap-srs:: for information on these linking capabilities).

   A saved-state, or any QOF file, can be restored using the `restore/1'
predicate from within Prolog:

     | ?- restore(SAVEDSTATE).

   The `restore/1' predicate will re-execute the running executable
(using the `execv(3)' system call) in order to obtain a completely new
environment, and will then load the QOF file. If the QOF file was saved
with `save_program/[1,2]' then this will restore exactly the same
Prolog database state as when the saved-state was saved.  In runtime
systems, however, it is the application program's responsibility to
load the file into the restarted executable, see *Note
mpg-ref-restore:: and *Note sap-srs-sqf::.

   Note that the executable that will be re-executed by `restore/1' is
the one currently running.  This may be different from the one named in
the first line in the QOF file, if that QOF file was saved from some
different executable. To use the executable that originally saved the
QOF file you should return to the command interpreter and run the QOF
file directly.  To use the executable you are currently running, you
should use `restore/1'.

   If the loaded QOF file has object file dependencies then those
object files will be re-linked and re-loaded as part of loading the QOF
file. If the object file cannot be found or linked, then an exception
will be raised.  Similarly, QOF dependencies are also reloaded at this
point.

     *Windows caveat:*

     Under Windows, it is not possible to replace a running executable
     with another.  Under Windows, `restore/1' will instead start a new
     sub-process and then terminate the running process. For more
     details see the Microsoft documentation for `execv()'.

     In a Windows command prompt window, the command interpreter does
     not wait when a process executes an `execv()' library call. Thus
     after `restore/1', the program gives the appearance of running in
     the background.

     *Please note:* The QOF file saved by `save_program/2' does _not_
     contain any of the Prolog code that is statically linked into the
     executable.  Only the Prolog database (both compiled and dynamic)
     that has been built since the executable started running is saved.
     This is done to avoid code duplication in the saved-state.
     However, this does mean that if the QOF-file is loaded into a
     different executable, then the program may be missing some code
     that it assumes should be there, because it was present in the
     original executable. An example would be a saved-state that was
     saved from an executable containing Quintus' ProWINDOWS add-on
     product. If that saved-state is loaded into a normal Prolog
     executable without ProWINDOWS then any calls to ProWINDOWS will
     not work (they will generate undefined predicate exceptions). The
     correct thing to do is clearly to make sure that you use either
     the original executable, or an executable that contains the
     necessary programs, or you load the necessary programs in addition
     to loading the saved-state QOF file.

   The `save_program/2' predicate can be used to specify an initial goal
that will be run when the saved-state is re-loaded. This usage of
`save_program/2' replaces the most common uses of the old `save/[1,2]'
predicates that are no longer available. For example:

     | ?- save_program(saved_state,initial_goal([a,b,c])).

   When `saved_state' is loaded `initial_goal/1' will be called. This
allows saved-states to be generated that will immediately start running
the user's program when they are executed. In addition to this
`save_program/2' facility there is also a comprehensive facility for
programs to set up initializations to be run when they are loaded or
otherwise started. This is described below in *Note ref-sls-igs::.


File: quintus.info,  Node: ref-sls-ssl,  Next: ref-sls-igs,  Prev: ref-sls-sst,  Up: ref-sls

Selective saving and loading of QOF files
-----------------------------------------

   The `save_program/[1,2]' and `restore/1' predicates discussed in the
previous section are used for saving and restoring the entire Prolog
database. To save selected parts of a Prolog database, the predicates
`save_modules/2' and `save_predicates/2' are used.

   For example, to save the modules `user' and `special' you would use:

     | ?- save_modules([user,special],'file1.qof').

   All predicates in those modules will be saved, and in addition any
foreign code files previously loaded into these modules will generate
an object file dependency in the QOF file.  All information in these
modules about predicates attached to foreign functions, and also
predicates that have been made externally callable from foreign code,
is saved as a normal part of the module.

   For each module imported by one of the specified modules, a QOF file
dependency is included in the QOF file.  This means that when you load
`file1.qof' into another Prolog session, it will automatically load any
additional QOF files that it needs.

   To just save certain predicates you would use:

     | ?- save_predicates([person/2,dept/4],'file2.qof').

   This will only save the predicates specified. In this case no
additional dependency information is saved into the QOF file. Note that
the module information for these predicates is included. When the QOF
file is loaded the predicates will be loaded into the same module they
were in originally.

   Any QOF file, however generated, can be loaded into Prolog with
`load_files/[1,2]':

     | ?- load_files('file1.qof')

   or, equivalently:
     | ?- ['file1.qof'].

   The information from each QOF file loaded is incrementally added to
the database.  This means that definitions from later loads may replace
definitions from previous loads.  A saved-state QOF file saved with
`save_program/[1,2]' can also be loaded with `load_files/[1,2]' in
which case the contents of the saved-state are just incrementally added
to the database as for any other QOF file.  The use of
`load_files/[1,2]' for this is different from the use of `restore/1' in
that `restore/1' will re-execute the executable thus reinitializing the
database. Using `load_files/[1,2]' allows the database to be
incrementally changed within the same process.

   If the loaded QOF file has object file dependencies then those object
files will be linked and loaded as part of loading the QOF file unless
they have already been loaded. If the object file cannot be found or
linked, then an exception will be raised.

   The predicates `load_files/[1,2]' are used for compiling and loading
source files as well as QOF files.  If `file1.qof' and `file1.pl' both
exist (and `file1' does not), then `load_files' (file 1) will load the
source (`.pl') or the QOF, whichever is the most recent.  Refer to
*Note ref-lod:: for more information on loading programs, and also to
the reference page for `load_files/[1,2]'.

     *Advanced note:*  Both `save_modules/2' and `save_predicates/2'
     will save Prolog code that is statically linked if such modules or
     predicates are specified.  This is different from
     `save_program/[1,2]', which will not save statically linked Prolog
     code.  Note that if such a QOF file is loaded back into the same
     executable that saved it, then the new definitions from the QOF
     file will replace the statically linked code.  There is no problem
     with this, except that some space will be wasted.  The original
     statically linked code will not be used, but since it is linked
     into the executable its space cannot be reclaimed.  Since static
     linking is normally used to optimize start-up time and the space
     usage for code, it is somewhat of a waste to circumvent this by
     saving and loading a lot of Prolog code that is already in the
     executable.  If the QOF file is to be used for other purposes,
     such as re-linking the executable, or as a part to be loaded into
     another program, then, of course, the saving of statically linked
     code is probably exactly what is required.


File: quintus.info,  Node: ref-sls-igs,  Next: ref-sls-lis,  Prev: ref-sls-ssl,  Up: ref-sls

Initializing Goals in Saved States
----------------------------------

* Menu:

* ref-sls-igs-ind::                     The Initialization Declaration
* ref-sls-igs-vol::                     Volatile Predicates
* ref-sls-igs-fto::                     Fine Tuning

   Under the earlier model, a Prolog file could either be compiled into
the development system, or compiled to Quintus Object Format by `qpc',
as shown in the following figure.


[See printed or HTML manual.]

               Compilation options:  Quintus Prolog 2.5

   The ability to save and load QOF files in a development system makes
the picture more complicated.  The following figure shows the ways a
Prolog source file can be compiled or saved.

   It would be natural to expect `a.qof' to be the same, however
generated.  But both the `save' predicates and `qpc' offer a rich
variety of options, and the reality is less simple (see the following
figure).


[See printed or HTML manual.]

            Saving and loading options:  Quintus Prolog 3.5


File: quintus.info,  Node: ref-sls-igs-ind,  Next: ref-sls-igs-vol,  Up: ref-sls-igs

The Initialization Declaration
..............................

   The `initialization/1' predicate is an important complement to the
embedded directive construct `:- GOAL' appearing in a file being
consulted or compiled, and can in many cases not only replace the
directive, but also make the code work better when used in stand-alone
programs and runtime systems.

   The main reason for this is that `:- GOAL' directive is executed at
compile-time, not when the file in which the construct occurs is
actually loaded into a running system. This causes no problems within
development systems, but if we want to save states and compile programs
into qof-files, link them together, and later start them up again,
problems arise because:

   * The `:- GOAL' construct calls GOAL only once, when the file is
     compiled, not when a saved state containing the file is restored.

   * GOAL is called at compile-time, which means that if you use `qpc'
     to compile source code into a qof-file, your directives will be
     run during this compilation, not when you load the qof-file or
     start up a stand-alone system to which the qof-file has been
     linked.

   The `initialization/1' predicate, on the other hand, provides a way
of letting initialization routines be called when a file is actually
loaded or a system containing the file is started up.  This allows for
correct initialization in stand-alone programs and runtime systems;
therefore a recommended programming style is to use `initialization/1'
instead of a bare `:- GOAL' construct whenever appropriate.

   In the following figure, GOAL_1 might typically be an operator
declaration and GOAL_2, an initialization predicate that modifies the
database.


[See printed or HTML manual.]

      Embedded directives (GOAL_1) vs. initialized goals (GOAL_2)

   The initialization goal, GOAL_2, is defined to be run when:
   *         a source file with a `:- initialization GOAL' directive is
     loaded into a running system (using compile, consult etc.)

   *         a stand-alone program or runtime system is started up, and
     some file linked to the system had a `:- initialization GOAL'
     directive. If several files had such directives, the order in
     which the goals are run is not defined.

   *         a saved state is restored, and some file loaded to the
     saved system had a `:- initialization GOAL' directive, or
     `initialization(GOAL)' was called before the state was saved.   If
     several initialization goals were defined in the system, the order
     in which they are run upon a restore is not defined.

   *         a QOF file is loaded into a running system, and the source
     file that was compiled into the qof file had a `(:- initialization
     GOAL)' directive.


File: quintus.info,  Node: ref-sls-igs-vol,  Next: ref-sls-igs-fto,  Prev: ref-sls-igs-ind,  Up: ref-sls-igs

Volatile Predicates
...................

   A predicate should be declared as volatile if it refers to data that
cannot or should not be saved in a QOF file.  In most cases a volatile
predicate will be dynamic, and it will be used to keep facts about
streams or references to C-structures.  When a state or a module is
saved at run-time, the clauses of all volatile predicates defined in
the context will be left unsaved. The predicate definitions will be
saved though, which means that the predicates will keep all properties,
that is volatile and maybe dynamic or multifile, when the saved state
is restored.

   For example, if a Prolog application connects to an external database
at start up, establishing a connection by an assertion like (A), a
volatile declaration would prevent each particular connection from
getting saved in the QOF file, as illustrated in the following figure.
A code example is found in the reference page for `initialization/1'.

     assert(db_connection(Connection)) (A)


[See printed or HTML manual.]

                      Using the Volatile Property

   When used as a compile-time directive, the volatile declaration of a
predicate must appear before all clauses of that predicate.  The
predicate is reinitialized.  When used as a callable goal, the only
effect on the predicate is that it is set to be volatile.


File: quintus.info,  Node: ref-sls-igs-fto,  Prev: ref-sls-igs-vol,  Up: ref-sls-igs

Fine Tuning
...........

   To tune the initialization of a file or system to be run only when it
should be run, `volatile/1', in combination with other declarations,
give `initialization/1' the information necessary to distinguish
different loading situations. In the reference pages, we show how some
common situations can be programmed using these predicates.

   If a source file contains data that is supposed to be transformed
according to some complicated rules (which cannot be done with
`term_expansion/2'), and the data after the transformation can be saved
into a saved state, we might want the transformation to be done when
the file is loaded, but not when a saved state is restored.  The
following program defines the initialization to be run only when the
file is loaded:

     :- dynamic do_not_transform/0. % reset fact
     :- initialization my_init.
     
     my_init :-
       ( do_not_transform ->
         true
       ; undo_transform, % remove old data
         do_transform,
         assert(do_not_transform)
       ).

   In the above example, `do_transform/0' and `undo_transform/0' are
user defined.


File: quintus.info,  Node: ref-sls-lis,  Prev: ref-sls-igs,  Up: ref-sls

Predicate List
--------------

   Detailed information is found in the reference pages for the
following:

   * `initialization/1'

   * `load_files/[1,2]'

   * `prolog_load_context/2'

   * `restore/1'

   * `save_modules/2'

   * `save_predicates/2'

   * `save_program/[1,2]'

   * `volatile/1'


File: quintus.info,  Node: ref-fdi,  Next: ref-gru,  Prev: ref-ere,  Up: ref

Files and Directories
=====================

* Menu:

* ref-fdi-fsp::                         The File Search Path Mechanism
* ref-fdi-pre::                         List of Predicates


File: quintus.info,  Node: ref-fdi-fsp,  Next: ref-fdi-pre,  Up: ref-fdi

The File Search Path Mechanism
------------------------------

* Menu:

* ref-fdi-fsp-def::                     Defining File Search Paths
* ref-fdi-fsp-ffs::                     Frequently Used File Specifications
* ref-fdi-fsp-fde::                     Filename Defaults
* ref-fdi-fsp-pre::                     Predefined file_search_path Facts
* ref-fdi-fsp-sys::                     The system file_search_path
* ref-fdi-fsp-lip::                     The Library Paths
* ref-fdi-fsp-lse::                     Editor Command for Library Search

   As a convenience for the developer and as a means for extended
portability of the final application, Quintus Prolog provides a
flexible mechanism to localize the definitions of the system dependent
parts of the file and directory structure a program relies on, in such
a way that the application can be moved to a different directory
hierarchy or to a completely new file system, with a minimum of effort.

   This mechanism, which can be seen as a generalization of the
`library_directory/1' scheme available in previous releases, presents
two main features:
  1. An easy way to create aliases for frequently used directories, thus
     localizing the external, file system and directory structure
     dependent directory name, to one single place in the program.

  2. A possibility to associate more than one directory specification
     with each alias, thus giving the developer full freedom in
     sub-dividing libraries, and other collections of programs, as it
     best suits the structure of the external file system, without
     making the process of accessing files in the libraries any more
     complicated. In this case, the alias can be said to represent a
     file search path, not only a single directory.

   The directory aliasing mechanism, together with the additional file
search capabilities of `absolute_file_name/3', can effectively serve as
an intermediate layer between the external world and a portable program.
For instance, the developer can hide the directory representation by
defining directory aliases, and he can automatically get a proper file
extension added, dependent on the type of file he wants to access, by
using the appropriate options to `absolute_file_name/3'.

   A number of directory aliases and file search paths, are predefined
in the Quintus Prolog system (though they can be redefined by the user).
The most important of those is the `library' file search path, giving
the user instant access to the Quintus library, consisting of several
sub-directories and extensive supported programs and tools.

   Specifying a library file, using the alias, is possible simply by
replacing the explicit file (and directory) specification with the
following term:

     library(FILE)

   The name of the file search path, in this case `library', is the
main functor of the term, and indicates that FILE is to be found in one
of the library directories.

   The association between the alias `library' (the name of the search
path) and the library directories (the definitions of the search path),
is defined by Prolog facts, `library_directory/1', which are searched
in sequence to locate the file. Each of these facts specifies a
directory where to search for FILE, whenever a file specification of
the form `library(FILE)' is encountered.

   The library mechanism discussed above, which can be extended with
new directories associated with the alias `library', has become
subsumed by the more general aliasing mechanism, in which arbitrary
names can be used as aliases for directories. The general mechanism
also gives the possibility of defining path aliases in terms of already
defined aliases.

   In addition to `library', the following aliases are predefined in
Quintus Prolog: `quintus',  `runtime', `system', `helpsys' `language'
and `tutorial'. The interpretation of the predefined aliases are
explained below.


File: quintus.info,  Node: ref-fdi-fsp-def,  Next: ref-fdi-fsp-ffs,  Up: ref-fdi-fsp

Defining File Search Paths
..........................

   The information about which directories to search when an alias is
encountered, is defined by the dynamic, multifile predicate
`file_search_path/2'. The clauses for this predicate are located in
module USER, and have the following form:

     file_search_path(PATHALIAS, DIRECTORYSPEC).

PATHALIAS
     must be an atom. It can be used as an alias for DIRECTORYSPEC

DIRECTORYSPEC
     Can either be an atom, spelling out the name of a directory, or a
     compound term using other path aliases to define the location of
     the directory.

   The directory path may be absolute, as in (A) or relative as in (B),
which defines a path relative to the current working directory.

   Then, files may be referred to by using file specifications of the
form similar to `library(FILE)'.  For example, (C), names the file
`/usr/jackson/.login', while (D) specifies the path `etc/demo/my_demo'
relative to the current working directory.

     file_search_path(home, '/usr/jackson'). (A)
     
     file_search_path(demo, 'etc/demo'). (B)
     
     home('.login') (C)
     
     demo(my_demo) (D)

   As mentioned above, it is also possible to have multiple definitions
for the same alias. If clauses (E) and (F) define the `home' alias,
then to locate the file specified by (G) each `home' directory is
searched in sequence for the file `.login'.  If `/usr/jackson/.login'
exists, it is used.  Otherwise, `/u/jackson/.login' is used if it
exists.

     file_search_path(home, '/usr/jackson'). (E)
     file_search_path(home, '/u/jackson'). (F)
     
     home('.login') (G)

   The directory specification may also be a term of arity 1, in which
case it specifies that the argument of the term is relative to the
`file_search_path/2' defined by its functor.  For example, (H) defines
a directory relative to the directory given by the `home' alias.
Therefore, the alias `qp_directory' represents the search path
`/usr/jackson/prolog/qp' followed by `/u/jackson/prolog/qp'.  Then, the
file specification (I) refers to the file (J), if it exists.
Otherwise, it refers to the file (K), if it exists.

     file_search_path(qp_directory, home('prolog/qp')). (H)
     
     qp_directory(test) (I)
     
     /usr/jackson/prolog/qp/test (J)
     
     /u/jackson/prolog/qp/test (K)

   Aliases such as `home' or `qp_directory' are useful because even if
the `home' directory changes, or the `qp_directory' is moved to a
different location, only the appropriate `file_search_path/2' facts
need to be changed.  Programs relying on these paths are not affected
by the change of directories because they make use of file
specifications of the form `home(FILE)' and `qp_directory(FILE)'.

   All built-in predicates that take file specification arguments allow
these specifications to include path aliases defined by
`file_search_path/2' facts.  These predicates are:

   * `absolute_file_name/[2,3]'

   * `compile/1'

   * `consult/1'

   * `ensure_loaded/1'

   * `load_files/[1,2]'

   * `open/[2,3]'

   * `restore/1'

   * `save_module/2'

   * `save_predicates/2'

   * `save_program/[1,2]'

   * `see/1'

   * `tell/1'

   * `use_module/[1,2,3]'

   *Notes:*
  1. The `file_search_path/2' database may contain directories that do
     not exist or are syntactically invalid (as far as the operating
     system is concerned).  If an invalid directory is part of the
     database, the system will fail to find any files in it, and the
     directory will effectively be ignored.

  2. This facility is provided so that one can load library or other
     files without knowing their absolute file names, but this does not
     restrict the way a file can be accessed.  It is _strongly_
     suggested that writing to a file not be done using the
     PATHALIAS(FILESPEC) facility.  (One could write to
     PATHALIAS(FILESPEC) but this may not have the desired effect,
     since the system will write to one of possibly many files
     depending upon the current order of the clauses in the
     `file_search_path/2' predicate.)  The absolute name of the file to
     which one is writing should be known.  To find the absolute name of
     a library file, for example, one can type
           | ?- absolute_file_name(library(FILESPEC), ABSFILENAME).

  3. `file_search_path/2'  must be defined in the default module `user'
     -- definitions in any other module will not be found.


File: quintus.info,  Node: ref-fdi-fsp-ffs,  Next: ref-fdi-fsp-fde,  Prev: ref-fdi-fsp-def,  Up: ref-fdi-fsp

Frequently Used File Specifications
...................................

   Frequently used `file_search_path/2' facts are best defined using
the initialization file `prolog.ini' , which is consulted at startup
time by the Development System.  Therefore, with reference to the
examples from *Note ref-fdi-fsp-def::, clauses like one following
should be placed in the `prolog.ini' file so that they are
automatically available to user programs after startup:

     :- multifile file_search_path/2.
     :- dynamic file_search_path/2.
     file_search_path(home, '/usr/jackson').
     file_search_path(qp_directory, home('prolog/qp')).
     file_search_path(demo, 'etc/demo').

   If it is necessary to avoid multiple definitions of the same fact,
this would be useful, for example, when restoring a saved state saved
by `save_program/1' at which time the `prolog.ini' file is consulted
again, a predicate such as `add_my_search_path/2' can be defined in the
`prolog.ini' file.
     add_my_search_path(Name, FileSpec) :-
         file_search_path(Name, FileSpec),
         !.
     add_my_search_path(Name, FileSpec) :-
         assert(file_search_path(Name, FileSpec)).

   This predicate only asserts a clause into the database if it is not
already defined.  Then, using goals of the following form avoids
multiple definitions:

     :- add_my_search_path(home, '/usr/jackson').
     :- add_my_search_path(demo, 'etc/demo').
     :- add_my_search_path(qp_directory, home('prolog/qp')).


File: quintus.info,  Node: ref-fdi-fsp-fde,  Next: ref-fdi-fsp-pre,  Prev: ref-fdi-fsp-ffs,  Up: ref-fdi-fsp

Filename Defaults
.................

   Some of the predicates that take file specification arguments not
only can search for a file among the directories defined by
`file_search_path/2' facts (if a path alias is used), but also can help
the user in finding the correct file by adding appropriate extensions
and/or looking for the most recent file by comparing modification times.

   `load_files/[1,2]' (and the predicates defined in terms of
`load_files/2'), uses the following algorithm to find the most
appropriate file to load:
  1. if the file specification is of the form PATHALIAS(FILENAME),
     retrieve the first directory in the search path associated with
     PATHALIAS and  apply the algorithm below in that directory (for
     instance, if `library(strings)' are given, look in the first
     library directory, with FILENAME set to `strings'):

  2. if `FILENAME' exists, load it.

  3. if `FILENAME.pl' exists, but not `FILENAME.qof', load `FILENAME.pl'

  4. if `FILENAME.qof' exists, but not `FILENAME.pl', load
     `FILENAME.qof'

  5. if both `FILENAME.pl' and `FILENAME.qof' exist, load the one that
     was most recently modified.

  6. if the file specification contained a path alias, retrieve the next
     directory in the path and retry from (2).

   For example,
     | ?- [user].
     | :- multifile file_search_path/2.
     | :- dynamic file_search_path/2.
     | file_search_path(home, '/usr').
     | file_search_path(home, '/usr/prolog').
     | end_of_file.        % (or <^D>)
     % user compiled in module user, 0.034 sec 284 bytes
     
     yes

   In this case the directory `/usr' is searched first and `/usr/prolog'
second.  Therefore, if the file `foo.pl' exists in both of these
directories, the following query will compile `foo.pl' in the directory
`/usr' (on the condition that `foo.qof' does not exist).

      | ?- compile(library(foo)).


File: quintus.info,  Node: ref-fdi-fsp-pre,  Next: ref-fdi-fsp-sys,  Prev: ref-fdi-fsp-fde,  Up: ref-fdi-fsp

Predefined file_search_path Facts
.................................

   An example of a directory hierarchy that has a constant structure,
but that may be installed at different parts of the file system, is the
Quintus installation hierarchy.  Several `file_search_path/2' facts are
defined in the system to support the flexibility of this installation.

   The predefined `file_search_path/2' facts are dynamic and multifile,
so they can be redefined or expanded by users.  In the Quintus Prolog
Development System installed for a Sparc running Solaris, the following
predefined `file_search_path/2' facts exist to specify the location of
certain Development System related directories:
     file_search_path(quintus,QUINTUS-DIRECTORY).
     file_search_path(runtime,RUNTIME-DIRECTORY).
     file_search_path(runtime,'').
     file_search_path(system,'sun4-5').
     file_search_path(system,sun4).
     file_search_path(system,'').
     file_search_path(helpsys,quintus('generic/q3.5/helpsys')).
     file_search_path(helpsys,package(helpsys)).
     file_search_path(qplib,quintus('generic/qplib3.5')).
     file_search_path(library,A) :-
             library_directory(A).
     file_search_path(messages,qplib(embed)).
     file_search_path(language,english).
     file_search_path(demo,quintus('generic/q3.5/demo/bench')).
     file_search_path(demo,quintus('generic/q3.5/demo/chat')).
     file_search_path(demo,quintus('generic/q3.5/demo/curses')).
     file_search_path(demo,quintus('generic/q3.5/demo/math')).
     file_search_path(demo,quintus('generic/q3.5/demo/menu')).
     file_search_path(demo,quintus('generic/q3.5/demo/search')).
     file_search_path(demo,quintus('generic/q3.5/demo/wafer')).
     file_search_path(demo,qplib('IPC/TCP/demo')).
     file_search_path(demo,qplib('IPC/RPC/demo')).
     file_search_path(demo,package(demo)).
     file_search_path(tutorial,quintus('generic/q3.5/tutorial')).
     file_search_path(tutorial,package(tutorial)).
     file_search_path(package,qplib(structs)).
     file_search_path(package,qplib(objects)).
     file_search_path(package,qplib(prologbeans)).
     file_search_path(package,quintus('qui3.5')).
     file_search_path(package,quintus('proxt3.5')).
     file_search_path(package,quintus('proxl3.5')).

   QUINTUS-DIRECTORY is the root of the Quintus installation hierarchy.
It is the directory where Quintus Prolog is installed, and is also
returned by
     | ?- prolog_flag(quintus_directory, QuintusDir).

   (see *Note ref-lps-flg-cha::, for discussion of `prolog_flag's).
The Prolog flag `host_type' creates the "system" facts.

   The path aliases predefined by the `file_search_path/2' facts above
have the following interpretation:

`quintus'
     gives the absolute name of the QUINTUS-DIRECTORY;
     QUINTUS-DIRECTORY is the root of the Quintus installation
     hierarchy;

`runtime'
     set to the value of the `runtime' `prolog_flag/2'; in the
     Development System, the current working directory is also added as
     a runtime path;

`system'
     gives the name of the system specific directories; see *Note
     ref-fdi-fsp-sys:: below for more discussion of the `system'
     specific directories;

`helpsys'
     gives the location of the help-system files; only defined for the
     Development System;

`qplib'
     gives the root directory of the Quintus libraries; see the
     `library_directory/1' facts below;

`library'
     defined in terms of the `library_directory/1' facts for
     compatibility with previous releases;

`package'
     lists Quintus Prolog packages, such as add-ons, for which general
     file search path facts are defined (e.g. `library', `helpsys',
     `demo', and `tutorial');

`messages'
     gives the location of message files (e.g. `QU_messages');

`language'
     gives the name of the current language specific directory.  One
     language specific directory exists under the embeddability
     directory in the library. This directory contains, for example,
     the file `QU_messages.pl', which thus can be retrieved using the
     file specification `messages(language('QU_messages'))';

`demo'
     gives the location of the Quintus Prolog demos;

`tutorial'
     gives the location of the Quintus Prolog tutorials.

     *Windows note:* The `syslib' file search path is provided to allow
     standard convention for Windows to be followed when searching for
     DLLs and libraries specified in `load_foreign_executable/1'. At
     startup time, Prolog asserts `syslib' file search path facts based
     upon the path specified in the environment variable `PATH' (as
     well as a couple of standard locations).

     When running `qld', the `syslib' file search path will be
     initialized to the path specified in the environment variable
     `LIB' in order to follow the Microsoft linker convention.

     Therefore, the directive
          :- load_foreign_executable(syslib(kernel32)).

     executed in the Development System will load `kernel32.dll' from a
     directory in the `PATH' environment variable, whereas if it is
     encountered by `qld', the environment variable `LIB' will be used
     to locate the import library `kernel32.lib'.

     The syslib file search paths can be modified by user code in the
     Development System or with the `-f' and `-F' options to `qld' if
     necessary.

   The library directories defined by the system  are:

     library_directory(qplib(library)).
     library_directory(qplib(tools)).
     library_directory(qplib('IPC/TCP')).
     library_directory(qplib('IPC/RPC')).
     library_directory(qplib(embed)).
     library_directory(package(library)).

   Note that these `file_search_path/2' and `library_directory/1'
tables, except for `helpsys', are also defined in `qpc' and `qld' (see
*Note too-too-qpc:: and *Note too-too-qld::).

