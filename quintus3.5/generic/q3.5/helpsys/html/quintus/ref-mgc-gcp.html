<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html lang="en">
<head>
<title>Quintus Prolog</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Quintus Prolog">
<meta name="generator" content="makeinfo 4.3">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home">
<link href="texinfo.css" rel="stylesheet" type="text/css">
</head>
<body>

<h4 class="subsection">Garbage Collection and Programming Style</h4>

   <p>The availability of garbage collection can lead to a more natural
programming style.  Without garbage collection, a procedure that generates
heap garbage may have to be executed in a failure-driven loop. 
Failure-driven loops minimize heap usage from iteration to iteration of
a loop via Quintus Prolog's automatic recovery of heap space on failure. 
For instance, in the following procedure
<code>echo/0</code> echoes Prolog terms until it reads an end-of-file character. 
It uses a failure-driven loop to recover inaccessible heap space.
<pre class="example">     echo :- repeat,
             read(Term),
             echo_term(Term),
             !.
     
     echo_term(Term) :-
             Term == end_of_file.
     echo_term(Term) :-
             write(Term), nl,
             fail.
     </pre>

   <p>Any heap garbage generated by <code>read/1</code> or <code>write/1</code>
is automatically reclaimed by the failure of each iteration.

   <p>Although failure-driven loops are an accepted Prolog idiom, they are
not particularly easy to read or understand.  So we might choose to
write a clearer version of <code>echo/0</code> using recursion instead, as in
<pre class="example">     echo :- read(Term),
             echo_term(Term).
     
     echo_term(Term) :-
             Term == end_of_file,
             !.
     echo_term(Term) :-
             write(Term), nl,
             echo.
     </pre>

   <p>Without garbage collection the more
natural recursive loop accumulates heap garbage that cannot be reclaimed
automatically.  While it is unlikely that this trivial example will run out
of heap space, larger and more practical applications may be unable to use
the clearer
recursive style without garbage collection.  With garbage collection, all
inaccessible heap space will be reclaimed by the garbage collector.

   <p>Using recursion rather than failure-driven loops can improve programming
style further.  We might want to write a predicate that reads terms and
collects them in a list.  This is naturally done in a recursive
loop by accumulating results in a list that is passed from iteration
to iteration.  For instance,
<pre class="example">     collect(List) :-
             read(Term),
             collect_term(Term, List).
     
     collect_term(Term, []) :-
             Term == end_of_file,
             !.
     collect_term(Term, [Term|List0]) :-
             collect(List0).
     </pre>

   <p>For more complex applications this sort of construction might prove unusable
without garbage collection.  Instead, we may be forced to use a
failure-driven loop with side-effects to store partial results, as in
the following much less readable version of <code>collect/1</code>:
<pre class="example">     collect(List) :-
             repeat,
             read(Term),
             store_term(Term),
             !,
             collect_terms(List).
     
     store_term(Term) :-
             Term == end_of_file.
     
     store_term(Term) :-
             assertz(term(Term)),
             fail.
     
     collect_terms([M|List]) :-
             retract(term(M)),
             !,
             collect_terms(List).
     collect_terms([]).
     </pre>

   <p>The variable bindings made in one iteration of
a failure-driven loop are unbound on failure of the iteration.  Thus partial
results cannot simply be stored in a data structure that is passed along
to the next iteration.  We must instead resort to storing partial results
via side-effects (here, <code>assertz/1</code>) and collect (and clean up) partial
results in a separate pass.  The second example is much less
clear to most people than the first.  It is also much less efficient than
the first.  However,  if there were no garbage collector, larger examples
of the second type might be able to run
where those of the first type would run out of memory.

<div class="logo">
<a href="http://www.sics.se/quintus/">
<table><tr><td>&nbsp;</td></tr></table>
</a>
</div>
<div class="node">
<ul class="node">
<li><a href="index.html#Top">User's Manual</a>
<hr>
<li><a href="index.html#TOC">Table of Contents</a>
<li><a rel="next" accesskey="n" href="ref-mgc-egc.html#ref-mgc-egc">Next</a>
<li><a rel="previous" accesskey="p" href="ref-mgc-ove.html#ref-mgc-ove">Previous</a>
<li><a rel="up" accesskey="u" href="ref-mgc.html#ref-mgc">Up</a>
</ul>
</div>
   </body></html>

