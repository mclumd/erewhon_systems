<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html lang="en">
<head>
<title>Quintus Prolog</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Quintus Prolog">
<meta name="generator" content="makeinfo 4.3">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home">
<link href="texinfo.css" rel="stylesheet" type="text/css">
</head>
<body>

<h4 class="subsection">Programs</h4>

   <p>A fundamental unit of a logic program is the  <dfn>goal</dfn> or
<dfn>procedure call</dfn> for example:
<pre class="example">     gives(tom, apple, teacher)
     
     reverse([1,2,3], L)
     
      X &lt; Y
     </pre>

   <p>A goal is merely a special kind of term,  distinguished  only  by  the
context  in  which it appears in the program.  The principal functor
of a goal is called a <dfn>predicate</dfn>.  It corresponds roughly to a verb  in
natural language, or to a procedure name in a conventional programming
language.

   <p>A logic <dfn>program</dfn> consists  simply  of  a  sequence  of  statements
called <dfn>sentences</dfn>,  which  are  analogous  to  sentences in  natural
language.

   <p>A sentence comprises a <dfn>head</dfn> and a <dfn>body</dfn>. 
The  head  either consists  of  a  single  goal  or  is  empty. 
The body consists of a
sequence of zero or more goals (it may be empty).  If the head
is not empty, the sentence is called a <dfn>clause</dfn>.

   <p>If the body of a clause is empty, the clause is called a <dfn>unit
clause</dfn>, and is written in the form (A) where <var>P</var> is the head
goal.  We interpret this <em>declaratively</em> as (B) and <em>procedurally</em>
as (C).
<pre class="display">     
     <var>P</var>. (A)
     </pre>

<pre class="display">     
     ``<var>P</var> is true.'' (B)
     </pre>

<pre class="display">     
     ``Goal <var>P</var> is satisfied.'' (C)
     </pre>

   <p>If the body of a clause is non-empty, the clause is called a
<dfn>non-unit clause</dfn>, and is written in the form (D) where <var>P</var>
is the head goal and <var>Q</var>, <var>R</var>, and <var>S</var> are the goals
that make up the body.  We can read such a clause either
declaratively as (E) or procedurally as (F).
<pre class="display">     
     <var>P</var> :- <var>Q, R, S</var>. (D)
     </pre>

<pre class="display">     
     ``<var>P</var> is true if <var>Q</var> and <var>R</var> and <var>S</var> are true.'' (E)
     </pre>

<pre class="display">     
     ``To satisfy goal <var>P</var>, satisfy goals <var>Q</var>, <var>R</var>, and <var>S</var>.'' (F)
     </pre>

   <p>A sentence with an empty head is called a <dfn>directive</dfn>, of which
the most important kind is called a <dfn>query</dfn> and is written in the
form (G) Such a query is read declaratively as (H), and procedurally as (I).
<pre class="display">     
     ?- <var>P</var>, <var>Q</var>. (G)
     </pre>

<pre class="display">     
     ``Are <var>P</var> and <var>Q</var> true?'' (H)
     </pre>

<pre class="display">     
     ``Satisfy goals <var>P</var> and <var>Q</var>.'' (I)
     </pre>

   <p>Sentences generally contain variables.  A variable should be thought of as
standing  for  some  definite  but unidentified  object.   This  is
analogous to the use of a pronoun in natural language.  Note that a
variable  is  not  simply  a  writable storage  location  as  in  most
programming languages;  rather it is a local name for some data object,
like the variable of  pure  Lisp.  Note that  variables  in different
sentences are completely independent, even if they have the same name --
the <em>lexical scope</em> of a variable  is limited  to  a single  sentence. 
To illustrate  this,  here  are  some examples  of  sentences containing
variables, with possible declarative and procedural readings:

     <dl>

     <br><dt><code>employed(X) :- employs(Y, X).</code>
     <dd>
"Any X is employed if any Y employs X."

     <p>"To find whether a person X is employed,
find whether any Y employs X."

     <br><dt><code>derivative(X, X, 1).</code>
     <dd>
"For any X, the derivative of X with respect to X is 1."

     <p>"The goal of finding a derivative for the
expression X with respect to X itself is
satisfied by the result 1."

     <br><dt><code>?- ungulate(X), aquatic(X).</code>
     <dd>
"Is it true, for any X, that X is an ungulate and X
is aquatic?"

     <p>"Find an X that is both an ungulate and aquatic." 
</dl>

   <p>In any program, the <dfn>procedure</dfn> for a particular predicate is the
sequence of clauses in the program whose head goals have that
predicate as principal functor.  For example, the procedure for a
predicate <code>concatenate</code> of three arguments might well consist of the
two clauses shown in (J) where <code>concatenate(L1, L2, L3)</code> means
"the list L1 concatenated with the list L2 is the list L3".

<pre class="example">     concatenate([], L, L). (J)
     concatenate([X|L1], L2, [X|L3]) :-
                 concatenate(L1, L2, L3). (K)
     </pre>

   <p>In Prolog, several predicates may have the same name but different arities. 
Therefore, when it is important to specify a predicate unambiguously, the
form <var>Name</var>/<var>Arity</var> is used, for example <code>concatenate/3</code>.

<div class="logo">
<a href="http://www.sics.se/quintus/">
<table><tr><td>&nbsp;</td></tr></table>
</a>
</div>
<div class="node">
<ul class="node">
<li><a href="index.html#Top">User's Manual</a>
<hr>
<li><a href="index.html#TOC">Table of Contents</a>
<li><a rel="next" accesskey="n" href="ref-sem-typ.html#ref-sem-typ">Next</a>
<li><a rel="up" accesskey="u" href="ref-sem.html#ref-sem">Up</a>
</ul>
</div>
   </body></html>

