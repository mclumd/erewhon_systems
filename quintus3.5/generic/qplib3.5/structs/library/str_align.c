/*  File   : structs_align.c
    Author : Peter Schachte
    Updated: 8/28/89
    Purpose: check out alignment constants for this C compiler

    Copyright (C) 1988, Quintus Computer Systems, Inc.  All rights reserved.

    This program autoamtically determines alignment constants used by the
    C compiler that compiles it.  It should be very portable.
    The output is written to stdout.

    We make a few assumptions:

	1.  globally allocated structures are allocated on 32 bit bountries.
	    This prog detects if this is not the case and aborts.
	2.  sizeof(int) == sizeof(long).  Prolog assumes this, too.
	    ** This assumption removed - invalid on the DEC alpha **
	3.  doubles aren't aligned on any greater boundry than sizeof(int).
	4.  the alignment requirement of a datatype depends only on the type
	    itself, not on any context.
	5.  unsigned things are aligned the same as their signed counterparts.
	    This asumption could be removed, with a bit more code.
*/


#ifndef	lint
static	char SCCSid[] = "@(#)94/06/01 str_align.c    20.1";
#endif	/* lint */

#include <stdio.h>
#include <stdlib.h>             /* [PM] 3.5 exit() */

/* z in a1 is a dummy to avoid SunPro C compiler
   allocating b1 on a 2-byte boundary
*/
struct a {char x; char y; short z;} a1;

struct b {char x; short y;} b1;

struct c {char x; int y;} c1;

struct d {char x; char *y;} d1;

struct e {char x; float y;} e1;

struct f {char x; double y;} f1;

struct g {char x; long y;} g1;


#define aligned(var) (0==((int)(&var))%4)
#define alignment(var) (((char *)(&(var.y))) - ((char *)(&(var.x))))


int                             /* [PM] 3.5 was void */
main()
    {
	if (!(aligned(a1) && aligned(b1) && aligned(c1) &&
	      aligned(d1) && aligned(e1) && aligned(f1) && aligned(g1))) {
	    fprintf(stderr, "can't determine C compiler alignment rules\n");
	    exit(1);
	}

	printf(
	    "%% This file automatically generated by structs_align\n");
	printf(
	    "%% Do not edit this file manually!\n\n");
	printf( ":- module(alignments, [\n");
	printf( "\tprimitive_type_size/3,\n");
	printf( "\tpointer_alignment/2\n");
	printf( "   ]).\n\n");

	printf( "primitive_type_size(long, %d, %d).\n",
		sizeof(long), alignment(g1));
	printf( "primitive_type_size(integer, %d, %d).\n",
		sizeof(int), alignment(c1));
	printf( "primitive_type_size(short, %d, %d).\n",
		sizeof(short), alignment(b1));
	printf( "primitive_type_size(char, %d, %d).\n",
		sizeof(char), alignment(a1));
	printf( "primitive_type_size(unsigned_long, %d, %d).\n",
		sizeof(unsigned long), alignment(g1));
	printf( "primitive_type_size(unsigned_integer, %d, %d).\n",
		sizeof(unsigned int), alignment(c1));
	printf( "primitive_type_size(unsigned_short, %d, %d).\n",
		sizeof(unsigned short), alignment(b1));
	printf( "primitive_type_size(unsigned_char, %d, %d).\n",
		sizeof(unsigned char), alignment(a1));
	printf( "primitive_type_size(float, %d, %d).\n",
		sizeof(float), alignment(e1));
	printf( "primitive_type_size(double, %d, %d).\n",
		sizeof(double), alignment(f1));
	printf( "primitive_type_size(atom, %d, %d).\n",
		sizeof(int), alignment(c1));
	printf( "primitive_type_size(string, %d, %d).\n",
		sizeof(char *), alignment(d1));
	printf( "primitive_type_size(address, %d, %d).\n",
		sizeof(char *), alignment(d1));
	printf( "primitive_type_size(opaque, unknown, unknown).\n\n");

	printf( "pointer_alignment(%d, %d).\n\n",
		sizeof(char *), alignment(d1));

	printf( "%% end of automatically generated file\n");
	exit(0);
    }
