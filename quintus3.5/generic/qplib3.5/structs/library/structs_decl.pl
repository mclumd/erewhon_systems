%   Package: structs_decl
%   Author : Peter Schachte
%   Updated: 12/10/98
%   Purpose: handle structure declarations for structs package

%   Copyright (C) 1990, Quintus Computer Systems, Inc.  All rights reserved.

:- module(structs_decl, []).

sccs_id('"@(#)98/12/10 str_decl.pl    22.1"').

:- use_module(library(basics)).
:- use_module(library(system(alignments))).
:- use_module(language(str_decl_msg)).
:- use_module(library(expansion), []).
:- use_module(library(strings), [concat_atom/2]).

:- initialization op(1150, fx, [(foreign_type)]).
%  Multifile procedures generated by this module:
%
%	structs:user_type_defn(Type_name, Simple_type_expr)
%		Type_name is the name of a user-defined type,
%		Simple_type_expr is a type expression defining
%		the type (see doc for new_atomic_type/8 for a
%		description of what a "simple" type expr is).
%
%	structs:user_type_size(Type_name, Size, Alignment)
%		Size is the size of a Type_name, in bytes.
%		Alignment is the byte alignment required for this
%		type; that is, the address of the beginning of an
%		instance of Type_name must be divisible by Alignment.
%		Sadly, alignment is completely machine and compiler
%		specific.
%
%	structs:user_type_file(Type_name, File)
%		File is the file that defined Type_name.  This hack
%		is to get around the fact that when the development
%		system compiles a file, the predicates previously
%		defined in this file are callable until the first
%		clause for each is found.  This means that when
%		compiling the first type definition, types defined
%		in that file when last loaded are still around.
%		So when we get a redefinition, we want to be able
%		to ask if the old definition came from the same file.
%
%	structs:user_get_contents(Datum, Part, Value)
%		This procedure is actually code used to get Part
%		of Datum, which is a compound datum.  Value is
%		bound to the contents of Part of Datum.
%
%	structs:user_put_contents(Datum, Part, Value)
%		This procedure is actually code used to put Part
%		of Datum, which is a compound datum.  Part of Datum
%		is set to Value.
%
%	structs:user_get_address(Datum, Part, Value)
%		This procedure is actually code used to get the
%		address of Part	of Datum, which is a compound datum.
%		Value is bound to the address of Part of Datum.
%
%  Dynamic procs:
%
%	qpc_user_type_defn(Type_name, Simple_type_expr)
%		Shadow version of structs:user_type_defn/2 clauses
%		generated while compiling this file.  This is
%		needed during qpc, since qpc can't execute clauses
%		it compiles.
%
%	qpc_user_type_size(Type_name, Size, Alignment)
%		Shadow version of structs:user_type_size/3 clauses
%		generated while compiling this file.  This is
%		needed during qpc, since qpc can't execute clauses
%		it compiles.
%
%	qpc_user_type_file(Type_name, File)
%		Shadow version of structs:user_type_file/2 clauses
%		generated while compiling this file.  This is
%		needed during qpc, since qpc can't execute clauses
%		it compiles.
%
%  There are also three separate procedures for each struct defined,
%  using the names get_X_field, put_X_field, and get_X_address,
%  where X is the name of the structure.  Similarly, there are two
%  procedures for each union defined, named get_X_field and
%  get_X_address.  All of these procedures are 3-ary.
%

:- multifile
	user_type_defn/2,
	user_type_size/3,
	user_type_file/2,
	user_get_contents/3,
	user_put_contents/3,
	user_get_address/3,
	user:unknown_predicate_handler/3.

user:unknown_predicate_handler(user_type_defn(_,_), structs, fail).
user:unknown_predicate_handler(user_type_size(_,_,_), structs, fail).
user:unknown_predicate_handler(user_type_file(_,_), structs, fail).

:- dynamic
	qpc_user_type_defn/2,
        qpc_user_type_size/3,
        qpc_user_type_file/2.


/****************************************************************
		    Installation of type definitions
 ****************************************************************/


%  compile_foreign_type_decl(+Decls, +Goal, +D0, -D)
%  D is D0 followed by the list of processed type declarations generated
%  by compiling the foreign type declaration(s) Decls.  D0 is a list of
%  processed declarations seen but not interned.  Goal is the goal
%  declaring all these types, for error-reporting purposes

compile_foreign_type_decl(Var, Goal, D, D) :-
	var(Var),
	print_message(error, instantiation_error(Goal,1)).
compile_foreign_type_decl((Type_decl1,Type_decl2), Goal, D0, D) :-
	compile_foreign_type_decl(Type_decl1, Goal, D0, D1),
	compile_foreign_type_decl(Type_decl2, Goal, D1, D).
compile_foreign_type_decl((Type_name=Type_expr), Goal, D0, D) :-
	(   new_type(Type_name, Type_expr, Goal, D0, D) -> true
	;   % new_type will print an error message and fail if Type_expr
	    % is invalid for some reason.
	    D = D0
	).


%  new_type(+Type_name, +Type_expr, +Goal, +D0, -D)
%  define Type_name to be a name for type Type_expr.  Goal is the original
%  goal, for error-reporting purposes.  D0 is a list of terms describing
%  type definitions seen but not interned, and D is this list plus the
%  processed version of this type declaration.

new_type(Type_name, Type_expr, Goal, D0, D) :-
	(   (   var(Type_name) ; var(Type_expr)) ->
		print_message(error, instantiation_error(Goal,1)),
		fail
	;   ( \+ atom(Type_name) ; primitive_type_size(Type_name, _, _)) ->
		print_message(error,
			domain_error(Goal,1,foreign_type_name,Type_name,'')),
		fail
	;   known_type_file(Type_name, Oldfile),
	    prolog_load_context(file, Newfile),
	    (Newfile \== Oldfile ; Newfile == user) ->
		print_message(error,
			permission_error(Goal,define,foreign_type,
				Type_name,already_defined)),
		fail
	;   true
	),
	(   known_type_defn(Type_expr, D0, Type_defn, _, _) ->
		true
	;   Type_defn = Type_expr
	),
	(   primitive_type_size(Type_defn, Size, Alignment) ->
		Simple = Type_defn,
		new_simple_type(Type_defn, Type_name, D0, D1)
	;   new_compound_type(Type_defn, Type_name, Type_name, 0, _,
			Simple, Size, Alignment, Goal, D0, D1)
	),
	type_clauses(Simple, Type_name, Size, Alignment, D1, D).


%  known_type_defn(+Type_name, +Defns, -Type_defn, -Size, -Alignment)

known_type_defn(Type_name, Defns, Type_defn, Size, Alignment) :-
	atom(Type_name),
	(   known_type_size(Type_name, Size, Alignment),
	    known_type_defn(Type_name, Type_defn0) ->
		cleanup_definition(Type_defn0, Type_defn)
	;   primitive_type_size(Type_name, Size, Alignment) ->
		Type_defn = Type_name
	;   memberchk(structs:user_type_size(Type_name,Size,Alignment), Defns),
	    memberchk(structs:user_type_defn(Type_name,Type_defn0), Defns),
	    cleanup_definition(Type_defn0, Type_defn)
	).


%  type_clauses(+Type_expr, +Type_name, +Size, +Alignment, +D0, -D)
%  D is D0 followed by the basic clauses to define Type_name as a name
%  for type Type_expr, with Size and Alignment.  Type_expr is a simple
%  type expression.  This does NOT include accessor clauses.

type_clauses(Type_expr, Type_name, Size, Alignment, D0, D) :-
	(   prolog_load_context(file, File) -> true
	;   File = none				% for debugging
	),
	D = [:-(multifile(structs:user_type_size/3)),
	     :-(discontiguous(structs:user_type_size/3)),
	     structs:user_type_size(Type_name,Size,Alignment),
	     :-(multifile(structs:user_type_defn/2)),
	     :-(discontiguous(structs:user_type_defn/2)),
	     structs:user_type_defn(Type_name, Type_expr),
	     :-(multifile(structs:user_type_file/2)),
	     :-(discontiguous(structs:user_type_file/2)),
	     structs:user_type_file(Type_name, File)|D0].

new_simple_type(Type_defn, Type_name, D0, D) :-
    	Ptr_term_1 =.. [Type_name,Ptr],
    	Ptr_term_2 =.. [Type_defn,Ptr],	
	D = [:-(multifile(structs:user_get_address/3)),
	     :-(discontiguous(structs:user_get_address/3)),
	     structs:user_get_address(Ptr_term_1, contents, Ptr_term_1)|D1],
							% a no-op
	D1 = [:-(multifile(structs:user_get_contents/3)),
	      :-(discontiguous(structs:user_get_contents/3)),
	      (structs:user_get_contents(Ptr_term_1,contents,Target_term) :-
	      	structs:user_get_contents(Ptr_term_2,contents,Target_term)),
	      :-(multifile(structs:user_put_contents/3)),
	      :-(discontiguous(structs:user_put_contents/3)),
	      (structs:user_put_contents(Ptr_term_1,contents,Target_term) :-
	      	structs:user_put_contents(Ptr_term_2,contents,Target_term))
	     | D0].


    	

%  new_compound_type(+Type_expr, +Type_name, +Parent, +N0, -N,
%	-Simple, -Size, -Alignment, +Goal, +D0, -D)
%  declare Type_name to be the name of type Type_expr, which is believed
%  to be a compound type (we fail if it's not).  Size is the number of
%  bytes one of these beasts occupy, and Alignment is the byte alignment
%  needed for one.  Simple is a simplified version of Type_expr, which
%  has only type names, not type expressions, for constituent types.
%  Parent is the user-supplied name for the type that defines this one,
%  N0 is the number of auxilliary types defined so far, and N is the
%  number after this type is defined.
%  Goal is the goal defining this type, for error-reporting
%  purposes.  D0 is a list of terms describing
%  type definitions seen but not interned, and D is this list plus the
%  processed version of this type declaration.

new_compound_type(pointer(Type_expr), Type_name, Parent, N0, N,
		pointer(Target_type), Size, Alignment, Goal, D0, D) :-
	!,
	( atom(Type_expr) ->
	      N = N0, D0 = D1, Target_type = Type_expr
	; get_type_name(Type_expr, Parent, N0, N, Target_type, _, _,
		D0, D1, Goal)
	),
	pointer_alignment(Size, Alignment),
	build_pointer_accessors(Type_name, Target_type, D1, D).
% For enums
new_compound_type(enum(Enums), Type_name, _Parent, N, N,
		enum(Enums), Size, Alignment, _Goal, D0, D) :-
	!,
	primitive_type_size(integer, Size, Alignment),
	build_enums(Enums, Type_name, D0, D).
new_compound_type(array(Num_elts,Type_expr), Type_name, Parent, N0, N,
		array(Num_elts,Elt_type), Size, Alignment, Goal, D0, D) :-
	!,
	get_type_name(Type_expr, Parent, N0, N, Elt_type, Elt_size0,
		Alignment, D0, D1, Goal),
	(   integer(Elt_size0) ->
		% we assume that an array should be aligned as it's elements
		Elt_size is ((Elt_size0+Alignment-1)//Alignment)*Alignment,
		Size is Elt_size*Num_elts,
		build_array_accessors(Type_name, Num_elts, Elt_type, Elt_size,
			D1, D)
	;   % otherwise it must be a type of unknown size
	    print_message(error,
		    domain_error(Goal,1,fixed_size_type,Type_expr,'')),
	    fail
	).
new_compound_type(array(Type_expr), Type_name, Parent, N0, N,
		array(Elt_type), unknown, Alignment, Goal, D0, D) :-
	!,
	get_type_name(Type_expr, Parent, N0, N, Elt_type, Elt_size0,
		Alignment, D0, D1, Goal),
	(   integer(Elt_size0) ->
		% we assume that an array should be aligned as it's elements
		Elt_size is ((Elt_size0+Alignment-1)//Alignment)*Alignment,
		build_array_accessors(Type_name, unknown, Elt_type, Elt_size,
			D1, D)
	;   % otherwise it must be a type of unknown size
	    print_message(error,
		    domain_error(Goal,1,fixed_size_type,Type_expr,'')),
	    fail
	).
new_compound_type(struct(Fields), Type_name, Parent, N0, N,
		struct(Simple_fields), Size, Alignment, Goal, D0, D) :-
	!,
	% we assume that a struct should be aligned as it's first field
	new_struct(Fields, Type_name, Parent, N0, N, Simple_fields,
		Size, Alignment, Goal, D0, D).
new_compound_type(union(Members), Type_name, Parent, N0, N,
		union(Simple_members), Size, Alignment, Goal, D0, D) :-
	!,
	new_union(Members, Type_name, Parent, N0, N, Simple_members,
		Size, Alignment, Goal, D0, D).
new_compound_type(Type_expr, _, _, _, _, _, _, _, Goal, _, _) :-
	print_message(error,
		domain_error(Goal,1,type_definition,Type_expr,'')),
	fail.


%  get_type_name(+Type_expr, +Parent_type, +N0, -N, -Type_name, -Size,
%	-Alignment, +D0, -D, +Goal)
%  Type_name is an atom describing type Type_expr.  Instances of this type
%  are Size bytes long, and must be aligned on an Alignment-byte
%  boundry.  If Type_expr is a valid type name or primitive
%  type, it is returned as Type_name, otherwise, a new type name is created
%  and defined, as described above.  Parent_type is the name of the
%  outermost type being defined, N0 is the number of subtypes defined so
%  far, and N is the number after this defn, to be used as a base for names
%  of subtypes.  D0 is a list of known uninterned types, and D is D0 extended
%  with any definitions necessary to define Type_name.  Goal is the
%  declaration, for error-reporting purposes.


get_type_name(Name, _, N, N, Name, Size, Alignment, D, D, _) :-
	atom(Name),
	known_type_defn(Name, D, _, Size, Alignment),
	!.
get_type_name(pointer(Type_expr), Parent, N0, N, Type_name, Size, Alignment,
		D0, D, Goal) :-
	!,
	(   atom(Type_expr) ->
		% we allow target type of pointer to be undefined, to
		% allow recursive structs
		Contents_type = Type_expr,
		N = N0,
		D1 = D0
	;   get_type_name(Type_expr, Parent, N0, N, Contents_type, _, _,
		    D0, D1, Goal)
	),
	atom_chars(Contents_type, Spelling),
	atom_chars(Type_name, [0'$|Spelling]),
	pointer_alignment(Size, Alignment),
	(   known_type_defn(Type_name, D0, _, _, _) ->
		% don't install this type as we already know about it
		D = D1
	;   type_clauses(pointer(Contents_type), Type_name , Size, Alignment,
		    D1, D2),
	    build_pointer_accessors(Type_name, Contents_type, D2, D)
	).
get_type_name(array(Num,Type_expr), Parent, N0, N, Type_name, Size, Alignment,
		D0, D, Goal) :-
	!,
	subtype_name(Parent, Type_name, N0, N1),
	new_compound_type(array(Num,Type_expr), Type_name, Parent, N1, N,
		Simple, Size, Alignment, Goal, D0, D1),
	type_clauses(Simple, Type_name, Size, Alignment, D1, D).
get_type_name(array(Type_expr), Parent, N0, N, Type_name, unknown, Alignment,
		D0, D, Goal) :-
	!,
	subtype_name(Parent, Type_name, N0, N1),
	new_compound_type(array(Type_expr), Type_name, Parent, N1, N,
		Simple, unknown, Alignment, Goal, D0, D1),
	type_clauses(Simple, Type_name, unknown, Alignment, D1, D).
get_type_name(struct(Fields), Parent, N0, N, Type_name, Size, Alignment,
		D0, D, Goal) :-
	!,
	subtype_name(Parent, Type_name, N0, N1),
	new_compound_type(struct(Fields), Type_name, Parent, N1, N,
		Simple, Size, Alignment, Goal, D0, D1),
	type_clauses(Simple, Type_name, Size, Alignment, D1, D).
get_type_name(union(Fields), Parent, N0, N, Type_name, Size, Alignment,
		D0, D, Goal) :-
	!,
	subtype_name(Parent, Type_name, N0, N1),
	new_compound_type(union(Fields), Type_name, Parent, N1, N,
		Simple, Size, Alignment, Goal, D0, D1),
	type_clauses(Simple, Type_name, Size, Alignment, D1, D).
get_type_name(enum(Enums), Parent, N0, N, Type_name, Size, Alignment,
		D0, D, Goal) :-
	!,
	subtype_name(Parent, Type_name, N0, N1),
	new_compound_type(enum(Enums), Type_name, Parent, N1, N,
		Simple, Size, Alignment, Goal, D0, D1),
	type_clauses(Simple, Type_name, Size, Alignment, D1, D).
get_type_name(Expr, _, _, _, _, _, _, _, _, Goal) :-
	print_message(error, domain_error(Goal,1,type_definition,Expr,'')),
	fail.

subtype_name(Parent, Subtype, N0, N) :-
	N is N0+1,
	atom_chars(Parent, List1),
	number_chars(N0, List2),
	append(List1, [0'$|List2], List),
	atom_chars(Subtype, List).


/****************************************************************
			Pointer declarations
 ****************************************************************/

%  build_pointer_accessors(+Type_name, +Target_type, +D0, -D)
%  Type_name is the name of a pointer type pointing to a Target_type thing.
%  D contains whatever linkage clauses are necessary to access the target of
%  one of these pointers, followed by D0.

build_pointer_accessors(Type_name, Target_type, D0, D) :-
	Ptr_term =.. [Type_name,Ptr],
	D = [:-(multifile(structs:user_get_address/3)),
	     :-(discontiguous(structs:user_get_address/3)),
	     structs:user_get_address(Ptr_term, contents, Ptr_term)|D1],
							% a no-op
	Target_term =.. [Target_type,Ptr2],
	D1 = [:-(multifile(structs:user_get_contents/3)),
	      :-(discontiguous(structs:user_get_contents/3)),
	      (structs:user_get_contents(Ptr_term,contents,Target_term) :-
			Ptr2 is address_at(Ptr)),
	      :-(multifile(structs:user_put_contents/3)),
	      :-(discontiguous(structs:user_put_contents/3)),
	      (structs:user_put_contents(Ptr_term,contents,Target_term) :-
			assign(address_at(Ptr),Ptr2))
	     | D0].


/****************************************************************
			Enum declarations
 ****************************************************************/

enum_goal(+, TypeName, IntV, EnumAtom, ToGoal) :-
    	from_enum_goal(TypeName, IntV, EnumAtom, ToGoal).
enum_goal(-, TypeName, IntV, EnumAtom, ToGoal) :-
    	to_enum_goal(TypeName, IntV, EnumAtom, ToGoal).

to_enum_goal(TypeName, IntV, EnumAtom, ToGoal) :-
	concat_atom([int_to_, TypeName], ToName),
	ToGoal =.. [ToName, IntV, EnumAtom].

from_enum_goal(TypeName, IntV, EnumAtom, FromGoal) :-
	concat_atom([TypeName, '_to_int'], FromName),
	FromGoal =.. [FromName, EnumAtom, IntV].

%  build_enums(+Enums, +Type_name, +D0, -D)

build_enums(Enums, Type_name, D0, D) :-
	Ptr_term =.. [Type_name,Ptr],
	D = [:-(multifile(structs:user_get_address/3)),
	     :-(discontiguous(structs:user_get_address/3)),
	     structs:user_get_address(Ptr_term, contents, Ptr_term)|D1],
							% a no-op
	to_enum_goal(Type_name, IntV, EnumAtom, ToGoal),
	from_enum_goal(Type_name, IntV, EnumAtom, FromGoal),
	functor(ToGoal, ToName, _),
	functor(FromGoal, FromName, _),
	D1 = [:-(multifile(structs:user_get_contents/3)),
	      :-(discontiguous(structs:user_get_contents/3)),
	      structs:(user_get_contents(Ptr_term,contents,EnumAtom) :-
			IntV is integer_at(Ptr), ToGoal),
	      :-(multifile(structs:user_put_contents/3)),
	      :-(discontiguous(structs:user_put_contents/3)),
	      structs:(user_put_contents(Ptr_term,contents,EnumAtom) :-
			FromGoal, assign(integer_at(Ptr),IntV)),
	      :-(discontiguous(structs:ToName/2)),
	      :-(discontiguous(structs:FromName/2))
	     | D2],
	build_enum_tables(Enums, Type_name, 0, D2, D0).

build_enum_tables([], _, _, D, D).
build_enum_tables([Enum|Enums], Type_name, CurrEnumVal, D, D0) :-
    	enum_value(Enum, CurrEnumVal, ThisName, ThisVal),
	NextVal is ThisVal + 1,
	to_enum_goal(Type_name, ThisVal, ThisName, ToFact),
	from_enum_goal(Type_name, ThisVal, ThisName, FromFact),
	D = [structs:ToFact, structs:FromFact | D1],
	build_enum_tables(Enums, Type_name, NextVal, D1, D0).

enum_value(Enum=Val, _, Enum, Val) :- !.
enum_value(Enum,   Val, Enum, Val).
	


/****************************************************************
			Array declarations
 ****************************************************************/

%  build_array_accessors(+Type_name, +Num_elts, +Elt_type, +Elt_size, +D0, -D)
%  Type_name is the name of an array type holding Num_elts elements of
%  type Elt_type.  We know that Elt_type things occupy Elt_size bytes
%  each.  Build whatever linkage clauses are necessary to access the
%  elements of the array.  If Num_elts is the atom unknown, then this
%  is an array of unknown size, so we can't do bounds checking.
%  D contains whatever linkage clauses are necessary to access the target of
%  one of these pointers, followed by D0.

build_array_accessors(Type_name, Num_elts, Elt_type, Elt_size, D0, D) :-
	Term =.. [Type_name, Ptr],
	simplify_is(Elt_num*Elt_size, Offset, Offset_goal0),
	simplify_is(Ptr+Elt_num*Elt_size, Address, Addr_goal0),
	(   integer(Num_elts) ->
		High_elt is Num_elts-1,
		conjoin(between:between(0,High_elt,Elt_num), Offset_goal0,
			Offset_goal),
		conjoin(between:between(0,High_elt,Elt_num), Addr_goal0,
			Addr_goal)
	;   Offset_goal = Offset_goal0,
	    Addr_goal = Addr_goal0
	),
	% Now Offset_goal is bound to the goal to bind Offset to the
	% appropriate offset for element Elt_num, doing bounds testing
	% if possible; and Addr_goal is bound to the goal to bind
	% Address to the address of the Elt_num element.
	(   accessor_goals(Elt_type, Ptr, Offset, Value, D0,
		    Get_goal0, Put_goal0) ->
		% now Get_goal is bound to the goal to bind Value to the
		% contents of memory at Ptr+Offset, which is of type Elt_type.
		% Put_goal is the goal to put Value into memory there.
		conjoin(Offset_goal, Get_goal0, Get_goal),
		conjoin(Offset_goal, Put_goal0, Put_goal),
		D = [:-(multifile(structs:user_get_contents/3)),
		     :-(discontiguous(structs:user_get_contents/3)),
		     structs:(user_get_contents(Term,Elt_num,Value):-Get_goal),
		     :-(multifile(structs:user_put_contents/3)),
		     :-(discontiguous(structs:user_put_contents/3)),
		     structs:(user_put_contents(Term,Elt_num,Value):-Put_goal)
		    | D1]
	;   D = D1			% can't access elements
	),
	% we evaluate any aliases of Elt_type to primitive types
	( known_type_defn(Elt_type, D0, Simple_type, _, _),
	  atom(Simple_type)		% maybe a hack
	-> Addr_value =.. [Simple_type, Address]
	;  Addr_value =.. [Elt_type, Address]
	),
	D1 = [:-(multifile(structs:user_get_address/3)),
	      :-(discontiguous(structs:user_get_address/3)),
	      structs:(user_get_address(Term,Elt_num,Addr_value):-Addr_goal) | D0].



/****************************************************************
			Struct declarations
 ****************************************************************/

%  new_struct(+Fields, +Struct_name, +Parent, +N0, -N, -Simplified_fields,
%	-Size, -Alignment, +Goal, +D0, -D)
%  Fields is the list of fields of a structure named Struct_name.
%  Simplified_fields is the same as Fields, except that all field types
%  are given as type names, rather than expressions.  Size is the number
%  of bytes an instance of this structure occupies, and Alignment is
%  the byte alignment required for this struct.  This procedure
%  generates the necessary linkage clauses to access fields of this
%  structure.  Goal is the goal declaring this type, for error reporting.
%  D contains whatever linkage clauses are necessary to access the target of
%  one of these pointers, followed by D0.

new_struct(Fields, Struct_name, Parent, N0, N, Simplified_fields, Size,
		Alignment, Goal, D0, D) :-
	accessor_names(Struct_name, Get_pred, Put_pred, Addr_pred),
	new_struct(Fields, 0, Get_pred, Put_pred, Addr_pred, Struct_name,
		Parent, N0, N, Simplified_fields, Size, Goal, D0, D1),
	build_struct_accessors(Struct_name, Get_pred, Put_pred,	Addr_pred,
		D1, D),
	struct_or_union_alignment(Simplified_fields, D, 0, Alignment).


%  new_struct(+Fields, +Offset, +Get_pred, +Put_pred, +Addr_pred, +Struct_name,
%	+Parent, +N0, -N, -Simplified_fields, -Size, +Goal, +D0, -D)
%  Build the accessor procedures necessary to access fields of a struct.
%  Fields is a list of the fields of the struct starting at byte offset
%  Offset.   Get_pred, Put_pred, and Addr_pred are the names of the
%  accessor procedures that must be generated.  Struct_name is the name
%  of the structure being defined, used in error messages.  Parent, N0,
%  N, Size, Simplified_fields, Goal, D0, and D are as described above.  

new_struct([], Size, _, _, _, _, _, N, N, [], Size, _, D, D).
new_struct([Field_name:Type_expr|Fields], Offset0, Get_pred, Put_pred,
		Addr_pred, Struct_name, Parent, N0, N,
	    [field(Field_name,Type_name,Offset0)|Simplified_fields],
	    Size, Goal, D0, D) :-
	(   get_type_name(Type_expr, Parent, N0, N1, Type_name, Field_size,
		    Field_align, D0, D1, Goal),
	    integer(Field_size) ->
		Offset1 is ((Offset0+Field_align-1)//Field_align)*Field_align,
		build_field_accessors(Field_name, Offset1, Type_name, 
			Get_pred, Put_pred, Addr_pred, D1, D2),
		Offset2 is Offset1+Field_size,
		new_struct(Fields, Offset2, Get_pred, Put_pred, Addr_pred,
			Struct_name, Parent, N1, N, Simplified_fields, Size,
			Goal, D2, D)
	;   print_message(error,
		    domain_error(Goal,1,fixed_size_type,Type_expr,'')),
	    fail
	).

%  build_field_accessors(+Field_name, +Offset, +Type_name, +Get_pred,
%		+Put_pred, +Addr_pred, +Clauses0, -Clauses)
%  Clauses is the list of clauses necessary to access field Field_name,
%  of type Type_name, which is found at byte offset Offset of a structure,
%  followed by Clauses0.  Other args are as above.

build_field_accessors(Field_name, Offset, Type_name, Get_pred, Put_pred,
		Addr_pred, Clauses0,
		[:-(discontiguous(structs:Addr_pred/3)),
		 structs:(Addr_head:-Addr_goal)|Clauses]) :-
	Addr_head =.. [Addr_pred,Field_name,Ptr,Value],
	Value =.. [Type_name,Addr],
	simplify_is(Ptr+Offset, Addr, Addr_goal),
	(   accessor_goals(Type_name, Ptr, Offset, Value1, Clauses0,
		    Get_goal, Put_goal) ->
		Get_head =.. [Get_pred,Field_name,Ptr,Value1],
		Put_head =.. [Put_pred,Field_name,Ptr,Value1],
		Clauses = [:-(discontiguous(structs:Get_pred/3)),
			   structs:(Get_head :- Get_goal),
			   :-(discontiguous(structs:Put_pred/3)),
			   structs:(Put_head :- Put_goal)
			  |Clauses0]
	;   Clauses = Clauses0		% can't access contents of this slot
	).


%  build_struct_accessors(+Struct_name, +Get_pred, +Put_pred, +Addr_pred,
%	D0, D)
%  Build and assert the clauses that link the user-visable accessor
%  procedures to the accessor procedures for struct Struct_name, named
%  Get_pred, Put_pred, and Addr_pred.  Clauses is the list of clauses
%  defining the accessor procedures.  It is possible for a struct to
%  have no fields the contents of which can be accessed, in which case,
%  don't generate those linkage clauses.

build_struct_accessors(Struct_name, Get_pred, Put_pred, Addr_pred, D0, D) :-
	Addr_goal =.. [Addr_pred,Fieldname,Ptr,Value],
	Term =.. [Struct_name,Ptr],
	D = [:-(multifile(structs:user_get_address/3)),
	     :-(discontiguous(structs:user_get_address/3)),
	     structs:(user_get_address(Term,Fieldname,Value):-Addr_goal)|D1],
	Head =.. [Get_pred,_,_,_],	% We use Get_pred, but either would
					% do, because if there's a put,
					% there's a corresponding get.
	(   memberchk(structs:(Head:-_), D0) ->
		Get_goal =.. [Get_pred,Fieldname,Ptr,Value],
		Put_goal =.. [Put_pred,Fieldname,Ptr,Value],
		D1 = [:-(multifile(structs:user_get_contents/3)),
		      :-(discontiguous(structs:user_get_contents/3)),
		      structs:(user_get_contents(Term,Fieldname,Value):-
				Get_goal),
		      :-(multifile(structs:user_put_contents/3)),
		      :-(discontiguous(structs:user_put_contents/3)),
		      structs:(user_put_contents(Term,Fieldname,Value):-
				Put_goal)|D0]
	;   D1 = D0			% don't need these linkage clauses,
					% because there's nothing to link to
	).


/****************************************************************
			Union declarations
 ****************************************************************/

%  new_union(+Members, +Union_name, +Parent, +N0, -N, -Simplified_members,
%	-Size, -Alignment, +Goal, +D0, -D)
%  Members is the list of members of a union named Union_name.
%  Simplified_members is the same as Members, except that all member types
%  are given as type names, rather than expressions.  Size is the number
%  of bytes an instance of this union occupies, and Alignment is its
%  alignment constraint.  Parent is the user-supplied name for the type
%  that defines this one, N0 is the number of auxilliary types defined so
%  far, and N is the number after this type is defined.
%  Goal is the goal defining this type, for error-reporting
%  purposes.  D0 is a list of terms describing
%  type definitions seen but not interned, and D is this list plus the
%  processed version of this type declaration.

new_union(Members, Union_name, Parent, N0, N, Simplified_members, Size,
		Alignment, Goal, D0, D) :-
	accessor_names(Union_name, Get_pred, Put_pred, Addr_pred),
	new_union(Members, 0, Get_pred, Put_pred, Addr_pred, Union_name,
		Parent, N0, N, Simplified_members, Size, Goal, D0, D1),
	build_union_accessors(Union_name, Get_pred, Put_pred, Addr_pred,
			      D1, D),
	struct_or_union_alignment(Simplified_members, D, 0, Alignment).

%  new_union(+Members, +Size0, +Get_pred, +Put_pred, Addr_pred, +Union_name, 
%	+Parent, +N0, -N, -Simplified_members, -Size, +Goal, +D0, -D)
%  Build the accessor procedures necessary to access members of a union.
%  Members is a list of members of the union.  Get_pred and Addr_pred
%  are the names of the accessor procedures that must be generated. 
%  Union_name is the name of the union being defined, used in error
%  messages.  Size is the greater of Size0 and the number of bytes that
%  must be allocated for any of the members listed on MEMBERS. 
%  Simplified_members is as described above.  Parent is the user-supplied
%  name for the type that defines this one, N0 is the number of auxilliary
%  types defined so far, and N is the number after this type is defined. 
%  Goal is the goal defining this type, for error-reporting
%  purposes.  D0 is a list of terms describing
%  type definitions seen but not interned, and D is this list plus the
%  processed version of this type declaration.

new_union([], Size, _, _, _, _, _, N, N, [], Size, _, D, D).
new_union([Member_name:Type_expr|Members], Size0, Get_pred, Put_pred,
	  	Addr_pred, Union_name, Parent, N0, N,
		[Member_name:Type_name|Simplified_members], Size,
		Goal, D0, D) :-
	(   get_type_name(Type_expr, Parent, N0, N1, Type_name, Size1, _,
		    D0, D1, Goal),
	    integer(Size1) ->
		build_member_accessors(Member_name, Type_name,
			Get_pred, Put_pred, Addr_pred, D1, D2),
		maximum(Size0, Size1, Size2),
		new_union(Members, Size2, Get_pred, Put_pred, Addr_pred,
			Union_name, Parent, N1, N, Simplified_members, Size,
			Goal, D2, D)
	;   print_message(error,
		    domain_error(Goal,1,fixed_size_type,Type_expr,'')),
	    fail
	).

%  build_member_accessors(+Member_name, +Type_name, +Get_pred, +Addr_pred,
%		+Clauses0, -Clauses)
%  Clauses is the list of clauses necessary to access member Member_name,
%  of type Type_name, followed by Clauses0.  Other args are as above.

build_member_accessors(Member_name, Type_name, Get_pred, Put_pred,
		Addr_pred, Clauses0,
		[:-(discontiguous(structs:Addr_pred/3)),
		 structs:Addr_head|Clauses]) :-
	Addr_head =.. [Addr_pred,Member_name,Ptr,Value],
	Value =.. [Type_name,Ptr],
	(   accessor_goals(Type_name, Ptr, 0, Value1, Clauses0,
			   Get_goal, Put_goal) ->
		Get_head =.. [Get_pred,Member_name,Ptr,Value1],
		Put_head =.. [Put_pred,Member_name,Ptr,Value1],
		Clauses=[:-(discontiguous(structs:Get_pred/3)),
			 structs:(Get_head:-Get_goal),
			 :-(discontiguous(structs:Put_pred/3)),
			 structs:(Put_head:-Put_goal)
			 |Clauses0]
	;   Clauses=Clauses0		% can't access contents of this slot
	).


%  build_union_accessors(+Union_name, +Get_pred, +Put_pred, +Addr_pred,
%	+D0, -D)
%  Build and assert the clauses that link the user-visable accessor
%  procedures to the accessor procedures for union Union_name, named
%  Get_pred and Addr_pred.  D0 is the list of clauses defining the
%  accessor procedures, and D is this list plus the new union accessors.
%  It is possible for a union to have no members the contents of which
%  can be accessed, in which case, don't generate the linkage clause
%  for Get_pred.

build_union_accessors(Type_name, Get_pred, Put_pred, Addr_pred, D0, D) :-
	Addr_goal =.. [Addr_pred,Membername,Ptr,Value],
	Term =.. [Type_name,Ptr],
	D = [:-(multifile(structs:user_get_address/3)),
	     :-(discontiguous(structs:user_get_address/3)),
	     structs:(user_get_address(Term,Membername,Value):-Addr_goal)|D1],
	Head =.. [Get_pred,_,_,_],
	(   memberchk(structs:(Head:-_), D0) ->
		Get_goal =.. [Get_pred,Membername,Ptr,Value],
		Put_goal =.. [Put_pred,Membername,Ptr,Value],
		D1 = [:-(multifile(structs:user_get_contents/3)),
		      :-(discontiguous(structs:user_get_contents/3)),
		      structs:(user_get_contents(Term,Membername,Value):-
				Get_goal),
		      :-(multifile(structs:user_put_contents/3)),
		      :-(discontiguous(structs:user_put_contents/3)),
		      structs:(user_put_contents(Term,Membername,Value):-
			      Put_goal)|D0]
	;   D1 = D0			% don't need this linkage clause,
					% because there's nothing to link to
	).


/****************************************************************
			Procedures for all types
 ****************************************************************/

%  known_type_defn(+Type_name, -Simple_type_expr)
%  Like structs:user_type_defn/2, but also checks the dynamic shadow
%  version so it'll work under qpc.

known_type_defn(Type_name, Simple_type_expr) :-
	(   structs:user_type_defn(Type_name, Simple_type_expr) -> true
	;   qpc_user_type_defn(Type_name, Simple_type_expr)
	).

%  known_type_size(+Type_name, -Size, -Alignment)
%  Like structs:user_type_size/3, but also checks the dynamic shadow
%  version so it'll work under qpc.

known_type_size(Type_name, Size, Alignment) :-
	(   structs:user_type_size(Type_name, Size, Alignment) -> true
	;   qpc_user_type_size(Type_name, Size, Alignment)
	).

%  known_type_file(+Type_name, -File)
%  Like structs:user_type_file/2, but also checks the dynamic shadow
%  version so it'll work under qpc.

known_type_file(Type_name, File) :-
	(   structs:user_type_file(Type_name, File) -> true
	;   qpc_user_type_file(Type_name, File)
	).

%  clean_up_after_file
%  wipe out dynamic shadow versions of structs:user_type_defn/2 and
%  structs:user_type_size/3, so later loads won't find them.

clean_up_after_file :-
	retractall(qpc_user_type_defn(_,_)),
	retractall(qpc_user_type_size(_,_,_)),
	retractall(qpc_user_type_file(_,_)).


%  cleanup_definition(+Definition0, -Definition)
%  Definition is the definition we want to show users corresponding to
%  Definition0, a definition as we store them internally.
%  NB:  this is also defined in structs.pl.

cleanup_definition(Definition0, Definition) :-
	(   Definition0 = struct(Fields0) ->
		Definition = struct(Fields),
		cleanup_struct_fields(Fields0, Fields)
	;   Definition = Definition0
	).


%  cleanup_struct_fields(+Fields0, -Fields)
%  Fields0 is a list of field(Name,Type,Offset) terms; Fields is a list
%  of corresponding Name:Type terms.
%  NB:  this is also defined in structs.pl.

cleanup_struct_fields([], []).
cleanup_struct_fields([field(N,T,_)|Fields0], [N:T|Fields]) :-
	cleanup_struct_fields(Fields0, Fields).



%  accessor_names(+Name, -Get_pred, -Put_pred, -Addr_pred)
%  Get_pred, Put_pred, and Addr_pred are the appropriate names for
%  the accessor procedures for struct or union Name.

accessor_names(Name, Get_pred, Put_pred, Addr_pred) :-
	name(Name, Type_chars),
	append(Type_chars, "_field", Suffix),
	append("get_", Suffix, Get_chars),
	name(Get_pred, Get_chars),
	append("put_", Suffix, Put_chars),
	name(Put_pred, Put_chars),
	append(Type_chars, "_address", Suffix2),
	append("get_", Suffix2, Addr_chars),
	name(Addr_pred, Addr_chars).

%  accessor_goals(+Type_name, +Ptr, +Offset, +Value, +Defns, -Get_goal,
%	-Put_goal)
%  Get_goal and Put_goal are the appropriate goals for getting and putting
%  Value, a pointer to a C-type data structure of type Type_name, out of
%  and into memory starting at location Prt + Offset.

accessor_goals(Type_name, Ptr, Offset, Value, Defns, Get_goal, Put_goal) :-
	simplify_expr(Ptr+Offset, Addrexpr),
	known_type_defn(Type_name, Defns, Defn, _, _),
	(   primitive_type_size(Defn, _, _) ->
		primitive_type_accessors(Defn, Addrexpr, Value,
			Get_goal, Put_goal)
	;   Defn = pointer(Dest_type) ->
		Value =.. [Dest_type,Actual_value],
		Get_goal = (Actual_value is address_at(Addrexpr)),
		Put_goal = assign(address_at(Addrexpr),Actual_value)
	;   Defn = enum(_Enums) ->
		to_enum_goal(Type_name, Code_value, Value, ToGoal),
		from_enum_goal(Type_name, Code_value, Value, FromGoal),
		Get_goal = (Code_value is integer_at(Addrexpr),
			    structs:FromGoal),
		Put_goal = (structs:ToGoal,
			    assign(integer_at(Addrexpr),Code_value))
	).

%  primitive_type_accessors(+Type_name, +Addrexpr, +Value, -Get_goal,
%		-Put_goal)
%  same as accessor_goals/6 above, except that it is known that Type_name
%  is a primitive type.

%  note that we treat long the same as address here.

primitive_type_accessors(long, Addrexpr, Value,
		Value is /*long*/address_at(Addrexpr),
		assign(/*long*/address_at(Addrexpr),Value)).
primitive_type_accessors(integer, Addrexpr, Value,
		Value is integer_at(Addrexpr),
		assign(integer_at(Addrexpr),Value)).
primitive_type_accessors(short, Addrexpr, Value,
		Value is integer_16_at(Addrexpr),
		assign(integer_16_at(Addrexpr),Value)).
primitive_type_accessors(char, Addrexpr, Value,
		Value is integer_8_at(Addrexpr),
		assign(integer_8_at(Addrexpr),Value)).
primitive_type_accessors(unsigned_long, Addrexpr, Value,
		Value is /*long*/address_at(Addrexpr),
		assign(/*long*/address_at(Addrexpr),Value)).
primitive_type_accessors(unsigned_integer, Addrexpr, Value,
		Value is integer_at(Addrexpr),
		assign(integer_at(Addrexpr),Value)).
primitive_type_accessors(unsigned_short, Addrexpr, Value,
		Value is unsigned_16_at(Addrexpr),
		assign(unsigned_16_at(Addrexpr),Value)).
primitive_type_accessors(unsigned_char, Addrexpr, Value,
		Value is unsigned_8_at(Addrexpr),
		assign(unsigned_8_at(Addrexpr),Value)).
primitive_type_accessors(float, Addrexpr, Value,
		Value is single_at(Addrexpr),
		assign(single_at(Addrexpr),Value)).
primitive_type_accessors(double, Addrexpr, Value,
		Value is double_at(Addrexpr),
		assign(double_at(Addrexpr),Value)).
primitive_type_accessors(address, Addrexpr, Value,
		Value is address_at(Addrexpr),
		assign(address_at(Addrexpr),Value)).
primitive_type_accessors(atom, Addrexpr, Value,
		get_atom(Ptr, Offset, Value),
		put_atom(Ptr, Offset, Value)) :-
	(   var(Addrexpr) -> Addrexpr = Ptr, Offset = 0
	;   Addrexpr = Ptr+Offset
	).
primitive_type_accessors(string, Addrexpr, Value,
		get_string(Ptr, Offset, Value),
		put_string(Ptr, Offset, Value)) :-
	(   var(Addrexpr) -> Addrexpr = Ptr, Offset = 0
	;   Addrexpr = Ptr+Offset
	).


%  struct_or_union_alignment(+Fields_or_members, +D, +Alignment0, -Alignment)
%  Alignment is the byte alignment necessary for a struct or union with
%  Fields_or_members, or Alignment0, whichever is greater.
%  Fields_or_members is in simplified form.  This code assumes that
%  the alignment necessary for a struct or union is the greatest
%  alignment necessary for any of its fields or members.


struct_or_union_alignment([], _, Alignment, Alignment).
struct_or_union_alignment([Member|Rest], D, Alignment0, Alignment) :-
	(   Member = _:Type_name -> true
	;   Member = field(_,Type_name,_)
	),
	known_type_defn(Type_name, D, _, _, Alignment1),
	maximum(Alignment0, Alignment1, Alignment2),
	struct_or_union_alignment(Rest, D, Alignment2, Alignment).


%  maximum(+X, +Y, -Z)
%  Z is the greater of X and Y, both numbers.

maximum(X, Y, Z) :- (X>=Y -> Z=X ; Z=Y).


%  simplify_is(+Expr, +Var, -Goal)
%  A very simple simplifier.  Goal is the goal necessary to bind Var to
%  the value of Expr.  Var may be bound, and Goal bound to true, if the
%  expression can be simplified to a single variable or constant.

simplify_is(Expr0, Var, Goal) :-
	simplify_expr(Expr0, Expr),
	(   (   var(Expr)
	    ;   integer(Expr)
	    ) ->
		Var = Expr,
		Goal = true
	;   Goal = is(Var,Expr)
	).

%  simplify(+Expr0, -Expr)
%  the actual simplifier.  Expr is arithmetically equivalent to Expr0.

simplify_expr(Var, Var) :-
	(   var(Var)
	;   integer(Var)
	),
	!.
simplify_expr(*(Expr1,Expr2), Expr) :-
	simplify_expr(Expr1, Expr1a),
	simplify_expr(Expr2, Expr2a),
	(   Expr1a == 1 -> Expr = Expr2a
	;   Expr2a == 1 -> Expr = Expr1a
	;   Expr1a == 0 -> Expr = 0
	;   Expr2a == 0 -> Expr = 0
	;   Expr = *(Expr1a,Expr2a)
	).
simplify_expr(+(Expr1,Expr2), Expr) :-
	simplify_expr(Expr1, Expr1a),
	simplify_expr(Expr2, Expr2a),
	(   Expr1a == 0 -> Expr = Expr2a
	;   Expr2a == 0 -> Expr = Expr1a
	;   Expr = +(Expr1a,Expr2a)
	).

%  conjoin(+Goal1, +Goal2, -Conj)
%  Conj is the conjunction of Goal1 and Goal2.  Drops redundant 'true's.

conjoin(Goal1, Goal2, Conj) :-
	(   Goal1 == true -> Conj = Goal2
	;   Goal2 == true -> Conj = Goal1
	;   Conj = (Goal1,Goal2)
	).




/****************************************************************
			foreign file handling
 ****************************************************************/

%  process_pred_spec(+Spec0, +Module, +Clause, -Spec, -WrapperClause)
%  Spec0 is a foreign predicate specification as described in the QP
%  manuals.  Spec is a different predicate specification to be used
%  instead.  WrapperClause is the extra clause needed to define the foreign
%  pred.  As usual, Module is the module this foreign predicate is to
%  be defined in.  Fails if this is not a typed foreign predicate.
%  Clause is the original foreign/2 or /3 clause for error reporting.

process_pred_spec(Spec0, Clause, Spec, Extras) :-
	functor(Spec0, Pred0, Arity),
	functor(Head, Pred0, Arity),
	atom_chars(Pred0, Chars),
	atom_chars(Pred, [0'$|Chars]),
	functor(Spec1, Pred, Arity),
	functor(Body, Pred, Arity),
	process_pred_args(Arity, Spec0, Clause, Spec1, Head, Body,
			  true, Pre, true, Post, false, Needed),
	(   Needed == false ->
		% We don't need the wrapper clause, but we may have used
		% some type name aliases, so we don't want to just fail.
		Extras = [],
		Spec1 =.. [_|Args],		% not fast, but good
		Spec =.. [Pred0|Args]		% enough here
	;   Extras = [:-(Head,(Pre,Body,Post))],
	    Spec = Spec1
	).


%  process_pred_args(+N, +Spec0, +Clause, +Spec, +Head, +Body,
%	+PreGoals0, -PreGoals, +PostGoals0, -PostGoals,
%	+NeedWrapperClause0, -NeedWrapperClause)
%  Process arguments up to N of Spec0, a foreign predicate spec.
%  Spec will be the new foreign predicate spec, and Head:-Body
%  will define the wrapper clause to strip off/add on foreign
%  wrappers.  NeedWrapperClause is either true
%  or false, depending on whether or not there is spec of a user-defined
%  type in some argument position <= N.  If no user-defined types are
%  specified in any argument positions, process_pred_args/7 fails.

process_pred_args(N, Spec0, Clause, Spec, Head, Body, Pre0, Pre, Post0, Post,
	    NeedWrapperClause0, NeedWrapperClause) :-
	(   N =:= 0 ->
		NeedWrapperClause = NeedWrapperClause0,
		Pre0 = Pre, Post0 = Post
	;   arg(N, Spec0, Arg_spec),
	    arg(N, Spec, New_spec),
	    arg(N, Head, Head_arg),
	    arg(N, Body, Body_arg),
	    N1 is N-1,
	    handle_arg_spec(Arg_spec, Clause, New_spec, Head_arg, Body_arg,
			    Pre0, Pre1, Post0, Post1,
			    NeedWrapperClause0, NeedWrapperClause1),
	    process_pred_args(N1, Spec0, Clause, Spec, Head, Body,
		    Pre1, Pre, Post1, Post,
		    NeedWrapperClause1, NeedWrapperClause)
	).

%  handle_arg_spec(+Arg_spec, +Clause, -New_spec, -Head_arg, -Body_arg,
%	  +Pre0, -Pre, +Post0, -Post,
%	  +NeedWrapperClause0, -NeedWrapperClause)
%  Arg_spec is an argument specification in a foreign predicate
%  specification, and Head_arg and Body_arg are the appropriate
%  arguments for that argument position in a linkage procedure.  They
%  will be bound together if Arg_spec does not specify a user-defined
%  type; if not, Head_arg will be the foreign term corresponding to
%  the address Body_arg.  New_spec is the real foreign arg spec to
%  be given to Prolog.  Head_arg \== Body_arg, then NeedWrapperClause
%  is true, else it is NeedWrapperClause0.  Clause is the original
%  foreign/2 or /3 clause for error reporting.

handle_arg_spec(+Type, Clause, +New_type, Head_arg, Body_arg,
		Pre0, Pre, Post, Post, 
		NeedWrapperClause0, NeedWrapperClause) :-
	handle_arg_type(Type, +Type, Clause, New_type, Head_arg, Body_arg,
		Pre0, Pre,
		NeedWrapperClause0, NeedWrapperClause, +).
handle_arg_spec(-Type, Clause, -New_type, Head_arg, Body_arg,
		Pre, Pre, Post0, Post,
		NeedWrapperClause0, NeedWrapperClause) :-
	handle_arg_type(Type, -Type, Clause, New_type, Head_arg, Body_arg,
		Post0, Post,
		NeedWrapperClause0, NeedWrapperClause, -).
handle_arg_spec([-Type], Clause, [-New_type], Head_arg, Body_arg,
		Pre, Pre, Post0, Post, 
		NeedWrapperClause0, NeedWrapperClause) :-
	handle_arg_type(Type, [-Type], Clause, New_type, Head_arg, Body_arg,
		Post0, Post,
		NeedWrapperClause0, NeedWrapperClause, -).

%  handle_arg_spec(+Arg_spec, +Clause, -New_spec, -Head_arg, -Body_arg,
%	  +ExtraGoals0, -ExtraGoals,
%	  +NeedWrapperClause0, -NeedWrapperClause, +PlusMinus)
%  Just like handle_arg_spec/7, except that Arg_spec does not have mode
%  information (eg, no +integer, -integer, or [-integer]; just integer).

handle_arg_type(pointer(Type), _Spec, _Clause, NewSpec,
		Head_arg, Body_arg, EG, EG, _, true, _) :-
	!,
	( atom(Type) ->
	      Head_arg =.. [Type,Body_arg],
	      NewSpec = address(Type)
	; known_type_defn(Type_name, Type) -> % This could be a hack!
	      Head_arg =.. [Type_name,Body_arg],
	      NewSpec = address(Type_name)
	).
handle_arg_type(Type, Spec, Clause, New_type, Head_arg, Body_arg,
		EG0, EG,
		NeedWrapperClause0, NeedWrapperClause, PlusMinus) :-
	(   known_type_defn(Type, enum(_)) ->
		enum_goal(PlusMinus, Type, Body_arg, Head_arg, EG1),
		New_type = integer,
		EG = (EG0, structs:EG1),
		NeedWrapperClause = true
	;   known_type_defn(Type, Defn) ->
		handle_arg_type(Defn, Spec, Clause,New_type,Head_arg, Body_arg,
		EG0, EG, NeedWrapperClause0, NeedWrapperClause, PlusMinus)
	;   valid_foreign_arg_type(Type, New_type),
	    NeedWrapperClause = NeedWrapperClause0,
	    Head_arg = Body_arg,
	    EG0 = EG
	).

%  valid_foreign_arg_type(+Type0, -Type).
%  Type0 is a valid primitive foreign type, and Type is the type to be
%  used by the the foreign interface.  This does mappings like
%  char -> integer.

valid_foreign_arg_type(long, integer).
valid_foreign_arg_type(integer, integer).
valid_foreign_arg_type(short, integer).
valid_foreign_arg_type(char, integer).
valid_foreign_arg_type(unsigned_long, integer).
valid_foreign_arg_type(unsigned_integer, integer).
valid_foreign_arg_type(unsigned_short, integer).
valid_foreign_arg_type(unsigned_char, integer).
valid_foreign_arg_type(float, float).
valid_foreign_arg_type(double, double).
valid_foreign_arg_type(atom, atom).
valid_foreign_arg_type(string, string).
valid_foreign_arg_type(string(N), string(N)).
valid_foreign_arg_type(address, address).
valid_foreign_arg_type(address(X), address(X)).


/****************************************************************
			Term Expansion code
 ****************************************************************/

term_exp(X, _) :-
	var(X),
	!,
	fail.
term_exp(:-(X), Clauses) :-
	nonvar(X),
	X = foreign_type(Foreigns),
	compile_foreign_type_decl(Foreigns, :-(foreign_type(Foreigns)),
		[], Clauses1),
	patch_bug_3911(Clauses1, Clauses),
	assert_as_needed(Clauses).
term_exp(foreign(Fn,Lang,Spec0),
		[:-(discontiguous(foreign/3)),
		 :-(dynamic(foreign/3)),
		 foreign(Fn,Lang,Spec)|ExtraClauses]) :-
	process_pred_spec(Spec0, foreign(Fn,Lang,Spec0),
		Spec, ExtraClauses).
term_exp(foreign(Fn,Spec0),
		[:-(discontiguous(foreign/2)),
		 :-(dynamic(foreign/2)),
		 foreign(Fn,Spec)|ExtraClauses]) :-
	process_pred_spec(Spec0, foreign(Fn,Spec0),
		Spec, ExtraClauses).
term_exp(end_of_file, _) :-
	% can be run multiple times without problems
	structs_decl:clean_up_after_file,
	fail.

assert_as_needed([]).
assert_as_needed([Cl|Cls]) :-
	(   needs_assertion(Cl, Cl1) ->
		assert(Cl1)
	;   true
	),
	assert_as_needed(Cls).

needs_assertion(structs:user_type_defn(A,B),
		qpc_user_type_defn(A,B)).
needs_assertion(structs:user_type_size(A,B,C),
		qpc_user_type_size(A,B,C)).
needs_assertion(structs:user_type_file(A,B),
		qpc_user_type_file(A,B)).


patch_bug_3911([], []).
patch_bug_3911([X|Xs], [Y|Ys]) :-
	copy_term(X, Y),
	patch_bug_3911(Xs, Ys).


:- multifile user:clause_expansion/3.

user:clause_expansion(X, _, Y) :-
	term_exp(X, Y).


/****************************************************************
			Testing code
 ****************************************************************/

end_of_file.

:- use_module(library(basics)).

user:test(X) :-
	compile_foreign_type_decl(X, (:- foreign_type(X)), [], L),
	(   member(C, L),
	    portray_clause(C),
	    fail
	;   true
	).
