(in-package "PARSER")

(defun trap-questions (sa)
    (cond ((cca-p sa) 
	   (let ((result nil))
	     (dolist (element (CCA-acts sa) result)
		     (when (first (trap-questions element))
			 (setf result (append (car (trap-questions element)) result))
			 (setf (CCA-acts sa) (remove element (CCA-acts sa) :test #'equal))))
	     (if (CCA-acts sa)
		 (list result (break-cca sa))
	       (list result nil))))
	  ((and (sa-p sa) 
		(equal (SA-type sa) 'SA-WH-QUESTION) 
		(propp (SA-semantics sa))
		(or (member ':TAKE-TIME (find-cl (SA-semantics sa)))
		    (subsetp '(:BE (:DISTANCE :OF)) (find-cl (SA-semantics sa)) :test #'equal)
		    (subsetp '(:BE (:TIME-DURATION :OF)) (find-cl (SA-semantics sa)) :test #'equal)))
	   (make-lookup-table (list sa))
	   (format *robust-stream* "~%;; ~S~%" sa) 
	   (finish-output *robust-stream*)
	   (list (list (list 'question (find-question (SA-semantics sa)) (find-path (SA-semantics sa)))) nil))

	  ((and (sa-p sa) (equal (SA-type sa) 'SA-WH-QUESTION)
		(propp (SA-semantics sa))
		(subsetp '(:BE :EQUAL) (find-cl (SA-semantics sa)))
		(member 'LENGTH (SA-input sa)))
	   (make-lookup-table (list sa))
	   (format *robust-stream* "~%;; ~S~%" sa) 
	   (finish-output *robust-stream*)
   (list (list (list 'question '(:HOW-MUCH :DISTANCE) (find-path (SA-semantics sa)))) nil))
	  ((and (sa-p sa) (equal (SA-type sa) 'SA-WH-QUESTION)
		(propp (SA-semantics sa))
		(subsetp '(:BE :EQUAL) (find-cl (SA-semantics sa))))
	   (make-lookup-table (list sa))
	   (format *robust-stream* "~%;; ~S~%" sa) 
	   (finish-output *robust-stream*)
   (list (list (list 'question '(:HOW-MUCH :TIME-DURATION) (find-path (SA-semantics sa)))) nil))
	  ((sa-p sa) (list nil (break-sa sa)))
	  (t (error "Non-speech-act passed to function trap-questions."))))

(defun find-question (form)
  (let ((temp (find-edges form)))
    (do ((args temp)
	 (result nil)
	 (bool nil))
	(bool result)
	(cond ((not args) (setf bool t))
	      ((or (equal (find-status (third (first args))) '(:HOW :MUCH)) 
		   (equal (find-status (third (first args))) ':HOW-MUCH))
	       (setf result (list ':HOW-MUCH (rest (find-cl (third (first args))))))
	       (setf bool t))
	      (t (setf args (rest args)))))))

(defun find-path-aux (args result)
	(cond ((not args) result)
	      ((propp (rest (lookup (third (first args)))))
	       (let ((temp (find-edges (rest (lookup (third (first args)))))))
		 (if (car temp)
		     (find-path-aux (append temp (rest args)) result)
		   (find-path-aux (rest args) result))))
	      ((equal (rest (find-cl (third (first args)))) ':ROUTE)
	       (let* ((now (first args))
		     (temp (find-edges (rest (lookup (third now))))))
		 (if (car temp)
		     (let ((path (find-path (rest (lookup (third (first args)))))))
		       (if (second path) 
			   (setf result path)
			 (setf result (construct-path (rest (lookup (third now)))))))
		   (find-path-aux (rest args) result))))
	      ((equal (rest (find-cl (third (first args)))) ':LENGTH)
	       (let* ((now (first args))
		     (temp (find-edges (rest (lookup (third now))))))
		 (if (car temp)
		     (let ((path (find-path (rest (lookup (second (assoc '(:LENGTH :OF) temp :test #'equal)))))))
		       (if (second path) 
			   (setf result path)
			 (setf result '(:PATH nil))))
		   (find-path-aux (rest args) result))))
	      ((equal (rest (find-cl (third (first args)))) ':PATH)
	       (setf result (construct-path (rest (lookup (third (first args)))))))
	      (t (find-path-aux (rest args) result))))

(defun find-path (form)
  (find-path-aux (find-edges form) NIL))

;    (do ((args (find-edges form))
;	 (result nil)
;	 (bool nil))
;	(bool (if (not result) '(:PATH NIL) result))
;	(format t "~%~S" (first args))
;	(cond ((not args) (setf bool t))
;	      ((propp (rest (lookup (third (first args)))))
;	       (let ((temp (find-edges (rest (lookup (third (first args)))))))
;		 (if (car temp)
;		     (setf args (append temp (rest args)))
;		   (setf args (rest args)))))
;	      ((equal (rest (find-cl (third (first args)))) ':ROUTE)
;	       (format t "~%~S" (first args))
;	       (let* ((now (first args))
;		     (temp (find-edges (rest (lookup (third now))))))
;		 (if (car temp)
;		     (let ((path (find-path (rest (lookup (third (first args)));))))
;		       (if (second path) 
;			   (setf result path)
;			 (setf result (construct-path (rest (lookup (third now))))))
;		       (format t "~%~S" now)
;		       (setf bool t))
;		   (setf args (rest args)))))
;	      ((equal (rest (find-cl (third (first args)))) ':PATH)
;	       (setf result (construct-path (rest (lookup (third (first args))))))
;	       (setf bool t))
;	      (t (setf args (rest args))))))

(defun construct-path (path)
  (let ((result (list ':PATH)) (edges (find-edges (rest path))))
    (if (first edges)
	(dolist (element (find-edges (rest path)) result)
		(setf result (append result (list (list (first element) (find-name (third element)))))))
      (append result (find-status (rest path))))))

(defun find-name (var)
  (second (assoc ':LEX (cddr (lookup var)))))

(defun find-status (var)
  (second (assoc ':STATUS (cddr (lookup var)))))
