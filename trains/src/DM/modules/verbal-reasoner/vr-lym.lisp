;; Time-stamp: <Mon Jan 20 14:35:20 EST 1997 ferguson>

(when (not (find-package :verbal-reasoner))
  (load "verbal-reasoner-def"))
(in-package verbal-reasoner)

;; lymphocyte interface for vr.

;; Warnings, and notes:
;; Checking the utility of a prior rule, will only work if the rule actually matched (so presumably the utility
;;  will always be positive). That's because the matcher prunes meta rules that have any dependancy on a unmatched
;;  prior rule. It would be hard to make an exception for utility, so possibly, if it's really needed, we need to 
;;  add a new operator that can be easily checked that just matches if the rule was (or was not) fired. That is,
;;  foo^utility=0 would never match, even if foo was not matched (because the engine needs to find the record
;;  for foo in order to trigger this rule; the part "utility=0" is handed to the pattern matcher, the engine
;;  ignores it). Note: this is only true for meta rules, "not" matching input works as you would expect (because 
;;  there is always "input" to hand to the matcher).

(set-syntax :lymphocyte)

(in-rulebase :focus)                    ; also inherited into the VR rulebase.

;; These rules are needed to update the focus. We do this before general matching under VR (that is invoke a 
;; generation from :focus rules only, update *current-focus*, and then invoke the engine on everything else.

;; ref-object-of-type is wider than just an object of type engine.

(add-rule [0 (engine-nps ?engines ?positions) *
             [^objects=[($** ($is ?engines (lambda (x) (or (engine-p x) (ref-object-of-types x *engine-synonyms*)))))
                        ($if ?engines)]] ; can't do this by type due to $**
             postmatch= ((?positions (foreach (?engine ?engines)
                                              (engine-position ?engine))))])

(add-rule [0 (goal-nps ?goals) *
             [^objects=[($** ($is ?goals@t-non-null (lambda (x) (ref-object-of-types x '( :goal :destination :target)))))]]])

(add-rule [0 (route-nps ?routes) *
             [^objects=[($** ($is ?routes@t-non-null (lambda (x) (or (route-p x) (ref-object-of-types x '( :route))))))]]])
#||
(eval-when (load eval)
  (lym:trace-lym-rule engine-nps goal-nps))
||#

(add-rule [0 (yn-question-p ?sem) *
             [^type=sa-yn-question
              ^semantics=?sem]])

(add-rule [0 existance-question *       ; generated by dm to handle a timeout, just return it
             [^type=sa-yn-question
              ^initiator= :self
              ^semantics= :existance]
             utility= 20
             produces= (vr-ask-yn-question :existance)])

(add-rule [0 confirm-question *
             [^type=sa-yn-question
              ^paths=nil
              ^semantics=( :confirm :okay)
              ($if (get-output-sas))]   ; already said something, built in confirm
             utility= 20
             produces= (progn)])             ; have to put something here, so we know it's a production rule

(add-rule [0 confirm-question-1 confirm-question
             [^type=sa-yn-question
              ^paths=nil
              ^semantics=( :confirm :okay)
              ($if (null (get-output-sas)))]   ; already said something, built in confirm
             utility= 20
             produces= (vr-greet t)])


(add-rule [1 focus-change-by-position *
             [engine-nps^positions=?pos
              engine-nps^engines=?eng@t-non-null
              yn-question-p^utility=?_@t-positive
              ($if (and (car ?pos) (not (eq (car ?pos) :unknown)))) ; known position
              ($if (and (identity (car ?pos)) ; did we find a position?
                        (not (eq *current-focus* (car ?eng)))))] ; is the engine already in focus?
             utility= 20
             produces= (if (current-rulebase-p :focus) ; only do this when executing focus rules.
                           (vr-update-focus (vr-find-engine (car ?pos) t)))])

;; like above, but not a yn question
(add-rule [1 focus-change-by-position-1 focus-change-by-position
             [engine-nps^positions=?pos
              engine-nps^engines=?eng@t-non-null
              ($if (and (car ?pos) (not (eq (car ?pos) :unknown)))) ; known position
              ;; we could put the following on our utility instead (fall to 0 if false)
              ($if (and (identity (car ?pos)) ; did we find a position?
                        (not (eq *current-focus* (car ?eng)))))] ; is the engine already in focus?
             utility= 19                ; lower utility, so we get the yn interp if available.
             produces= (if (current-rulebase-p :focus) ; only do this when executing focus rules.
                           (vr-update-focus (vr-find-engine (car ?pos) nil)))])

#||
(eval-when (load eval)
  (lym:trace-lym-rule focus-change-by-position))
||#

(add-rule [1 focus-change-to-other *
             [engine-nps^engines=?eng@t-non-null
              ($if (mentioned-predicate *other-pred* (car ?eng)))]
             utility= (if (eql (list-length *all-engines*) 2)
                          20
                        0)
             produces= (if (current-rulebase-p :focus) ; only do this when executing focus rules.
                           (vr-update-focus (other-engine *all-engines*)))])

(add-rule [1 focus-change-to-other-amb *
             [engine-nps^engines=?eng@t-non-null
              ($if (mentioned-predicate *other-pred* (car ?eng)))]
             utility= (if (not (eql (list-length *all-engines*) 2))
                          19
                        0)
             produces= (vr-ambiguous *all-engines* :engine)])

(in-rulebase :vr)

;; These set up some vars to be used at higher levels.
(add-rule [0 (reliability ?reliability) *
             [^reliability=?reliability]])

(add-rule [0 (paths ?paths) *
             [^paths=?paths]])

(add-rule [0 (focus ?focus) *
             [^focus=?focus]])

(add-rule [0 (semantics ?semantics) *
             [^semantics=?semantics@t-non-null]])

(add-rule [0 (defs ?defs) *
             [^defs=?defs]])

(add-rule [0 wh-question-p *
             [^type=sa-wh-question]])

(add-rule [0 (wh-be-p ?sub ?obj ?properties) *
             [^type=sa-wh-question
              ^semantics=?sem
              ($if (perf-be-p nil nil ?sem))]
             postmatch= ((?sub (nth-value 1 (perf-be-p nil nil ?sem)))
                         (?obj (nth-value 2 (perf-be-p nil nil ?sem)))
                         (?properties (nth-value 3 (perf-be-p nil nil ?sem))))])

(add-rule [0 (at-loc ?at-loc ?engine) *
             [^semantics=?sem ($if (or (rperf-prop-p :at-loc ?sem)
                                       (rperf-prop-p :at ?sem))==?foo)]
             postmatch= ((?at-loc (if (consp ?foo) (second ?foo) ?foo))
                         (?engine (unless (vari-p ?at-loc)
                                    (vr-find-engine ?at-loc t))))])

(add-rule [0 can-send *
             [^semantics=?sem ($if (perf-prop-p '( :can :move) ?sem))]])

(add-rule [1 (preprocess-paths ?ppaths) *
             [paths^paths=?paths@t-non-null
              ($if (focus-changed-p))]
             utility= 5
             postmatch= ((?ppaths (fixup-paths (update-for-new-focus ?paths))))])

(add-rule [1 (preprocess-paths-1 ?ppaths) preprocess-paths
             [paths^paths=?paths]
             utility= 4
             postmatch= ((?ppaths (fixup-paths ?paths)))])

;; classify rules into type of action.


;;;; DISCOURSE ACTIONS

;; if we changed focus, and otherwise can't figure out what will happen, we can invoke this.

(add-rule [1 handle-focus-change-only *
             [paths^paths=nil
              ($if (and (focus-changed-p)
                        (or (handling-reject-p)
                            (error-frame-p))))]
             cost= 5
             utility= 18
             produces= (redo-plan-based-on-focus-shift)])

(add-rule [1 handle-focus-change-only-1 handle-focus-change-only
             [paths^paths=nil
              defs^defs=(:new-focus)]
             utility= 10
             produces= (progn (set-focus-changed) ; for naked cities that are now mentioned.
                              (vr-confirm))]) ; confirm the shift in focus, handled by reference (not part of reject).

(add-rule [0 nolo-comprendez *
             [?_] ; if we can't figure out anything else, this is cheap and fast!
             cost= 0
             utility= 1
             produces= (progn (wazzawump :prince)        ; problem may be I don't have the rule
                              (log-warning :prince "Prince: can't handle input: ~S" *current-input*))])
             
(add-rule [0 greeting *
             [^type=sa-greet]
             utility= (if (greet-frame-p)
                          2             ; better this than a nolo-comprendez
                        20)
             produces= (vr-greet)])

(add-rule [0 close *
             [^type=sa-close ^mode=:mouse]
             utility= 20
             produces= (generate 'sa-close)])

(add-rule [0 close1 close
             [^type=sa-close ($not ^mode=:mouse)]
             utility= 20
             produces= (progn (set-did-close)
                              (vr-ask-yn-question :quit))])

(add-rule [0 close2 close
             [^type=sa-tell ^defs=?defs ($if (member :done ?defs))]
             utility= 20
             produces= (progn (set-did-close) (vr-ask-yn-question :quit))])

(add-rule [0 close3 close
             [^type=sa-tell ^semantics=?sem ($if (perf-be-p :done nil ?sem))]
             utility= 20
             produces= (progn (set-did-close) (vr-ask-yn-question :quit))])

(add-rule [0 apology *
             [^type=sa-apologize]
             utility= 20
             produces= (vr-handle-apology)])

(add-rule [0 ambiguous *
             [?input^type=sa-ambiguous]
             utility= 20
             produces= (push-proposed-sas ?input)])

;; check for a break
(add-rule [0 break *
             [^type=sa-break]
             utility= 20
             produces= ()])             ; ignore it, just used to keep us from spanning. 

;; check for a restart
(add-rule [0 restart * 
             [^type=sa-restart 
              ^defs=?act
              ^mode=:mouse]
             utility= 20
             produces= (execute-restart ?act)])


(add-rule [0 restart-1 restart
             [($or ^type=sa-restart
                   ($and ^type=sa-request
                         ($if (eqmemb :restart ?act))))]
             utility= 19
             produces= (vr-ask-yn-question :restart)])

;; expressives

(add-rule [0 expressive-thanks *
             [^type=sa-expressive
              ($or ^semantics=:thanks ^semantics=:thank-you)]
             utility= 20
             produces= (vr-expressive :welcome)])

(add-rule [0 expressive *
             [^type=sa-expressive
              ($not ($or ^semantics=:thanks ^semantics=:thank-you))]
             utility= 20
             produces= (vr-expressive :ah)])

;; reject/correction

(add-rule [0 (reject-p ?sem) *
             [^type=sa-reject
              ^semantics=?sem]])

(add-rule [0 last-reject-p *
             [?_^type=sa-reject         ; was $eoi, but that won't work with incremental rules.
              ($if (or (not (remaining-acts-p)) ; nothing more
                       (notany #'sa-reject-p (remaining-acts-p))))]])

(add-rule [0 next-tell-object-p *
             [?_^type=sa-reject
              ($if (and (remaining-acts-p)
                        (eq 'speech-act (type-of (car (remaining-acts-p))))))]])

(add-rule [1 non-responsive-reject *
             [reject-p^sem=?sem@symbol
              ($if (member ?sem *existance-non-responsive-rejects*))]])
             
(add-rule [1 reject-subdialogue *
             [reject-p^sem=?sem@symbol
              ($if (and (not (member ?sem *existance-non-responsive-rejects*))
                        (existance-frame-p)
                        (not (future-request-p))))] ; handle "no, go to cleveland" in response to "are you there?", i.e. ignoring immediate question and dealing with prior result.
             utility= 20
             produces= (vr-expressive :fooey)])

(add-rule [1 reject-subdialogue-1 reject-subdialogue
             [reject-p^sem=?sem@symbol
              ($if (and (not (member ?sem *existance-non-responsive-rejects*))
                        (or (quit-frame-p)
                            (restart-frame-p))))]
             utility= 20
             produces= (vr-expressive :feh)])

(add-rule [1 reject-subdialogue-2 reject-subdialogue
             [reject-p^sem=?sem@symbol
              ($if (and (not (member ?sem *existance-non-responsive-rejects*))
                        (new-goal-frame-p)))]
             utility= 20
             produces= (vr-confirm)]) ; don't need to undo.

(add-rule [2 reject-focus *
             [reject-p^sem=?sem@t-non-null
              preprocess-paths^ppaths=nil
              non-responsive-reject^utility=?_@t-positive]
             utility= 25
             produces= (simple-undo)])

(add-rule [2 reject-focus-1 reject-focus
             [reject-p^sem=?sem@t-non-null
              preprocess-paths^ppaths=nil
              ($if (or (perf-prop-p :cancel ?sem)
                       (perf-prop-p :forget ?sem)))]
             utility= 24
             produces= (simple-undo)])

;; confirm
(add-rule [0 existance-confirm-p *
             [^type=sa-confirm
              ^paths=nil
              ($if (existance-frame-p))]
             utility= 20
             produces= (vr-expressive :ah)])

(add-rule [0 new-goal-confirm-p *
             [^type=sa-confirm
              ^paths=nil
              ($if (new-goal-frame-p))]
             utility= 20
             produces= (vr-add-new-goal)])

(add-rule [0 confirm-p *
             [^type=sa-confirm
              ($if (and *current-plan*
                        (not (eq *current-plan* (root-plan))) ; there's always a root plan
                        (not (plan-confirmed-p *current-plan*))))] ; we might be confirming something else, eventually search for it. For now, assume it's a pure discourse issue if the plan was confirmed.
             utility= 19
             ;; not confirming something we talked about? So pass it on to PS.
             produces= (execute-confirm *current-plan*)])

(add-rule [0 confirm-p-1 confirm-p
             [^type=sa-confirm]
             utility= 5
             produces= (progn)])               ; not so bad just to ignore a confirm, since the user may just interject one
                                        ; eg. start the conversation with "ok", etc.

;; unhandled-reject
(add-rule [0 unhandled-reject *
             [^paths=nil
              ($if (and (handling-reject-p)
                        (not (remaining-acts-p)) ; hmm
                        (not (reject-handled-p))))]
          utility= 15
          produces= (progn 
                      ;; try an alternate.
                      (set-reject-handled)
                      (execute-ps-strategies `( :reject-solution) *current-plan* nil))])

;; cancel

(add-rule [0 cancel-request *
             [^type=sa-request
              ^paths=?paths             ; might be, e.g. "cancel the route via pittsburgh"
              ^objects=?objects
              ^semantics=?sem@t-non-null
              ($if (or (perf-prop-p :cancel ?sem)
                       (perf-prop-p :forget ?sem)))]
             utility= 20
             ;; eventually handle qualifications, for now, assume it refers to the last item.
             produces= (let ((content (or (find-if #'route-p ?objects)
                                          ?paths)))
                         (set-reject-handled)
                         (if content
                             (execute-ps-strategies `( :cancel) *current-plan* content)
                           (simple-undo)))])

(add-rule [0 nevermind-reject cancel-request
             [^type=sa-reject
              ^paths=nil
              ^objects=?objects
              ^semantics=?sem
              ($if (and (member ?sem '( :nevermind :cancel :forget-it))
                        (null (find-if #'route-p ?objects))))]
             utility= 25
             produces= (progn (set-reject-handled)
                              (simple-undo))])

;; stay at cincinnati
(add-rule [0 stay *
             [^semantics=?sem@t-non-null
              ^type=sa-reject
              ($if (and (perf-prop-p :stay-until ?sem)
                        (city-p (rperf-prop-p :lobj ?sem))))]
             utility= 18                ; more specialized versions may override, e.g. "hold on".
             produces= (progn (set-reject-handled)
                              (execute-ps-strategies '( :modify-current :modify-backup) 
                                                     *current-plan* 
                                                     (make-path-quantum :to (rperf-prop-p :lobj ?sem))))])

(add-rule [0 stay-1 stay
             [^semantics=?sem@t-non-null
              ($if (and (perf-prop-p :stay-until ?sem)
                        (city-p (rperf-prop-p :lobj ?sem))))]
             utility= 17                ; more specialized versions may override, e.g. "hold on".
             produces= (execute-ps-strategies '( :modify-current :modify-backup) 
                                              *current-plan* 
                                              (make-path-quantum :to (rperf-prop-p :lobj ?sem)))])

;; go back to new york
(add-rule [0 go-back-request *
             [^type=sa-request
              ^paths=?paths@t-non-null
              ^semantics=?sem@t-non-null
              ($if (perf-prop-p :go-back ?sem))] ; for now, this seems the best way to handle it.
             utility= 20
             produces= (progn (set-reject-handled)
                              (execute-ps-strategies 
                               '( :modify-current :modify-backup)
                               *current-plan* ?paths))])

(add-rule [0 go-back-request-1 go-back-request
             [^type=sa-request
              ^paths=nil
              ^semantics=?sem@t-non-null
              ($if (perf-prop-p :go-back ?sem))] ; for now, this seems the best way to handle it.
             utility= 20
             produces= (progn (set-reject-handled)
                              (simple-undo))])
          

;; I'm here (after an "are you there?")
(add-rule [0 I-am-here *
             [^paths=nil
              ^semantics=?sem@t-non-null
              ($if (and (existance-frame-p) ;; I'm here response
                        (perf-prop-p :be sem)))]
             utility= 20
             produces= (let ((at (or (rperf-prop-p :at-loc ?sem)
                                     (rperf-prop-p :at ?sem))))
                         (if (and at
                                  (eq (car (terms at)) :i)
                                  (vari-p (cadr (terms at))) 
                                  (equalp (string (basic-name (second (terms at)))) "HERE")) ;yuck
                             (vr-expressive :good)))])

;; hold on (after an "are you there?")
(add-rule [0 wait *
             [^paths=nil
              ^semantics=?sem@t-non-null
              ($if (and (existance-frame-p) ;; wait response
                        (perf-prop-p :stay-until ?sem)))] ; need to check further.
             utility= 20
             produces= (progn (vr-confirm)
                              ;; increase timeout
                              (kb-request-kqml (create-request :display-kb 
                                                               `( :set-timeout-value
                                                                  ,(floor (* 3 (kb-request-kqml
                                                                                (create-request :display-kb 
                                                                                                '( :timeout-value)))))))))])
;; that's great

#||
(eval-when (load eval)
  (lym:trace-lym-rule compliment))
||#

(add-rule [0 compliment *
             [^type=sa-tell
              ^paths=nil
              ^semantics=?sem@t-non-null
              ($if (perf-be-p :good :that ?sem))]
             utility= 20
             produces= (progn (unless (eq *current-plan* (root-plan))
                                (execute-confirm *current-plan*)) ; naked compliment is usually a confirm.
                              (if (greet-frame-p)
                                  (vr-ask-wh-question :so-what) ; try to keep discourse moving... like a timeout.
                                (vr-expressive :welcome)))])

(add-rule [0 compliment-1 compliment
             [^type=sa-evaluation
              ^paths=nil
              ^semantics=?sem@t-non-null
              ($if (or (and (good-eval-p ?sem)
                            (null (remaining-acts-p)))
                       (member ?sem '( :thank-you :thanks))))]
             utility= 15
             produces= (progn (unless (eq *current-plan* (root-plan))
                                (execute-confirm *current-plan*)) ; naked compliment is usually a confirm.
                              (if (greet-frame-p)
                                  (vr-ask-wh-question :so-what) ; try to keep discourse moving... like a timeout.
                                (vr-expressive :welcome)))])

;; "good, but I really would rather go via chicago"
(add-rule [0 compliment-2 compliment
             [^type=sa-evaluation
              ^paths=nil
              ^semantics=?sem@t-non-null
              ($if (and (good-eval-p ?sem)
                        (remaining-acts-p)))]              ; not naked. (see above)
             utility= 10
             produces= (progn)]) ; ignore it.

;; "good, I'm done."
(add-rule [0 compliment-3 compliment
             [^type=sa-evaluation
              ^paths=nil
              ^semantics=?sem@t-non-null
              ($if (and (good-eval-p ?sem)
                        (or (did-close-p)
                            (future-act-p #'sa-close-p))))] ; not naked, close (see above)
             utility= 20
             produces= (unless (eq *current-plan* (root-plan))
                         (execute-confirm *current-plan*))]) ; don't say anything, in favor of the quit.

;; empty click, or <cr>
;;
;; really this is a recognition of the intent of the user to use the speech control box.
(add-rule [0 null-input *
             [^type=sa-null]
             utility= 10
             produces= (push-proposed-sas (make-sa-suggest
                                           :semantics :help-with-input))])

;; PROBLEM-SOLVING ACTIONS

;; looks like a discourse action (focus change), but 
;; U: send <garbled> to bath. 
;; S: I know bath is a goal, say something about it.
;; U: I mean the engine at frozzbozz.

(add-rule [1 handle-focus-change-only-2 handle-focus-change-only 
             [paths^paths=nil
              ($if (and (focus-changed-p)
                        (not (handling-reject-p))
                        (goal-frame-p)))] ;; just mentioned a goal.
             utility= 20
             produces= (respond-with-route (make-path-quantum :engine *current-focus* :to (goal-frame-p)))])

#||
(eval-when (load eval)
  (lym:trace-lym-rule handle-focus-change-only))
||#

;;;
;;; Handling y/n questions
;;;

#|| (lym:trace-lym-rule yn-question-engine ynq-engine ynq-engine-ground ynq-engine-unknown ynq-engine-send) ||#

(add-rule [1 (yn-question-eng ?eng ?sem) yn-question
             [yn-question-p^utility=?_@t-positive
              yn-question-p^sem=?sem
              engine-nps^engines=?eng@t-non-null]])

;; base case - can't identify the engine in the question

(add-rule [2 ynq-engine-unknown *
             [yn-question-eng^eng=?eng]
             produces= (vr-huh (car ?eng) :unknown *current-plan*)
             utility= 15])

;; engine found by reference, in the world. A different at-location was mentioned.
;; "Are we at pittsburgh?" referring to the focused engine.

(add-rule [2 ynq-engine-ground *
             [yn-question-eng^eng=?eng
              ($if (ground-engine-p ?eng))
              at-loc^engine=nil]
             produces= (vr-reject t)
             utility= 20])

(add-rule [2 ynq-engine-ground-1 ynq-engine-ground
             [yn-question-eng^eng=?eng
              ($if (ground-engine-p ?eng))
              at-loc^engine=?_@t-non-nil] ; talking about an engine
             produces= (vr-confirm t)
             utility= 20])

;; Simpler case, completely ground by reference. "Is there an engine at pittsburgh?" becomes :exists <engine4> and we say "yep".

(add-rule [2 ynq-engine-ground-2 ynq-engine-ground
             [yn-question-eng^eng=?eng
              yn-question-eng^sem=?sem
              ($if (and (ground-engine-p ?eng)
                        (resolved-existance-p ?eng ?sem)))]
             produces= (vr-confirm t)
             utility= 20])

;; ground by reference, just asking if we can send it there - handle indirect act
;; Can I send the engine at pittsburgh to chicago?

(add-rule [2 ynq-engine-send *
             [yn-question-eng^eng=?eng
              can-send^utility=?_@t-positive
              preprocess-paths^ppaths=?paths@t-non-null]
             produces= (respond-with-route ?paths)
             utility= 19])
             
;; For these, we have to find the engine: we have a generic description, that reference
;; didn't ground. "Is there a engine at raleigh" (and there isn't one), or 
;; "can you send the engine closest to raleigh" etc. (not that we handle that now, but
;; this is where we'd end up with a descriptor for the engine, instead of an engine.

(add-rule [2 (yn-question-engine ?answer-state ?eng ?engine) yn-question
             [yn-question-eng^eng=?eng
              engine-nps^positions=?pos
              ($if (and (car ?pos) (not (eq (car ?pos) :unknown)))) ; known position
              ($if (basic-for-reference-p (car ?eng)))]
 
             postmatch= ((?answer-state (basic-predicates (car ?eng)))
                         (?engine (vr-find-engine (car ?pos) t)))])

;; asking about engines along a path.

(add-rule [3 ynq-engine-path ynq-engine
             [yn-question-engine^utility=?_@t-positive
              preprocess-paths^ppaths=?_@t-non-null
              yn-question-engine^engine=NIL
              yn-question-engine^eng=?eng]
             produces= (vr-reject-and-elaborate t (car ?eng))
             utility= 25])

;; can i take engine foo to bar? treat as the indirect speech act.
(add-rule [3 ynq-engine-path1 ynq-engine
             [yn-question-engine^utility=?_@t-positive
              preprocess-paths^ppaths=?paths@t-non-null
              yn-question-engine^engine=?_@t-non-null]
             produces= (respond-with-route ?paths)
             utility= 25])

(add-rule [3 ynq-engine-there ynq-engine
             [yn-question-engine^utility=?_@t-positive
              preprocess-paths^ppaths=nil
              yn-question-engine^engine=?_@t-non-null
              yn-question-engine^eng=?eng]
             produces= (vr-confirm-and-elaborate t (car ?eng))
             utility= 25])
             
(add-rule [3 ynq-engine-there1 ynq-engine 
             [yn-question-engine^utility=?_@t-positive
              preprocess-paths^ppaths=nil
              yn-question-engine^engine=nil
              yn-question-engine^eng=?eng]
             produces= (vr-reject-and-elaborate t (car ?eng))
             utility= 25])

(add-rule [1 ynq-route *
             [yn-question-p^sem=?sem@t-non-null
              route-nps^routes=?routes@t-non-null]
             utility= 20
             produces= (vr-question-route ?sem ?routes)])


;;;
;;; Handling wh-questions
;;;

#||
(lym:trace-lym-rule wh-question-p engine-nps wh-question-engine wh-question-sem wh-question-engine-ref
                    wh-question-be wh-question-be-resolve)
||#
                
(add-rule [1 (wh-question-engine ?eng ?engine)  *
             [engine-nps^engines=?eng@t-non-null
              engine-nps^positions=?pos
              ($if (and (car ?pos)      ; talking about a specific engine somewhere
                        (not (eq (car ?pos) :unknown)))) ; known position
              wh-question-p^utility=?_@t-positive]
             postmatch= ((?engine (vr-find-engine (car ?pos) nil)))])

(add-rule [1 (wh-question-engine-1 ?eng ?engine) wh-question-engine
             [engine-nps^engines=?eng@t-non-null
              engine-nps^positions=?pos
              ($if (every #'null ?pos)) ; not asking about a specific position
              wh-question-p^utility=?_@t-positive]
             postmatch= ((?engine *current-focus*))])

;; where is the Bath engine? (i.e. now)
(add-rule [2 (wh-question-sem ?substituted-semantics ?ref-answer) *
             [wh-question-engine^engine=?engine@t-non-null
              focus^focus=?focus@t-non-null
              semantics^semantics=?semantics]
             postmatch= ((?ref-answer (match-spec ?engine ?focus))
                         (?substituted-semantics (vr-substitute ?ref-answer ?focus ?semantics)))])

;; where are the goals?
(add-rule [2 (wh-question-sem-1 ?substituted-semantics ?ref-answer) wh-question-sem
             [goal-nps^goals=?goals@t-non-null
              wh-question-p^utility=?_@t-positive
              focus^focus=?focus@t-non-null
              semantics^semantics=?semantics]
             postmatch= ((?ref-answer (let ((r (mapcar #'(lambda (g) (vr-goal-p g ?focus)) ?goals)))
                                        (if (endp (cdr r)) (car r) r)))
                         (?substituted-semantics (vr-substitute ?ref-answer ?focus ?semantics)))])

;; where is buffalo
(add-rule [1 wh-question-city *
             [wh-be-p^sub=?sub
              wh-be-p^obj=?obj
              ($if (city-p ?sub))]
             utility= 20
             produces= (vr-show-wh ?sub)])

;; how far/long/etc. is it <path>
(add-rule [1 wh-question-path *
             [wh-be-p^sub=?sub
              wh-be-p^obj=?obj
              wh-be-p^properties=?properties
              ($if (path-quantum-p ?sub))]
             utility= 20
             produces= (vr-prop-of-path ?properties ?sub)])

;; similarly, but pronoun for path
(add-rule [1 wh-question-path-1 wh-question-path
             [wh-be-p^sub=?sub
              wh-be-p^obj=?obj
              wh-be-p^properties=?properties
              ($if (and (vari-p ?obj)
                        (member (vclass ?obj) '(:distance))))] ; add other properties we recognize
             utility= 19
             produces= (vr-prop-of-path ?properties *current-plan*)])

;; how questions

(add-rule [0 how-are-you *
             [^type=sa-how-question
              ^semantics=?sem
              ($if (perf-be-p :you nil ?sem))]
             utility= 20
             produces= (vr-greet t)])

;; reject/correction

(add-rule [2 reject-engine *
             [reject-p^sem=?sem@cons
              preprocess-paths^ppaths=nil
              ($if (and (eq (first ?sem) :instead) ; are we substituting one engine for another?
                        (engine-p (second ?sem))   ; the replacement
                        (engine-p (third ?sem))))] ; yep
             utility= 20
             produces= (redo-extension-new-engine (second ?sem))])

(add-rule [2 no-path-reject *
             [last-reject-p^utility=?_@t-positive
              preprocess-paths^ppaths=nil
              ($if (not (future-focus-shift-p)))] ; don't match if we did "no, use the engine at..."
             utility= 18
             produces=   (execute-ps-strategies `( :reject-solution) *current-plan* nil)])

(add-rule [2 no-path-reject-1 no-path-reject
             [reject-p^utility=?_@t-positive
              preprocess-paths^ppaths=nil]
             utility= 17             
             produces= (set-handling-reject)]) ; really a flag for further incremental processing, needs to be changed.

(add-rule [2 no-path-reject-w-instead no-path-reject
             [reject-p^sem=?sem@cons
              preprocess-paths^ppaths=nil
              ($if (eq (first ?sem) :instead))]
             utility= 19
             produces= (vr-handle-reject-with-instead (second ?sem) (third ?sem))])

;; cancel the route....
(add-rule [2 no-path-reject-w-instead-1 no-path-reject
             [reject-p^sem=?sem@cons
              preprocess-paths^ppaths=nil
              ($if (eq (first ?sem) :instead)
                   (route-p (third ?sem)))] 
             utility= 19
             produces= (progn (set-reject-handled) ; until cancel is handled right.
                              (execute-ps-strategies `( :cancel) *current-plan* (third ?sem)))])

(add-rule [2 reject-w-paths *
             [reject-p^utility=?_@t-positive
              preprocess-paths^ppaths=?paths@t-non-null]
             utility= 18
             produces= (execute-ps-strategies 
                        `( :modify-current-and-stack)
                        *current-plan* ?paths)])

(add-rule [2 reject-w-paths-and-instead reject-w-paths
             [reject-p^sem=?sem@cons
              preprocess-paths^ppaths=?paths@t-non-null
              ($if (eq (first ?sem) :instead))]
             utility= 20
             produces= (vr-handle-reject-with-semantics ?paths ?sem)])

;; not very general, but handle a common case: "No, back to foobar"
(add-rule [2 reject-w-paths-and-back reject-w-paths
             [reject-p^utility=?_@t-positive
              preprocess-paths^ppaths=?paths@t-non-null
              ($if (and (predicates (car ?paths))
                        (eq (name (predicate (car (predicates (car ?paths))))) :back)))] ; one predicate, it's back.
             utility= 20
             produces= (progn (set-reject-handled)
                              (simple-undo))])             ;; some kind of cancel, but barring that
             


#||
(eval-when (load eval)
  (lym:trace-lym-rule no-path-reject default-reject-w-paths reject-engine reject-focus reject-subdialogue reject-p last-reject-p))
||#

;; goal with paths

#||
(lym:trace-lym-rule preprocess-paths id-goal-p id-goal handle-paths handle-paths-deferred-reject)
||#


(add-rule [0 (id-goal-p ?sem ?defs) *
             [^type=sa-id-goal
              ^semantics=?sem
              ^defs=?defs]])

(add-rule [1 id-goal *
             [id-goal-p^utility=?_@t-positive
              reliability^reliability=?rel
              ($if (not (handling-reject-p)))
              ($if (not (eq *current-plan* (root-plan))))
              ($if (and (< ?rel 70)     ; possible mistake
                        (or (error-frame-p)
                            (not (plan-solved-p *current-plan*)))))
              preprocess-paths^ppaths=?paths@t-non-null]
             utility= 20
             produces= (execute-ps-strategies 
                        `( :new-subplan-root-maybe :extend-current  :do-what-you-can) ; should have responded, no?
                        *current-plan* ?paths)])

(add-rule [1 id-goal-1 id-goal
             [id-goal-p^utility=?_@t-positive
              ($if (not (handling-reject-p)))
              ($if (not (eq *current-plan* (root-plan))))
              preprocess-paths^ppaths=?paths@t-non-null]
             utility= 19
             produces= (execute-ps-strategies `( :new-subplan-root :extend-current :do-what-you-can )
                                              *current-plan* ?paths)])

(add-rule [1 id-goal-root id-goal
             [id-goal-p^utility=?_@t-positive
              ($if (not (handling-reject-p)))
              ($if (eq *current-plan* (root-plan)))
              preprocess-paths^ppaths=?paths@t-non-null]
             utility= 20
             produces= (execute-ps-strategies `( :new-subplan-root :do-what-you-can) *current-plan* ?paths)])

;; id-goal w/o path, but hiding in the semantics
;;;#<SA-ID-GOAL Initiator: USER Mode: SPEECH Reliability: 90
;;;                             Focus: :I
;;;                             Objects: (:I
;;;                                       #1=#<CITY BALTIMORE>
;;;                                       #2=#<CITY MILWAUKEE>
;;;                                       #4={ #1# #2#}:CONJ)
;;;                             Syntax: ((:SUBJECT . :I) (:OBJECT))
;;;                             Defs: (#3=#<OPERATOR-PROP
;;;                                         PERF #<PREDICATE-PROP
;;;                                                ARRIVE-AT #3#> #<OPERATOR-PROP
;;;                                                                 AND #<PREDICATE-PROP
;;;                                                                       LSUBJ :I> #<PREDICATE-PROP
;;;                                                                                   LOBJ #4#>>>)
;;;                             Semantics: #5=#<OPERATOR-PROP
;;;                                             PERF #<PREDICATE-PROP
;;;                                                    WANT-NEED #5#> #<OPERATOR-PROP
;;;                                                                     AND #<PREDICATE-PROP
;;;                                                                           LSUBJ :I> #<PREDICATE-PROP
;;;                                                                                       LCOMP #3#>>>
;;;                             Input: (I NEED TO GET TO BALTIMORE AND MILWAUKEE)
;;;                             >
#|| (lym:trace-lym-rule id-goal-no-path) ||#

(add-rule [1 id-goal-no-path *
             [id-goal-p^sem=?sem@t-non-null
              id-goal-p^defs=?defs@t-non-null
              ($if (and (not (handling-reject-p))
                        (perf-prop-p :arrive-at (car ?defs))))]
             utility= 20
             produces= (execute-ps-strategies `( :new-subplan-root :do-what-you-can) 
                                              *current-plan*
                                              (list (make-path-quantum :engine (if (focus-changed-p)
                                                                                   *current-focus*) ; pick up new engine
                                                                       :to (rperf-prop-p :lobj (car ?defs)))))])


;; general objects with paths, should have lower utility than other specialized cases.
(add-rule [2 handle-paths-deferred-reject *
             [preprocess-paths^ppaths=?paths@t-non-null
              ($if (and (handling-reject-p) ; obsolete, right?
                        (not (reject-handled-p))))]
             utility= 15
             produces= (progn
                         (set-reject-handled)
                         (execute-ps-strategies `( :modify-current #|| :modify-backup ||# :modify-stack :do-what-you-can) *current-plan* ?paths))])

(add-rule [2 handle-paths *
             [preprocess-paths^ppaths=?paths@t-non-null
              reliability^reliability=?rel
              ($if (and (< ?rel 70)     ; possible mistake
                        (or (error-frame-p)
                            (and (not (eql *current-plan* (root-plan)))
                                 (not (plan-solved-p *current-plan*))))))]
             utility= 14
             produces= (execute-ps-strategies `( ,(if (or (to (car ?paths))
                                                          (from (car ?paths)))
                                                      :refine-extend-current-using-status
                                                    :refine-extend-current)
                                                   :refine-extend-stack 
                                                   :do-what-you-can
                                                 :new-subplan-root-maybe
                                                 )
                                              *current-plan*
                                              ?paths)])

(add-rule [2 handle-paths-1 handle-paths
             [preprocess-paths^ppaths=?paths@t-non-null]
             utility= 13
             produces= (execute-ps-strategies `( ,(if (or (to (car ?paths))
                                                          (from (car ?paths)))
                                                      :refine-extend-current-using-status
                                                    :refine-extend-current)
                                                   :refine-extend-stack 
                                                   :do-what-you-can
                                                 :new-subplan-root
                                                 )
                                              *current-plan*
                                              ?paths)])

(add-rule [2 handle-paths-2 handle-paths
             [preprocess-paths^ppaths=?paths@t-non-null
              ($if (and (eql *current-plan* (root-plan))
                        (not (from (car ?paths)))
                        (not (handling-reject-p))))]
             ;; treat like an id-goal
             utility= 22
             produces= (execute-ps-strategies `( :new-subplan-root :do-what-you-can) *current-plan* ?paths)])

;; send an engine
(add-rule [0 send-engine *
             [^type=sa-request
              ^paths=nil
              ^semantics=?sem@t-non-null
              ^reliability=?rel
              ($if (and (or (perf-prop-p :move ?sem)
                            (perf-prop-p :use ?sem))
                        (engine-p (rperf-prop-p :lobj ?sem))))]
             utility= 20
             produces= (execute-ps-strategies `( :refine-extend-current-using-status
                                                 :refine-extend-stack 
                                                 :do-what-you-can
                                                 ,(if (and (< ?rel 70) ; possible error
                                                           (or (error-frame-p)
                                                               (not (plan-solved-p *current-plan*))))
                                                      :new-subplan-root-maybe
                                                    :new-subplan-root) )
                                              *current-plan*
                                              (list (create-engine-q-from-sem ?sem)))])

;; handle avoid as not-via
(add-rule [0 avoid-city *
             [^semantics=?sem@t-non-null
              ($if (perf-prop-p :avoid ?sem)
                   (city-p (rperf-prop-p :lobj ?sem)))]
             utility= 19
             produces= (progn (set-reject-handled) ; e.g. no, avoid avon.
                              (execute-ps-strategies 
                               '( :modify-current :refine-current :modify-stack :do-what-you-can)
                               *current-plan*
                               (make-path-quantum :not-via (rperf-prop-p :lobj ?sem))))])

;;; probably should be made into multi-level rules.

;; naked city, in response to an error (e.g. I need a suggestion of an intermediate destination)
;; 8/6/96, handle engine too

#||
(lym:trace-lym-rule naked-objects)
||#

(add-rule [0 naked-objects *
             [^type=speech-act
              ^paths=nil
              ^semantics=?sem@t-non-null
              ($if (and (valid-replan-object-p ?sem)
                        (error-frame-p)))]
             utility= 20
             ;; fill the missing slots in with the mentioned objects.
             produces= (replan-route ?sem)])

(add-rule [0 naked-objects-1 naked-objects
             [^type=speech-act
              ^paths=?paths@t-non-null
              ^mode=?mode
              ^semantics=?sem@t-non-null
              ($if (and (eq ?sem (car ?paths))
                        (not (eq ?mode :mouse)) ; if we got a path from a mouse move, it's a drag, so don't replan.
                        (error-frame-p)))] ; may be addressing the error with a fragment
             utility= 19
             produces= (progn (if (and (focus-changed-p)
                                       (null (engine (car ?paths))))
                                  (setf (engine (car ?paths)) *current-focus*)) ; know the agent from prior tell
                              (replan-route ?sem))])

(add-rule [0 naked-objects-1a naked-objects
             [^type=speech-act
              ^paths=?paths@t-non-null
              ^mode=?mode
              ^semantics=?sem@t-non-null
              ($if (and (eq ?sem (car ?paths))
                        (not (eq ?mode :mouse)) ; if we got a path from a mouse move, it's a drag, so don't replan.
                        (question-frame-p)))] ; may be readdressing the question with a replacement
             utility= 20
             produces= (vr-huh nil :question-elipsis-too-hard *current-plan*)])

;; That's chicago (that be chicago)
(add-rule [0 naked-objects-2 naked-objects
             [^type=speech-act
              ^paths=nil
              ^semantics=?sem@t-non-null
              ($if (mlet (success sub ob)
                       (perf-be-p nil nil ?sem) ; be sentence
                     (and success
                          (valid-replan-object-p ob) ; lobj is either a city or a collection of them
                          (error-frame-p))))] ; we are addressing a problem
             utility= 20
             produces= (mlet (success sub ob)
                           (perf-be-p nil nil ?sem)
                         (replan-route ob))]) ; replan the route based on the response

;; try chicago
(add-rule [0 naked-objects-3 naked-objects
             [^type=sa-request
              ^paths=nil
              ^semantics=?sem@t-non-null
              ($if (let (lcomp)
                     (and (perf-prop-p :use ?sem)
                          (setq lcomp (rcheck-prop-p :lobj (cadr (propositions ?sem))))
                          (valid-replan-object-p lcomp) ; lobj is either a city or a collection of them
                          (error-frame-p))))] ; we are addressing a problem
             utility= 20
             produces= (replan-route (rcheck-prop-p :lobj (cadr (propositions ?sem))))])
                                        ; replan the route based on the response

;; go to chicago / also raleigh
(add-rule [0 naked-objects-4 naked-objects
             [^type=speech-act
              ^paths=nil
              ^semantics=?sem@t-non-null
              ($if (city-p ?sem))]
             utility= 18                ; compare to naked-objects rule - not in an error frame
             ;; what I want to do here is check the interp of the last utterance. Since I don't yet record that 
             ;; (and it's too big a change right now, 8/21/96), assume it's a goal.
             produces= (execute-ps-strategies 
                        `( :new-subplan-root :do-what-you-can) 
                        *current-plan*
                        (make-path-quantum :use ?sem))]) ; figuring out the real slot would be hard, .
;; DOMAIN ACTIONS

;; where are the engines?
(add-rule [2 (wh-question-sem-2 ?substituted-semantics ?ref-answer) wh-question-sem
             [wh-question-engine^eng=?eng@t-non-null
              ($if (endp (cdr ?eng)))
              focus^focus=?focus@t-non-null
              semantics^semantics=?semantics]
             postmatch= ((?ref-answer (match-spec (car ?eng) ?focus))
                         (?substituted-semantics (vr-substitute ?ref-answer ?focus ?semantics)))])

(add-rule [3 wh-question-engine-ref *
             [wh-question-engine^engine=?engine@t-non-null ; engine focus
              wh-question-sem^substituted-semantics=?sem
              wh-question-sem^ref-answer=?ref-answer@t-non-null]
             utility= 20
             produces= (vr-question-answer ?engine ?sem)])

(add-rule [3 wh-question-engine-ref-1 wh-question-engine-ref
             [focus^focus=?focus@t-non-null ; engine focus, wh-question-engine probably didn't match
              wh-question-sem^substituted-semantics=?sem
              wh-question-sem^ref-answer=?ref-answer@t-non-null]
             utility= 19
             produces= (vr-question-answer ?focus ?sem)])

(add-rule [3 wh-question-engine-ref-2 wh-question-engine-ref
             [focus^focus=?focus@t-non-null ; engine focus, wh-question-engine probably didn't match
              wh-question-sem^ref-answer=null]
             utility= 15
             produces= (vr-huh ?focus :unknown *current-plan*)])

(add-rule [3 wh-question-engine-ref-3 wh-question-engine-ref
             [wh-question-engine^engine=?engine@t-non-null ; engine focus
              wh-question-sem^ref-answer=null]
             utility= 15
             produces= (vr-huh ?engine :unknown *current-plan*)])

(add-rule [3 wh-question-unknown *
             [wh-question-engine^engine=?eng]
             utility= 15
             produces= (vr-huh ?eng :unknown *current-plan*)])

(add-rule [2 (wh-question-be ?object ?resolution ?substituted-semantics) *
             [semantics^semantics=?semantics@t-non-null
              wh-question-p^utility=?_@t-positive
              focus^focus=?focus@t-non-null]
             postmatch= ((?object (get-object-for-what ?semantics))
                         (?resolution (if ?object (vr-resolve-object ?object)))
                         (?substituted-semantics (if ?object (vr-substitute ?resolution ?focus ?semantics))))
             utility= (if ?object 15 0)])

(add-rule [3 wh-question-be-resolve *
             [wh-question-be^object=?object@t-non-null
              wh-question-be^resolution=?res@t-non-null
              wh-question-be^substituted-semantics=?sem]
             utility= 20
             produces= (vr-question-answer ?object ?sem)])

(add-rule [3 wh-question-be-resolve-1 wh-question-be-resolve
             [wh-question-be^object=?object@t-non-null
              wh-question-be^resolution=nil]
             utility= 20
             produces= (vr-huh ?object :unknown *current-plan*)])



