
/*
  history file looks like:
 
step(1)
add(now(1))  2  []
add(p(X1) ---> q(X1))  1  []
add(p(a))  0  []
End of Step----------------------------------

step(2)
add(now(2))  4  []
add(q(a))  3  [[1,0]]
delete(now(1))  2  []
End of Step----------------------------------

  adds are: add(FORM) FORMNUMBER DERIV
  deletes are: delete(FORM) FORMNUMBER ??

  DERIV is a list of lists of FORMNUMBER
  step is: step(STEPNUMBER)
  endofstep: End of Step----...

*/




import java.util.*;
import java.applet.*;
import java.awt.*;
import java.awt.event.*;
import java.io.*;
import java.net.*;
import pparser.*;

/** 
 * This class keeps track of the contents of the database and its history.
 * <br>
 * If the GUI is supposed to connect to a running alma process, we start
 * a server for the alma history output to connect to. Otherwise we get
 * connect to the URL of the history file.
 * <br>
 * The sockets or the history file are read through an input buffer. As long
 * as there is information in the buffer, we parse it according to the 
 * syntax of the history output.
 * <br>
 * This information is then used to build the view of the KB as time proceeds.
 * <br>
 * See elsewhere for a description of the GUI panel generated by this class.
 * @author K. Purang
 * @version October 2000
 */


public class Db extends Thread{

    ServerSocket server;	// server for the alma history 
    Socket thesocket;		// the actual ports
    String infofile = "htcp";	// name of the history socket file
				//   this is needed by alma
    Vector theDb;		// contrains the formulas
    Hashtable name2Index;	// maps formula name to vector index
    int maxNames = -1;		// the latest index used in the vector
    int maxCaret = 0;		// the last positino in the gui
    int offset = 0;		// offset between fromname and 0

    boolean synchronize;	// does the display keep up with alma?

    InputStream socketInStream;	// various streams related to the socekt
    OutputStream socketOutStream;
    BufferedReader socketBReader;
    BufferedWriter socketBWriter;

    ScrollPane hDisplay;		// the text area inthe gui for this
    TextField hDisplayedStep;	// the goto field
    int displayedStep = 0;
    int previousDisplayedStep = 0;

    int INITIALCAPACITY = 1000;	// initial size of theDb
    int HISTORYHEIGHT = 350;
    int HISTORYWIDTH = 500;

    int currentStep = 0;	// need to do something with this

    String historyInputURLName;
    boolean historyFromFile;

    Label kbLabel;
    Button startHistoryButton;
    Button prevHistoryButton;
    Button gotoHistory;
    TextField gotoTextField;
    Button endHistoryButton;
    Button nextHistoryButton;
    public ScrollPane historyWin;	// history
    Panel historyPanel;
    Panel historyContentsPanel;
    Label fileNameLabel;
    TextField fileNameReader;
    Button fileNameButton;
    Panel fileNamePanel;

    public BRWrapper hBRW;

    
    //**************************************************
    /**
     * The constructor needs to know whether we are to read the history from 
     * a file, and if it is available, the name of the file.
     */

    public Db(boolean FromFile, String fName){
	theDb = new Vector(INITIALCAPACITY);
	theDb.setSize(INITIALCAPACITY);
	name2Index = new Hashtable(INITIALCAPACITY);
	synchronize = true;

	historyFromFile = FromFile;

	historyPanel = new Panel(new GridBagLayout());
	historyPanel.setBackground(ColorsFonts.historyPanelBackground);
	makeHistoryPanel();
	hDisplay = historyWin;
	hDisplayedStep = gotoTextField;

	hBRW = new BRWrapper();

	if(!FromFile){
	    // setting up sockets
	    try {
		server = new ServerSocket(0);
		
		// write the info required by prolog to connect

		BufferedWriter ostream = 
		    new BufferedWriter(new OutputStreamWriter
				       (new FileOutputStream(infofile)));
		ostream.write("port " + server.getLocalPort() + "\n");
		ostream.write("host " + InetAddress.getLocalHost().getHostName()
			      + "\n");
		ostream.write("process " + server.getLocalPort() + "\n");
		ostream.flush();
		ostream.close();
	    }	
	catch (IOException e) {
	    Globals.theGui.showStatus("Cannot create server" + e);
	    System.err.println("Cannot create server" + e);
	}
	if(Globals.verbose)
	    System.out.println("History server up");
	} // if !fromFile
	else{			// if from file
	    historyInputURLName = fName;
	    if(Globals.verbose)
		System.out.println("Not getting sockets");
	    if(fName != null){
		//		FilePermission fp = new FilePermission("/fs/disco/kpurang/work/Alma/examples/applets/tweet.history", "read");
		InputStream historyInputStream = null;
		try{
		    URL inputURL = new URL(fName);
		    // PROBLEM: the java in netscape does not seem to
		    // recognize this class.
		    /*
		    SocketPermission perm1 = new 
			SocketPermission("*.cs.umd.edu", "connect, accept");
		    historyInputStream = inputURL.openStream();
		    socketBReader = new BufferedReader(new 
						       InputStreamReader
						       (historyInputStream));
		    */
		    
		    // try new approach
		    // but is supposed ot be same as above
		    URLConnection inputConnection =  inputURL.openConnection();
		    inputConnection.setDoInput(true);
		    inputConnection.connect();
		    //		    setupParms();
		    inputConnection.connect();
		    
		    historyInputStream = inputConnection.getInputStream();
		    socketBReader = new BufferedReader(new 
						       InputStreamReader
						       (historyInputStream));

		}catch(Exception gUB){
		    Globals.theGui.showStatus("Error getting URL " + gUB);
		    System.err.println("Error getting URL " + gUB);
		    socketBReader = null;
		}
	    } // fname != null
	    else socketBReader = null;	    
	} // else

    } // constructor


    //**************************************************

    public Panel getHistoryPanel(){
	return historyPanel;
    }



    //**************************************************
    /**
     * This method repeatedly tries to parse input according to the
     * history syntax.
     *<br>
     * If we are reading from a file and we reach the end of the file, 
     * we wait for a new file to be loaded. In the case of a running alma,
     * we wait for more history information to be available on the sockets.
     */

    public void run(){

	// might want to allow reconnections later.

	if(!historyFromFile){
	try{
	    thesocket = server.accept();
	    socketInStream = thesocket.getInputStream();
	    socketOutStream = thesocket.getOutputStream();
	}catch(Exception e){
	    Globals.theGui.showStatus("Cannot accept connection" + e);
	    System.out.println("Cannot accept connection" + e);
	}
	
	if(Globals.verbose)
	    System.out.println("History connected");

	socketBReader = new BufferedReader(new 
					   InputStreamReader
					   (socketInStream));
	socketBWriter = new BufferedWriter(new 
					   OutputStreamWriter
					   (socketOutStream));
	}
	else{
	    // can also read the file from the kbd. better i think
	    // arg is then just t or f.
	    // for now allow both
	    if(Globals.verbose)
		System.out.println("Run: not connected");
	}
	
	// forever read socket, parse, update datastrucutres
	
	String lineRead;
	int openPar, closePar;
	int openSq, closeSq;
	String formula;
	String formName;
	String parents;
	lineRead = "Boo";
	int firstChange = 0;	// location of first cahngein vector
	int vectorIndex;


	// read the first line
	if(Globals.verbose)
	    System.out.println("Going to read first line");

	try{
	    lineRead = socketBReader.readLine();
	}catch(Exception e1){
	    Globals.theGui.showStatus("Cannot read line from socket" + e1);
	    System.err.println("Cannot read line from socket" + e1);
	}
	if(lineRead == null){
	    // we have an EOF 
	    if(Globals.verbose)
		System.out.println("Read a null. nulling socket.");
	    socketBReader = null;
	    // need to close the URL conenction too. dunno how.
	}
	else
	    if(Globals.verbose)
		System.out.println("Read: " + lineRead);
	
	
	//__________________________________________________

	ParseMe lineToParse;
	Term inputTerm;

	while(true){

	    // need to do this only if we are in the URL mode.
	    synchronized(hBRW){
		while(socketBReader == null){
		    if(Globals.verbose)
			System.err.println("Run: waiting for URL");
		    try{
			hBRW.wait();}catch(Exception wE1){
			    Globals.theGui.showStatus("Error waiting for URL stream" + wE1);
			    System.err.println("Error waiting for URL stream" + wE1);
			}
		}
	    }
	    if(Globals.verbose)
		System.out.println("Db.run: Out of wait");

	    if(!isBlankLine(lineRead)){
	    lineToParse = new ParseMe(lineRead);	    
	    inputTerm = Term.parseTerm(lineToParse);
	    if((inputTerm.getClass().getName().endsWith("Cterm"))){
				// is step(_) add(_, _), delete(_, _)

		if(Globals.verbose)System.out.println("Got a Cterm");

		if(((((Cterm)inputTerm).getPred()).toString()).compareTo("step") == 0){
				// is step
		    if(Globals.verbose)System.out.println("Got a step");
		    try{
			currentStep = Integer.parseInt((((Cterm)inputTerm).getArg(0)).
						       toString());
		    }catch(Exception intexception1){
			Globals.theGui.showStatus("Not an int" + intexception1);
			System.err.println("Not an int" + intexception1);
		    }
		    if(Globals.verbose)
			System.out.println("Step: " + currentStep);
		} // if is step
		else{		    // is add or delete
		    if(Globals.verbose)System.out.println("Is add or delete");
		    if(((((Cterm)inputTerm).getPred()).toString()).
		       compareTo("add") == 0){	// is add
			if(Globals.verbose)System.out.println("Is add");
			formula = (((Cterm)inputTerm).getArg(0)).toString();
			if(Globals.verbose)
			    System.out.println("Formula: " + formula);
			formName = ((((Cterm)((Cterm)inputTerm).
				      getArg(1))).getArg(0)).toString();
			if(Globals.verbose)
			    System.out.println("Name: " + formName);
			vectorIndex = maxNames + 1;
			name2Index.put(formName, new Integer(vectorIndex));
			maxNames = vectorIndex;
		
			// get a new formula and insert into Db.
			Formula tempForm = new Formula(formula, formName, 
						       ((Cterm)inputTerm).getArg(1));
			tempForm.setTimeAdded(currentStep);
			addToDb(tempForm);
			if(firstChange > maxNames) firstChange = maxNames;
			if(Globals.verbose)
			    System.out.println("First change: " + firstChange);
			
		    } // add
		    else{		// delete

			if(Globals.verbose)System.out.println("Is delete");
			formName =  ((((Cterm)((Cterm)inputTerm).
				       getArg(1))).getArg(0)).toString();
			if(Globals.verbose)
			    System.out.println("Formula: " + formName);
			vectorIndex = ((Integer)name2Index.get(formName)).
			    intValue();
			removeFromDb(vectorIndex);
			if(Globals.verbose)
			    System.out.println("Delete change " + formName + 
					       ": " + vectorIndex);
		if(firstChange > vectorIndex) firstChange = vectorIndex;
			
		    } // else delete
		    
		} // else is add or delete
		
	    } // else is not step

	    else{
				// is end
		if(Globals.verbose){
		    System.out.println("displayedStep: " + displayedStep);
		    System.out.println("curentStep: " + currentStep);
		}
		if((currentStep - previousDisplayedStep) > 1)
		    firstChange = getFirstChange(displayedStep, currentStep);
		if(Globals.verbose)
		    System.out.println("First change: " + firstChange);
		
		if(synchronize){
		    maxCaret = updateWindow(firstChange, currentStep);
		    displayedStep = currentStep;
		    firstChange = maxNames;	
		} // if synchronize
	    } // else is end

	    //__________________________________________________

	    } // if lineRead != blankline


	    // read the next line in

	    try{
		lineRead = socketBReader.readLine();
	    }catch(Exception e1){
		Globals.theGui.showStatus("Cannot read line from socket" + e1);
		System.err.println("Cannot read line from socket" + e1);
	    }
	    if(lineRead == null){
		socketBReader = null;
		// need to close the URL conenction too
	    }
	    else
		if(Globals.verbose)
		    System.out.println("Read: " + lineRead);
	    

	} // while true
	
    } // run

    //**************************************************
    
    public void addToDb(Formula form){
	int dbCapacity = theDb.capacity();
	String formName = form.getName();
	int formIndex = ((Integer) name2Index.get(formName)).intValue();

	if(dbCapacity <= formIndex){
	    theDb.ensureCapacity(formIndex + INITIALCAPACITY);
	    theDb.setSize(theDb.capacity());
	}
	theDb.setElementAt(form, formIndex);
    } // addToDb

    //**************************************************

    public void removeFromDb(int formIndex){
	Formula form = (Formula) theDb.elementAt(formIndex);
	form.delete();
	form.setTimeDeleted(currentStep);
    }

    //**************************************************

    public void dumpDb(){
	// try something simple first 
	//	theDb.toString();
	int count = 0;
	Formula toprint;
	for(count = 0; count <= maxNames; count++){
	    if((toprint = (Formula) theDb.elementAt(count)) != null){
		if(!toprint.deleted())System.out.println(toprint.toString());
	    }
	}

    } //dumpDb

    //**************************************************

    /**
     * This method is used to clear our record of the formulas in the Db.
     * This correponds to the reset_alma command.
     */

    public void resetDb(){
	maxNames = -1;
	name2Index.clear();
	hDisplay.removeAll();

    } // resetDb


    //**************************************************

    /**
     * After a new step has been read, this updates the window.
     * We update the minimum possible instead of redrawing the wholw
     * window at each step.
     * firstChange is the firstChange in the vector
     */

    public int updateWindow(int firstChange, int stepToDisplay){

	previousDisplayedStep = displayedStep;
	displayedStep = stepToDisplay; 

	Formula currentForm = null;
	int formulaToUpdate = 0;
	if(firstChange > 0) formulaToUpdate = firstChange - 1;

	while(formulaToUpdate <= maxNames){
	    currentForm = (Formula) theDb.elementAt(formulaToUpdate);
	    if(currentForm != null){
		//		System.out.println("Considering " + currentForm.theFormula);
		// this condition should be in a function for the formula
		// that returns true if this formula is present in the
		// given step
		if(currentForm.getTimeAdded() <= stepToDisplay &&
		   ((!currentForm.deleted()) ||
		    currentForm.getTimeDeleted() > stepToDisplay)){
		    // Display the formula
		    if(!currentForm.isDisplayed()){
			currentForm.displayed = true;
			// System.out.println("Adding " + currentForm.theFormula);
			GridBagConstraints lbCon = new GridBagConstraints();
			//			lbCon.anchor = GridBagConstraints.WEST;
			lbCon.anchor = GridBagConstraints.NORTHWEST;
			//			lbCon.weightx = 1.0;
			//			lbCon.weighty = 1.0;
			lbCon.gridx = 0;
			lbCon.ipadx = lbCon.ipadx = 0;
			// lbCon.insets = 0;
			lbCon.gridy = GridBagConstraints.RELATIVE;
			historyContentsPanel.add(currentForm.theLabel,
						 lbCon);
		    }//#####
		}
		else{
		    // Delete the formula
		    // need to verigy that the thing is displayed.
		    // System.out.println("Deleting " + currentForm.theFormula);
		    if(currentForm.isDisplayed()){
			historyContentsPanel.remove(currentForm.theLabel);
			currentForm.displayed = false;
		    }
		}
	    } // current form != null
	    formulaToUpdate++;
	}
	historyContentsPanel.validate();
	historyWin.setScrollPosition(0, 10000);
	historyWin.validate();
	displayStepNumber();

	// need to refresh the window
	

	return 0;

    } // updateWindow


    //**************************************************
    // return the first index in the vecotr where there is a difference
    // between the two steps.

    /**
     * Given the current step displayed and the desired step, this finds the
     * first place the two steps differ.
     * This is used to know which parts of the window do not need updating.
     */

    public int getFirstChange(int initialStep, int newStep){
	int count = 0;
	boolean first, second;
	Formula theFormula;
	if(Globals.verbose)
	    System.out.println("In getFirstChange maxNames: " + maxNames);

	while(count <= maxNames){
	    theFormula = (Formula)theDb.elementAt(count);
	    if(theFormula == null) break;
	    first = theFormula.isAlive(initialStep);
	    second = theFormula.isAlive(newStep);
	    if(!((first && second) || ((!first) && (!second)))) break;
	    count++;
	} // count <= maxNames
	return count;
    } // getFoirstChange

    //**************************************************
    public void synchronizeWindow(){
	synchronize = true;
    }
    //**************************************************
    public void unsynchronizeWindow(){
	synchronize = false;
    }
    //**************************************************
    public int getDisplayedStep(){
	return displayedStep;
    }
    //**************************************************
    public void displayStepNumber(){
	hDisplayedStep.setText(Integer.toString(displayedStep));

    }

    //**************************************************

    /**
     * This makes the display for the DB and the history.
     * <br>
     * The formulas are displayed as:
     * <br>
     * &lt FORMULA NAME &gt : &lt PRINTABLE FORMULA &gt
     * <br>
     * The formula name is a string that can be used to identify the formula
     * in other literals. The printable formula is an intuitive rendering
     * of the formula though it may not correspond exactly to the formula
     * entered.
     * <br>
     * The control panel is:
     * <img src="dbcontrol.gif">
     * <br>
     * <ul>
     * <li>
     * The first button dispalys the first step in the history.
     * <li>
     * The second button moves back one step in the history.
     * <li>
     * The third button, causes the step in the text field to be displayed.
     * <li>
     * The text field serves to display the step number of the step that is
     * being displayed. It is editable and can also be used to specify a 
     * particular step to display.
     * The fourth button causes the next step to be displayed. If there are no
     * more steps, this will not cause new steps to be computed.
     * <li>
     * The fifth button causes the last step to be displayed. This serves
     * another purpose which is to synchronize the display with the input
     * steps. 
     * </ul>
     * In usual operation, with alma computing steps instead of reading
     * from a file, the latest available step is displayed. However,
     * if any one of the buttons but the last is used, the display is no
     * longer synchronized with the steps that are being computed by alma.
     * This allows one to inspect previous steps without always jumping to 
     * the latest step. 
     * <br>
     * The last button resynchronizes the display with the running alma so
     * that the latest computed step is displayed.
     * <br>
     * In history file mode, an additional panel is displayed:
     * <br>
     * <img src="urlload.gif">
     * <br>
     * This allows one to load new history files. Loading a new file causes
     * the previous information to be lost.
     */

    public void makeHistoryPanel(){

	//__________________________________________________
	// here we add the control for history.
	// |<, <<, GOTO [ ], >>, >|
	// this is not working out. maybe put this into a panel
	// then place the panel
	// try to put everything in the history panel

	

	//__________________________________________________
	// label for history
	
	kbLabel = new Label("KB contents");
	GridBagConstraints kbCon = new GridBagConstraints();
	kbCon.gridx = 0;
	kbCon.gridy = 0;
	
	historyPanel.add(kbLabel, kbCon);


	//__________________________________________________
	// text area for history

	/* 03/27/01
	  put in a scroll pane
	  add a panel
	  set the panel layout
	  panel must be global

	 */

        historyWin = new ScrollPane();
	historyWin.setSize(HISTORYHEIGHT, HISTORYWIDTH);
	historyWin.setBackground(ColorsFonts.historyPanelBackground);
	//	historyWin.setLayout(new GridBagLayout());
	historyContentsPanel = new Panel(new GridBagLayout());
	historyWin.add(historyContentsPanel);

        GridBagConstraints hWinCon = new GridBagConstraints();
	//        hWinCon.gridy = menuBarCon.gridy + 1;
        hWinCon.gridy = kbCon.gridy + 1;
        hWinCon.gridx = 0;
        hWinCon.weightx = 1.0;
        hWinCon.weighty = 1.0;
        hWinCon.gridwidth = GridBagConstraints.REMAINDER;
        hWinCon.fill = GridBagConstraints.HORIZONTAL;

        historyPanel.add(historyWin, hWinCon);

	//__________________________________________________
	// label for history control

	Panel controlPanel = new Panel(new GridBagLayout());
	controlPanel.setBackground(ColorsFonts.historyPanelBackground);


	//__________________________________________________
	// |<

        startHistoryButton = new Button("|<");
        startHistoryButton.addActionListener(new ActionListener(){
            public void actionPerformed(ActionEvent shbe){
		synchronize = false;
		updateWindow(getFirstChange(displayedStep,
							1), 1);
		displayStepNumber();
            }
        }
					     );
        GridBagConstraints sHBCon = new GridBagConstraints();
	sHBCon.gridy = 0;
        sHBCon.gridx = 0;

        controlPanel.add(startHistoryButton, sHBCon);

	//__________________________________________________
	// <<

        prevHistoryButton = new Button("<<");
        prevHistoryButton.addActionListener(new ActionListener(){
            public void actionPerformed(ActionEvent phbe){
		if(currentStep == 1) return;
		synchronize = false;
		updateWindow(getFirstChange
			     (displayedStep,
			      displayedStep - 1), 
			     displayedStep - 1 );
		displayStepNumber();
            }
        }
					    );
        GridBagConstraints pHBCon = new GridBagConstraints();
        pHBCon.gridy = sHBCon.gridy;
	pHBCon.gridx = GridBagConstraints.RELATIVE;

        controlPanel.add(prevHistoryButton, pHBCon);

	//__________________________________________________
	// the goto button

        gotoHistory = new Button("Goto step: ");
        gotoHistory.addActionListener(new ActionListener(){
            public void actionPerformed(ActionEvent ghbe){
		String gs = gotoTextField.getText();
		int gotoStep= -1;
		synchronize = false;
		try{
		    gotoStep = Integer.
			parseInt(gs.trim(), 10);
		}catch(Exception ie1){
		    Globals.theGui.showStatus("Not an int" + ie1);
		    System.err.println("Not an int" + ie1);
		}
		if(gotoStep > 0){
		    updateWindow(getFirstChange
				       (displayedStep, gotoStep),
				       gotoStep);
		    displayStepNumber();
		} // if goto > 0
            }
        }
				      );

	GridBagConstraints ghCon = new GridBagConstraints();
	ghCon.gridx = GridBagConstraints.RELATIVE;
	ghCon.gridy = sHBCon.gridy;
	controlPanel.add(gotoHistory, ghCon);

	//__________________________________________________
	// textfield to get step

        gotoTextField = new TextField(5);
	gotoTextField.setBackground(ColorsFonts.gotoTextBackground);
	gotoTextField.setFont(ColorsFonts.gotoTextFont);
        GridBagConstraints gTFCon = new GridBagConstraints();
        gTFCon.gridy = pHBCon.gridy;
        gTFCon.gridx = GridBagConstraints.RELATIVE;

        controlPanel.add(gotoTextField, gTFCon);

	//__________________________________________________
	// <<


        nextHistoryButton = new Button(">>");
        nextHistoryButton.addActionListener(new ActionListener(){
            public void actionPerformed(ActionEvent nhbe){
		synchronize = false;
		updateWindow(getFirstChange(displayedStep,
					    displayedStep + 1), displayedStep + 1 );
		displayStepNumber();
            }
        }
					    );
        GridBagConstraints nHBCon = new GridBagConstraints();
        nHBCon.gridy = sHBCon.gridy;
	//        nHBCon.gridx = ghCon.gridx + 1;
        nHBCon.gridx =  GridBagConstraints.RELATIVE;
	//        nHBCon.anchor = GridBagConstraints.WEST;

        controlPanel.add(nextHistoryButton, nHBCon);

	//__________________________________________________
	// <<

        endHistoryButton = new Button(">|");
        endHistoryButton.addActionListener(new ActionListener(){
            public void actionPerformed(ActionEvent ehbe){
		synchronize = true;
		updateWindow(getFirstChange(displayedStep,
							currentStep), currentStep );
		displayStepNumber();
            }
        }
					   );
        GridBagConstraints eHBCon = new GridBagConstraints();
        eHBCon.gridy = sHBCon.gridy;
	//        eHBCon.gridx = nHBCon.gridx + 1;
	eHBCon.gridx = GridBagConstraints.RELATIVE;
        eHBCon.anchor = GridBagConstraints.WEST;


        controlPanel.add(endHistoryButton, eHBCon);

	//__________________________________________________
	// add the panel

        GridBagConstraints cpCon = new GridBagConstraints();	
	cpCon.gridy = GridBagConstraints.RELATIVE;
	cpCon.gridx = 0;
	cpCon.fill = GridBagConstraints.HORIZONTAL;
	historyPanel.add(controlPanel, cpCon);

	//__________________________________________________
	// here we have the file reader. do this only if FromFIle

	if(historyFromFile){
	    if(Globals.verbose)
		System.out.println("Making file reading panel");

	    fileNamePanel = new Panel(new GridBagLayout());
	    //__________________________________________________

	    fileNameLabel = new Label("URL:");
	    GridBagConstraints fNCon = new GridBagConstraints();
	    fNCon.gridx = 0;
	    fNCon.gridy = 0;
	    
	    fileNamePanel.add(fileNameLabel, fNCon);
	    
	    //__________________________________________________
	
	    fileNameReader = new TextField(40);
	    GridBagConstraints fNRCon = new GridBagConstraints();
	    fNRCon.gridy = 0;
	    fNRCon.gridx =  GridBagConstraints.RELATIVE;

	    fileNamePanel.add(fileNameReader, fNRCon);
	    //__________________________________________________

	    fileNameButton = new Button("Load");
	    fileNameButton.addActionListener(new ActionListener(){
            public void actionPerformed(ActionEvent fnbe){
		// assume the name is a url
		String fileNameInput = fileNameReader.getText();
		if(fileNameInput != null){
		    InputStream historyInputStream = null;
		    try{
		    URL inputURL = new URL(fileNameInput);
		    historyInputStream = inputURL.openStream();
		    }catch(Exception gUB){
			Globals.theGui.showStatus("Getting URL" + gUB);
			System.err.println("Getting URL" + gUB);
		    }
		    // now what???
		    // reset the db
		    resetDb();
		    synchronized(hBRW){
			socketBReader = new BufferedReader(new 
							   InputStreamReader
							   (historyInputStream));
		    hBRW.notify();
		    }
		} // fileNameInput != null
            }
	    }
					     );
	    GridBagConstraints fNBCon = new GridBagConstraints();
	    fNBCon.gridy = 0;
	    fNBCon.gridx =  GridBagConstraints.RELATIVE;

	    fileNamePanel.add(fileNameButton, fNBCon);
	    //__________________________________________________
	    
	    GridBagConstraints fNPCon = new GridBagConstraints();	
	    fNPCon.gridy = GridBagConstraints.RELATIVE;
	    fNPCon.gridx = 0;
	    fNPCon.fill = GridBagConstraints.HORIZONTAL;
	    historyPanel.add(fileNamePanel, fNPCon);


	} // if fromfile


    }

    public boolean isBlankLine(String s){
	if(s.length() == 0 || (s.trim()).length() == 0) return true;
	return false;
    }



} // db


//**************************************************
//**************************************************
//**************************************************

class BRWrapper{
    public BufferedReader theBR;
    BRWrapper(){
	theBR = null;
    }
}




	    /***************************************************
	    if(lineRead.startsWith("step")){
		openPar = 4;
		closePar = lineRead.lastIndexOf(")");
		try{
		    currentStep = Integer.
			parseInt(lineRead.substring
				 (openPar + 1, closePar).trim(), 10);
		}catch(Exception ie1){
		    Globals.theGui.showStatus("Not an int" + ie1);
		    System.err.println("Not an int" + ie1);
		}
		if(Globals.verbose)
		    System.out.println("Step: " + currentStep);
	    } // step

	    //__________________________________________________
	    if(lineRead.startsWith("add")){
		openPar = 3;
		closePar = lineRead.lastIndexOf(")");
		formula = lineRead.substring(openPar + 1, closePar);
		String tS1 = lineRead.substring(closePar + 1);		
		openSq = tS1.indexOf("[");
		formName = tS1.substring(0,openSq).trim();
		closeSq = tS1.lastIndexOf("]");
		parents = tS1.substring(openSq, closeSq);
		vectorIndex = maxNames + 1;
		name2Index.put(formName, new Integer(vectorIndex));
		maxNames = vectorIndex;

		// get a new formula and insert into Db.
		Formula tempForm = new Formula(formula, formName, parents);
		tempForm.setTimeAdded(currentStep);
		addToDb(tempForm);
		if(firstChange > maxNames) firstChange = maxNames;
		if(Globals.verbose)
		    System.out.println("First change: " + firstChange);
	    } // add

	    //__________________________________________________
	    if(lineRead.startsWith("delete")){
		closePar = lineRead.lastIndexOf(")");
		String tS2 = lineRead.substring(closePar + 1);
		openSq = tS2.indexOf("[");
		formName = tS2.substring(0, openSq).trim();
		vectorIndex = ((Integer)name2Index.get(formName)).intValue();
		removeFromDb(vectorIndex);
		if(Globals.verbose)
		    System.out.println("Delete change " + formName + ": " +
				       vectorIndex);

		if(firstChange > vectorIndex) firstChange = vectorIndex;
	    } // delete

	    //__________________________________________________
	    if(lineRead.startsWith("End")){
		if(Globals.verbose){
		    System.out.println("displayedStep: " + displayedStep);
		    System.out.println("curentStep: " + currentStep);
		}
		if((currentStep - previousDisplayedStep) > 1)
		    firstChange = getFirstChange(displayedStep, currentStep);
		if(Globals.verbose)
		    System.out.println("First change: " + firstChange);

		if(synchronize){
		    maxCaret = updateWindow(firstChange, currentStep);
		    displayedStep = currentStep;
		    firstChange = maxNames;	
		} // if synchronize

	    }// linestarts with "end"
	    ***************************************************/
