;;; 
;;; Here is the file to give to Rasul's program
;;; /usr/local/mcox/prodigy/working/domains/goal-trans/domain.lisp
;;;

(defvar *socket-code-loaded-p* nil
  "When nil, load files for socket code.")

(defparameter *path* "/usr/local/mcox/prodigy/working/domains/goal-trans/domain.lisp")


;;;
;;; For eof-p predicate below.
;;;
(defvar *end-of-file* (gensym)
  "Unique end of file character.")

(defvar *prodigy-base-directory*
  "/usr/local/mcox/prodigy/"
  "Base pathname for the prodigy 4.0 system.")

(defvar *prodigy-root-directory* 
  (concatenate 'string *prodigy-base-directory* 
	       "working/")
  "Pathname for the working system.")

(defvar *system-directory*
  (concatenate 'string *prodigy-root-directory*
	       "system/")
  "Directory holding all source file directories.")

(defvar *prod-ui-home* 
  (concatenate 'string 
	       *system-directory*
	       "ui/"))


(defvar *tcl-home* 
  (concatenate 
   'string
   *prodigy-base-directory*
   "tcl-tk/")
  )

(defvar *tcl-customizations* 
  (concatenate 'string 
	       *prod-ui-home*
	       "example-param-custom.tcl")
  "A string specifying a file with your personal tcl code")

;;; NOTE that this must remain a variable rather than a parameter so that users
;;; can change it. Otherwise the value remains nil when the systrem tries to
;;; load it. [cox 31oct96]
;;;
(defvar *post-tcl-customizations* nil
  "String specifies file with code loaded last that overloads existing code")


(defvar *load-ui-immediately* t
  "If t, then load binaries, else load source code.")


(defvar *ui-modules*
  '(("/lisp-source/"  "tcl" "prod-specific" "ask-rules" "shell" 
     "scrollbutton" "op-graph" "ui" 
     )
    ("/sockets/"  "c-interface" "socket-interface"
     )
   ))


;;; *** LOOK HERE WHEN YOU INSTALL OR COPY PRODIGY ***
;;; You must create the directory specified here, as a subdirectory of
;;; the prodigy "system" directory, below the root directory. If your
;;; lisp version is not mentioned here, you must create an entry for
;;; it and also modify the *binary-extension* variable below.
;;; First, work out what system this is and whether we have the right
;;; compiled files. 
(defun set-binary-path (&optional 
			(module-path
			 *system-directory*))
  (concatenate 'string 
	       module-path
	       #+APPLE "fasl:"
	       #+(and CMU IBM-RT-PC) ".ibm-rt/"
	       #+(and ALLEGRO SUN3 ALLEGRO-V3.1)  ".sun3-allegro-3.1/"
	       #+(and ALLEGRO DEC3100 ALLEGRO-V3.1) ".pmax-allegro/"
	       #+(and ALLEGRO DEC3100 ALLEGRO-V4.1) ".pmax-allegro-4.1/"
	       #+(and ALLEGRO SPARC ALLEGRO-V5.0) ".sparc-allegro-5.0/"
	       #+(and ALLEGRO SPARC ALLEGRO-V4.3.1) ".sparc-allegro-4.3.1/"
	       #+(and ALLEGRO SPARC ALLEGRO-V4.3) ".sparc-allegro-4.3/"
	       #+(and ALLEGRO SPARC ALLEGRO-V4.2) ".sparc-allegro-4.2/"
	       #+(and ALLEGRO SPARC ALLEGRO-V4.1) ".sparc-allegro-4.1/"	       
	       #+(and ALLEGRO SPARC ALLEGRO-V4.0) ".sparc-allegro-4.0/"
	       #+(and ALLEGRO SPARC ALLEGRO-V3.1) ".sparc-allegro-3.1/"
	       #+(and CMU PMAX) ".pmax-cmu/"
	       #+(and CMU SPARC) ".sparc-cmu/"
	       #+(and DOS CLISP) "dosbin/"
	       #+PA ".hp-9000/"
	       #+(and PRISM ALLEGRO-V4.2) ".hp-allegro-4.2/"
	       #+(and LUCID LCL4.0 MIPS) ".pmax-lucid-4.0/"
	       #+(and LUCID LCL4.0 SPARC) ".sparc-lucid-4.0/"
	       #+(and GCL SPARC) ".gnu/"
	       #+(AND GCL UNIX BSD386) ".gnu-linux/"
	       #+CLISP ".clisp/"
	       )
  )

(defvar *ui-binary-pathname*
  (set-binary-path *prod-ui-home*)
  )

;;;
;;; Macro return-val is a utility used by Tcl to read LISP variables without 
;;; crashing if the variable has no value. If no binding, return-val returns 
;;; nil, otherwise, it returns the variable value. Because it is a macro, the 
;;; caller need not quote the variable identifier. See utils.tcl.
;;;
(defmacro return-val (var)
  (if (boundp var)
      var)
  )

      



;;; 
;;; Top-level functions
;;;


(defun spawn-agent (&optional (port *default-port*))
  (if (not (eql port *default-port*))
      (setf *default-port* port))
  (start-socket-server)  
  )


(defun send-obj-strings (&optional 
			 (port *default-port*)
					;(fname (string (get-socket-message)))
			 )
  (start-socket-server t port)
  ;; Wait until input received from socket
  (do ()
      (*last-line-from-socket*
       (format t "READY!~%")))
  (let ((extracted-list (extract-types 
			 *last-line-from-socket*
;			 fname
;			 *in*
			 )))
  (dolist (each-obj-type extracted-list)
    (send-to-socket (concatenate 'string (string each-obj-type) " "))
    )
  (send-to-socket "**end**"))
  )

(defun get-socket-message (&optional (socket-stream *tcl-send*))
  (IPC-READ socket-stream)
  )

;;; Example: (ptype-of OBJECT :top-type)
;;;
;;; This should be implemented as an agent.
;;;
;;; Assumes that types introduced before used.
;;;
;;; Assumes that no object is an intermediate type
;;; For example, given
;;;
;;;  (ptype-of a :top-type)
;;;  (ptype-of b a)
;;;
;;; an object can be of type b, but not of type a. 
;;; NOTE that I actually did this in a few of the domains (the goal-trans
;;; domain?  Which other?)
;;;
(defun extract-types (domain-file-name)
  (with-open-file
      (domain-file domain-file-name
       :direction :input)
    (do* ((next nil 
		(read domain-file 
		      nil 
		      *end-of-file* 
		      nil)) 
	  (types nil 
		 (if (ptype-list-p next)
		     (cond  ((eq (third next) 
				 :top-type)
			     (cons (second next) types))
			    ((intermediate-type-p (third next) types)
			     (substitute (second next) (third next) types))
			    (t		;could be two both isa X and not :top-type
					;on encounter of first of these it will be intermediate-type-p
					;whereas second will be neither intermediate or :top-type
			     (cons (second next) types)))
		   types))
	  )
	((eof-p next)
	 (remove-duplicates 
	  types))
      )
    )
  )

;;;
;;; (ptype-of new-type old-type)
;;; 
;;; Predicate intermediate-type-p returns true only if the parent (old-type) of
;;; the new type is already in the type-list
;;;

(defun intermediate-type-p (old-type type-list)
  (if (member old-type type-list :test #'eql)
      t)
  )

(defun ptype-list-p (alist)
    (if (and 
	 (consp alist)			;This clause also assures not eof
	 (eq (first alist) 
	     'ptype-of))
	t)
    )

;;; 
;;; Predicate eof-p tests whether the char x is the end of file character. It
;;; is used by the function recover-from-disk.
;;; 
(defun eof-p (x)
  (eq x *end-of-file*))





(when (not *socket-code-loaded-p*)
  (setf *socket-code-loaded-p* t)
  (load (concatenate 'string *prod-ui-home* "sockets/c-interface.lisp"))
  (load (concatenate 'string *prod-ui-home* "sockets/socket-interface.lisp"))
  (load "/usr/local/mcox/Research/PRODIGY/Wrapper/socket.lisp")
  )



