;;; This file has the variables, parameters, and misc functions needed by the socket code.


(defvar *prodigy-base-directory*
  "/usr/local/mcox/prodigy/"
  "Base pathname for the prodigy 4.0 system.")

(defvar *prodigy-root-directory* 
  (concatenate 'string *prodigy-base-directory* 
	       "working/")
  "Pathname for the working system.")

(defvar *system-directory*
  (concatenate 'string *prodigy-root-directory*
	       "system/")
  "Directory holding all source file directories.")

(defvar *prod-ui-home* 
  (concatenate 'string 
	       *system-directory*
	       "ui/"))


(defvar *tcl-home* 
  (concatenate 
   'string
   *prodigy-base-directory*
   "tcl-tk/")
  )

(defvar *tcl-customizations* 
  (concatenate 'string 
	       *prod-ui-home*
	       "example-param-custom.tcl")
  "A string specifying a file with your personal tcl code")

;;; NOTE that this must remain a variable rather than a parameter so that users
;;; can change it. Otherwise the value remains nil when the systrem tries to
;;; load it. [cox 31oct96]
;;;
(defvar *post-tcl-customizations* nil
  "String specifies file with code loaded last that overloads existing code")


(defvar *load-ui-immediately* t
  "If t, then load binaries, else load source code.")


;;;
;;; For eof-p predicate below.
;;;
(defvar *end-of-file* (gensym)
  "Unique end of file character.")


(defvar *ui-modules*
  '(("/lisp-source/"  "tcl" "prod-specific" "ask-rules" "shell" 
     "scrollbutton" "op-graph" "ui" 
     )
    ("/sockets/"  "c-interface" "socket-interface"
     )
   ))


;;; *** LOOK HERE WHEN YOU INSTALL OR COPY PRODIGY ***
;;; You must create the directory specified here, as a subdirectory of
;;; the prodigy "system" directory, below the root directory. If your
;;; lisp version is not mentioned here, you must create an entry for
;;; it and also modify the *binary-extension* variable below.
;;; First, work out what system this is and whether we have the right
;;; compiled files. 
(defun set-binary-path (&optional 
			(module-path
			 *system-directory*))
  (concatenate 'string 
	       module-path
	       #+APPLE "fasl:"
	       #+(and CMU IBM-RT-PC) ".ibm-rt/"
	       #+(and ALLEGRO SUN3 ALLEGRO-V3.1)  ".sun3-allegro-3.1/"
	       #+(and ALLEGRO DEC3100 ALLEGRO-V3.1) ".pmax-allegro/"
	       #+(and ALLEGRO DEC3100 ALLEGRO-V4.1) ".pmax-allegro-4.1/"
	       #+(and ALLEGRO SPARC ALLEGRO-V5.0) ".sparc-allegro-5.0/"
	       #+(and ALLEGRO SPARC ALLEGRO-V4.3.1) ".sparc-allegro-4.3.1/"
	       #+(and ALLEGRO SPARC ALLEGRO-V4.3) ".sparc-allegro-4.3/"
	       #+(and ALLEGRO SPARC ALLEGRO-V4.2) ".sparc-allegro-4.2/"
	       #+(and ALLEGRO SPARC ALLEGRO-V4.1) ".sparc-allegro-4.1/"	       
	       #+(and ALLEGRO SPARC ALLEGRO-V4.0) ".sparc-allegro-4.0/"
	       #+(and ALLEGRO SPARC ALLEGRO-V3.1) ".sparc-allegro-3.1/"
	       #+(and CMU PMAX) ".pmax-cmu/"
	       #+(and CMU SPARC) ".sparc-cmu/"
	       #+(and DOS CLISP) "dosbin/"
	       #+PA ".hp-9000/"
	       #+(and PRISM ALLEGRO-V4.2) ".hp-allegro-4.2/"
	       #+(and LUCID LCL4.0 MIPS) ".pmax-lucid-4.0/"
	       #+(and LUCID LCL4.0 SPARC) ".sparc-lucid-4.0/"
	       #+(and GCL SPARC) ".gnu/"
	       #+(AND GCL UNIX BSD386) ".gnu-linux/"
	       #+CLISP ".clisp/"
	       )
  )

(defvar *ui-binary-pathname*
  (set-binary-path *prod-ui-home*)
  )


(defparameter *socket-home*
    "/usr/local/mcox/Research/PRODIGY/Wrapper/sockets/")
    
    
;;;
;;; Macro return-val is a utility used by Tcl to read LISP variables without 
;;; crashing if the variable has no value. If no binding, return-val returns 
;;; nil, otherwise, it returns the variable value. Because it is a macro, the 
;;; caller need not quote the variable identifier. See utils.tcl.
;;;
(defmacro return-val (var)
  (if (boundp var)
      var)
  )


;;; 
;;; Predicate eof-p tests whether the char x is the end of file character. It
;;; is used by the function recover-from-disk.
;;; 
(defun eof-p (x)
  (eq x *end-of-file*))






(when (not *socket-code-loaded-p*)
  (setf *socket-code-loaded-p* t)
  (load (concatenate 'string *prod-ui-home* "sockets/c-interface.lisp"))
  (load (concatenate 'string *prod-ui-home* "sockets/socket-interface.lisp"))
  (load (concatenate 'string *socket-home* "socket.lisp"))
  )



