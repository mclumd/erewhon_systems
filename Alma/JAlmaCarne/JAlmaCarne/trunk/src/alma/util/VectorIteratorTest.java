package alma.util;

import java.util.*;

public class VectorIteratorTest extends TestBase {
	private static class InfiniteIterator implements BiIterator{
		int count = 0;

		public boolean hasPrevious() {
			return count-1 >= 0;
		}

		public Object previous() {
			if (!hasPrevious()) throw new NoSuchElementException("Count Equals:" + count);
			return --count;
		}

		public boolean hasNext() {
			return true;
		}

		public Object next() {
			return count++;
		}

		public void remove() {
		}
	}
	
	private static class FiniteIterator implements BiIterator{
		int count = 0;
		int max;
		
		public FiniteIterator(int i){
			max = i;
		}
		
		public boolean hasPrevious() {
			return count-1 >= 0;
		}

		public Object previous() {
			if (!hasPrevious()) throw new NoSuchElementException("Count Equals:" + count);
			return --count;
		}

		public boolean hasNext() {
			return count < max;
		}

		public Object next() {
			if(!hasNext()) throw new NoSuchElementException("Count Equals:" + count + " --- Max Equals:" +max);
			return count++;
		}

		public void remove() {
		}
	}
	
	public static VectorIterator makeFinite(int m, int n){
		return new VectorIterator(new FiniteIterator(m), new FiniteIterator(n));
	}
	
	public static int size(VectorIterator vi){
		int i=0;
		while(vi.hasNext()){
			vi.next();
			i++;
		}
		
		return i;
	}
	
	/**
	 * Cartesian Product of Finite domains have M x N elements, where M is cardinality of
	 * the first, and N is the cardinality of the second.
	 */
	public static void testFiniteSize(){
		//Should have 1 element. 1x1 == 1
		VectorIterator vi = makeFinite(1,1);
		int size = size(vi);
		assertTrue("Size of Iterator is: "+size, size==1);
		
		//Should have 12 elements, 3x4 == 12
		vi = makeFinite(3,4);
		size = size(vi);
		assertTrue("Size of Iterator is: "+size, size==12);
		
		//Should have 200 elements. 20x10 == 200
		vi = makeFinite(20,10);
		size = size(vi);
		assertTrue("Size of Iterator is: "+size, size==200);
		
		//Should have 0 elements. 2000x0 == 0
		vi = makeFinite(2000,0);
		size = size(vi);
		assertTrue("Size of Iterator is: "+size, size==0);
		
		//Should have 0 elements. 0x2000 == 0
		vi = makeFinite(0,2000);
		size = size(vi);
		assertTrue("Size of Iterator is: "+size, size==0);
		
		for(int i=-5; i<25; i++){
			for(int j=-5; j<25; j++){
				vi = makeFinite(i, j);
				size = size(vi);
				assertTrue(i < 0 || j<0 ? size==0 : size == i*j);
			}
		}
	}
	
	public static void testInfiniteSimple(){
		VectorIterator vi = new VectorIterator(new InfiniteIterator(), new InfiniteIterator());
		
		Object[] o1 = vi.next().flatten();
		Object[] o2 = vi.previous().flatten();
		
		assertTrue(o1[0] == o2[0]);
		assertTrue(o1[1] == o2[1]);
	}
	
	public static void testNoCrash(){
		VectorIterator vi = new VectorIterator(new InfiniteIterator(), new InfiniteIterator());

		/**
		 * Now have an equal number of "next" and "previous" statements and make sure
		 * there are no crashes.
		 */
		
		vi.next();
		vi.previous();
		vi.next();
		vi.previous();
		vi.next();
		vi.next();
		vi.previous();
		vi.previous();
		vi.next();
		vi.next();
		vi.next();
		vi.previous();
		vi.next();
		vi.previous();
		vi.previous();
		vi.previous();
		
		int count = 0;
		for(int i=0; i<500; i++){
			if(count == 0){
				vi.next();
				count ++;
			} else if (Math.random() > .5){
				vi.next(); count++;
			} else {
				vi.previous(); count--;
			}
		}
		
		while(count >0){
			vi.previous();
			count--;
		}
	}
	
	/**
	 * This list of asserts was generated by hand using the diagonalization method.
	 */
	public static void testPair(){
		VectorIterator vi = new VectorIterator(new InfiniteIterator(), new InfiniteIterator());
		
		/*for(int i=0; i<20; i++){
			VectorIterator.Pair p = vi.next();
			Object[] os = p.flatten();
			for(int j=0; j<os.length; j++){
				System.out.print(os[j] + ",");
			}
			System.out.println();
		}
		
		System.out.println("Reverse");
		
		for(int i=0; i<20; i++){
			VectorIterator.Pair p = vi.previous();
			Object[] os = p.flatten();
			for(int j=0; j<os.length; j++){
				System.out.print(os[j] + ",");
			}
			System.out.println();
		}*/
		
		vi = new VectorIterator(new InfiniteIterator(), new InfiniteIterator());
		assertTrue(vi.next().flatten()[0].equals(0));
		assertTrue(vi.next().flatten()[0].equals(1));
		assertTrue(vi.next().flatten()[0].equals(0));
		assertTrue(vi.next().flatten()[0].equals(0));
		assertTrue(vi.next().flatten()[0].equals(1));
		assertTrue(vi.next().flatten()[0].equals(2));
		assertTrue(vi.next().flatten()[0].equals(3));
		assertTrue(vi.next().flatten()[0].equals(2));
		assertTrue(vi.next().flatten()[0].equals(1));
		assertTrue(vi.next().flatten()[0].equals(0));
		assertTrue(vi.next().flatten()[0].equals(0));
		assertTrue(vi.next().flatten()[0].equals(1));
		assertTrue(vi.next().flatten()[0].equals(2));
		assertTrue(vi.next().flatten()[0].equals(3));
		assertTrue(vi.next().flatten()[0].equals(4));
		assertTrue(vi.next().flatten()[0].equals(5));
		assertTrue(vi.next().flatten()[0].equals(4));
		assertTrue(vi.next().flatten()[0].equals(3));
		assertTrue(vi.next().flatten()[0].equals(2));
		assertTrue(vi.next().flatten()[0].equals(1));
		assertTrue(vi.next().flatten()[0].equals(0));
		
		assertTrue(vi.previous().flatten()[0].equals(0));
		assertTrue(vi.previous().flatten()[0].equals(1));
		assertTrue(vi.previous().flatten()[0].equals(2));
		assertTrue(vi.previous().flatten()[0].equals(3));
		assertTrue(vi.previous().flatten()[0].equals(4));
		assertTrue(vi.previous().flatten()[0].equals(5));
		assertTrue(vi.previous().flatten()[0].equals(4));
		assertTrue(vi.previous().flatten()[0].equals(3));
		assertTrue(vi.previous().flatten()[0].equals(2));
		assertTrue(vi.previous().flatten()[0].equals(1));
		assertTrue(vi.previous().flatten()[0].equals(0));
		assertTrue(vi.previous().flatten()[0].equals(0));
		assertTrue(vi.previous().flatten()[0].equals(1));
		assertTrue(vi.previous().flatten()[0].equals(2));
		assertTrue(vi.previous().flatten()[0].equals(3));
		assertTrue(vi.previous().flatten()[0].equals(2));
		assertTrue(vi.previous().flatten()[0].equals(1));
		assertTrue(vi.previous().flatten()[0].equals(0));
		assertTrue(vi.previous().flatten()[0].equals(0));
		assertTrue(vi.previous().flatten()[0].equals(1));
		assertTrue(vi.previous().flatten()[0].equals(0));
		
		assertTrue(vi.next().flatten()[0].equals(0));
		assertTrue(vi.next().flatten()[0].equals(1));
		assertTrue(vi.next().flatten()[0].equals(0));
		assertTrue(vi.next().flatten()[0].equals(0));
		assertTrue(vi.next().flatten()[0].equals(1));
		assertTrue(vi.next().flatten()[0].equals(2));
		assertTrue(vi.next().flatten()[0].equals(3));
		assertTrue(vi.next().flatten()[0].equals(2));
		assertTrue(vi.next().flatten()[0].equals(1));
		assertTrue(vi.next().flatten()[0].equals(0));
		assertTrue(vi.next().flatten()[0].equals(0));
		assertTrue(vi.next().flatten()[0].equals(1));
		assertTrue(vi.next().flatten()[0].equals(2));
		assertTrue(vi.next().flatten()[0].equals(3));
		assertTrue(vi.next().flatten()[0].equals(4));
		assertTrue(vi.next().flatten()[0].equals(5));
		assertTrue(vi.next().flatten()[0].equals(4));
		assertTrue(vi.next().flatten()[0].equals(3));
		assertTrue(vi.next().flatten()[0].equals(2));
		assertTrue(vi.next().flatten()[0].equals(1));
		assertTrue(vi.next().flatten()[0].equals(0));
		
		vi = new VectorIterator(new InfiniteIterator(), new InfiniteIterator());
		assertTrue(vi.next().flatten()[1].equals(0));
		assertTrue(vi.next().flatten()[1].equals(0));
		assertTrue(vi.next().flatten()[1].equals(1));
		assertTrue(vi.next().flatten()[1].equals(2));
		assertTrue(vi.next().flatten()[1].equals(1));
		assertTrue(vi.next().flatten()[1].equals(0));
		assertTrue(vi.next().flatten()[1].equals(0));
		assertTrue(vi.next().flatten()[1].equals(1));
		assertTrue(vi.next().flatten()[1].equals(2));
		assertTrue(vi.next().flatten()[1].equals(3));
		assertTrue(vi.next().flatten()[1].equals(4));
		assertTrue(vi.next().flatten()[1].equals(3));
		assertTrue(vi.next().flatten()[1].equals(2));
		assertTrue(vi.next().flatten()[1].equals(1));
		assertTrue(vi.next().flatten()[1].equals(0));
		assertTrue(vi.next().flatten()[1].equals(0));
		assertTrue(vi.next().flatten()[1].equals(1));
		assertTrue(vi.next().flatten()[1].equals(2));
		assertTrue(vi.next().flatten()[1].equals(3));
		assertTrue(vi.next().flatten()[1].equals(4));
		assertTrue(vi.next().flatten()[1].equals(5));
		assertTrue(vi.next().flatten()[1].equals(6));
		
		assertTrue(vi.previous().flatten()[1].equals(6));
		assertTrue(vi.previous().flatten()[1].equals(5));
		assertTrue(vi.previous().flatten()[1].equals(4));
		assertTrue(vi.previous().flatten()[1].equals(3));
		assertTrue(vi.previous().flatten()[1].equals(2));
		assertTrue(vi.previous().flatten()[1].equals(1));
		assertTrue(vi.previous().flatten()[1].equals(0));
		assertTrue(vi.previous().flatten()[1].equals(0));
		assertTrue(vi.previous().flatten()[1].equals(1));
		assertTrue(vi.previous().flatten()[1].equals(2));
		assertTrue(vi.previous().flatten()[1].equals(3));
		assertTrue(vi.previous().flatten()[1].equals(4));
		assertTrue(vi.previous().flatten()[1].equals(3));
		assertTrue(vi.previous().flatten()[1].equals(2));
		assertTrue(vi.previous().flatten()[1].equals(1));
		assertTrue(vi.previous().flatten()[1].equals(0));
		assertTrue(vi.previous().flatten()[1].equals(0));
		assertTrue(vi.previous().flatten()[1].equals(1));
		assertTrue(vi.previous().flatten()[1].equals(2));
		assertTrue(vi.previous().flatten()[1].equals(1));
		assertTrue(vi.previous().flatten()[1].equals(0));
		assertTrue(vi.previous().flatten()[1].equals(0));
	}
	
	/**
	 * Assert "no visiting": if the input iterators have a lack of revisiting, then the
	 * output vector iterator should never revisit. Every "next" should be unique, and every
	 * "Previous" should revisit elements exactly once. This test tests for this property.
	 */	
	public static void testQuad(){
		//We can clearly see that "InfiniteIterators" do not repeat.
		VectorIterator tmp = new VectorIterator(new InfiniteIterator(), new InfiniteIterator());
		VectorIterator tmp2 = new VectorIterator(new InfiniteIterator(), new InfiniteIterator());
		VectorIterator vi = new VectorIterator(tmp, tmp2);
		
		HashSet<List<Object>> check = new HashSet();
		
		for(int i=0; i<2000; i++){
			VectorIterator.Pair p = vi.next();
			Object[] os = p.flatten();
			List<Object> lat = Arrays.asList(os);
			assertFalse(check.contains(lat));
			check.add(lat);
			/*for(int j=0; j<os.length; j++){
				System.out.print(os[j] + ",");
			}
			System.out.println();*/
		}
		
		for(int i=0; i<2000; i++){
			VectorIterator.Pair p = vi.previous();
			Object[] os = p.flatten();
			List lat = Arrays.asList(os);
			assertTrue(check.contains(lat));
			check.remove(lat);
		}
	}
}